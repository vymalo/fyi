import { createRequire } from "node:module";
import { Cli, Command, Option } from "clipanion";
import path, { dirname, isAbsolute, join, parse, resolve } from "node:path";
import * as colors from "colorette";
import { underline, yellow } from "colorette";
import { createDebug } from "obug";
import { access, copyFile, mkdir, readFile, readdir, rename, stat, unlink, writeFile } from "node:fs/promises";
import { exec, execSync, spawn, spawnSync } from "node:child_process";
import fs, { existsSync, mkdirSync, promises, rmSync, statSync } from "node:fs";
import { isNil, merge, omit, omitBy, pick, sortBy } from "es-toolkit";
import { createHash } from "node:crypto";
import { homedir } from "node:os";
import { parse as parse$1 } from "semver";
import { dump, load } from "js-yaml";
import * as typanion from "typanion";
import { Octokit } from "@octokit/rest";
import { checkbox, confirm, input, select } from "@inquirer/prompts";

//#region src/def/artifacts.ts
var BaseArtifactsCommand = class extends Command {
	static paths = [["artifacts"]];
	static usage = Command.Usage({ description: "Copy artifacts from Github Actions into npm packages and ready to publish" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o,-d", "./artifacts", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	buildOutputDir = Option.String("--build-output-dir", { description: "Path to the build output dir, only needed when targets contains `wasm32-wasi-*`" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir,
			npmDir: this.npmDir,
			buildOutputDir: this.buildOutputDir
		};
	}
};
function applyDefaultArtifactsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./artifacts",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/utils/log.ts
const debugFactory = (namespace) => {
	const debug$10 = createDebug(`napi:${namespace}`, { formatters: { i(v) {
		return colors.green(v);
	} } });
	debug$10.info = (...args) => console.error(colors.black(colors.bgGreen(" INFO ")), ...args);
	debug$10.warn = (...args) => console.error(colors.black(colors.bgYellow(" WARNING ")), ...args);
	debug$10.error = (...args) => console.error(colors.white(colors.bgRed(" ERROR ")), ...args.map((arg) => arg instanceof Error ? arg.stack ?? arg.message : arg));
	return debug$10;
};
const debug$9 = debugFactory("utils");

//#endregion
//#region package.json
var version$1 = "3.5.0";

//#endregion
//#region src/utils/misc.ts
const readFileAsync = readFile;
const writeFileAsync = writeFile;
const unlinkAsync = unlink;
const copyFileAsync = copyFile;
const mkdirAsync = mkdir;
const statAsync = stat;
const readdirAsync = readdir;
function fileExists(path$1) {
	return access(path$1).then(() => true, () => false);
}
async function dirExistsAsync(path$1) {
	try {
		return (await statAsync(path$1)).isDirectory();
	} catch {
		return false;
	}
}
function pick$1(o, ...keys) {
	return keys.reduce((acc, key) => {
		acc[key] = o[key];
		return acc;
	}, {});
}
async function updatePackageJson(path$1, partial) {
	if (!await fileExists(path$1)) {
		debug$9(`File not exists ${path$1}`);
		return;
	}
	const old = JSON.parse(await readFileAsync(path$1, "utf8"));
	await writeFileAsync(path$1, JSON.stringify({
		...old,
		...partial
	}, null, 2));
}
const CLI_VERSION = version$1;

//#endregion
//#region src/utils/target.ts
const SUB_SYSTEMS = new Set(["android", "ohos"]);
const AVAILABLE_TARGETS = [
	"aarch64-apple-darwin",
	"aarch64-linux-android",
	"aarch64-unknown-linux-gnu",
	"aarch64-unknown-linux-musl",
	"aarch64-unknown-linux-ohos",
	"aarch64-pc-windows-msvc",
	"x86_64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-pc-windows-gnu",
	"x86_64-unknown-linux-gnu",
	"x86_64-unknown-linux-musl",
	"x86_64-unknown-linux-ohos",
	"x86_64-unknown-freebsd",
	"i686-pc-windows-msvc",
	"armv7-unknown-linux-gnueabihf",
	"armv7-unknown-linux-musleabihf",
	"armv7-linux-androideabi",
	"universal-apple-darwin",
	"loongarch64-unknown-linux-gnu",
	"riscv64gc-unknown-linux-gnu",
	"powerpc64le-unknown-linux-gnu",
	"s390x-unknown-linux-gnu",
	"wasm32-wasi-preview1-threads",
	"wasm32-wasip1-threads"
];
const DEFAULT_TARGETS = [
	"x86_64-apple-darwin",
	"aarch64-apple-darwin",
	"x86_64-pc-windows-msvc",
	"x86_64-unknown-linux-gnu"
];
const TARGET_LINKER = {
	"aarch64-unknown-linux-musl": "aarch64-linux-musl-gcc",
	"loongarch64-unknown-linux-gnu": "loongarch64-linux-gnu-gcc-13",
	"riscv64gc-unknown-linux-gnu": "riscv64-linux-gnu-gcc",
	"powerpc64le-unknown-linux-gnu": "powerpc64le-linux-gnu-gcc",
	"s390x-unknown-linux-gnu": "s390x-linux-gnu-gcc"
};
const CpuToNodeArch = {
	x86_64: "x64",
	aarch64: "arm64",
	i686: "ia32",
	armv7: "arm",
	loongarch64: "loong64",
	riscv64gc: "riscv64",
	powerpc64le: "ppc64"
};
const SysToNodePlatform = {
	linux: "linux",
	freebsd: "freebsd",
	darwin: "darwin",
	windows: "win32",
	ohos: "openharmony"
};
const UniArchsByPlatform = { darwin: ["x64", "arm64"] };
/**
* A triple is a specific format for specifying a target architecture.
* Triples may be referred to as a target triple which is the architecture for the artifact produced, and the host triple which is the architecture that the compiler is running on.
* The general format of the triple is `<arch><sub>-<vendor>-<sys>-<abi>` where:
*   - `arch` = The base CPU architecture, for example `x86_64`, `i686`, `arm`, `thumb`, `mips`, etc.
*   - `sub` = The CPU sub-architecture, for example `arm` has `v7`, `v7s`, `v5te`, etc.
*   - `vendor` = The vendor, for example `unknown`, `apple`, `pc`, `nvidia`, etc.
*   - `sys` = The system name, for example `linux`, `windows`, `darwin`, etc. none is typically used for bare-metal without an OS.
*   - `abi` = The ABI, for example `gnu`, `android`, `eabi`, etc.
*/
function parseTriple(rawTriple) {
	if (rawTriple === "wasm32-wasi" || rawTriple === "wasm32-wasi-preview1-threads" || rawTriple.startsWith("wasm32-wasip")) return {
		triple: rawTriple,
		platformArchABI: "wasm32-wasi",
		platform: "wasi",
		arch: "wasm32",
		abi: "wasi"
	};
	const triples = (rawTriple.endsWith("eabi") ? `${rawTriple.slice(0, -4)}-eabi` : rawTriple).split("-");
	let cpu;
	let sys;
	let abi = null;
	if (triples.length === 2) [cpu, sys] = triples;
	else [cpu, , sys, abi = null] = triples;
	if (abi && SUB_SYSTEMS.has(abi)) {
		sys = abi;
		abi = null;
	}
	const platform = SysToNodePlatform[sys] ?? sys;
	const arch = CpuToNodeArch[cpu] ?? cpu;
	return {
		triple: rawTriple,
		platformArchABI: abi ? `${platform}-${arch}-${abi}` : `${platform}-${arch}`,
		platform,
		arch,
		abi
	};
}
function getSystemDefaultTarget() {
	const host = execSync(`rustc -vV`, { env: process.env }).toString("utf8").split("\n").find((line) => line.startsWith("host: "));
	const triple = host === null || host === void 0 ? void 0 : host.slice(6);
	if (!triple) throw new TypeError(`Can not parse target triple from host`);
	return parseTriple(triple);
}
function getTargetLinker(target) {
	return TARGET_LINKER[target];
}
function targetToEnvVar(target) {
	return target.replace(/-/g, "_").toUpperCase();
}

//#endregion
//#region src/utils/version.ts
let NapiVersion = /* @__PURE__ */ function(NapiVersion$1) {
	NapiVersion$1[NapiVersion$1["Napi1"] = 1] = "Napi1";
	NapiVersion$1[NapiVersion$1["Napi2"] = 2] = "Napi2";
	NapiVersion$1[NapiVersion$1["Napi3"] = 3] = "Napi3";
	NapiVersion$1[NapiVersion$1["Napi4"] = 4] = "Napi4";
	NapiVersion$1[NapiVersion$1["Napi5"] = 5] = "Napi5";
	NapiVersion$1[NapiVersion$1["Napi6"] = 6] = "Napi6";
	NapiVersion$1[NapiVersion$1["Napi7"] = 7] = "Napi7";
	NapiVersion$1[NapiVersion$1["Napi8"] = 8] = "Napi8";
	NapiVersion$1[NapiVersion$1["Napi9"] = 9] = "Napi9";
	return NapiVersion$1;
}({});
const NAPI_VERSION_MATRIX = new Map([
	[NapiVersion.Napi1, "8.6.0 | 9.0.0 | 10.0.0"],
	[NapiVersion.Napi2, "8.10.0 | 9.3.0 | 10.0.0"],
	[NapiVersion.Napi3, "6.14.2 | 8.11.2 | 9.11.0 | 10.0.0"],
	[NapiVersion.Napi4, "10.16.0 | 11.8.0 | 12.0.0"],
	[NapiVersion.Napi5, "10.17.0 | 12.11.0 | 13.0.0"],
	[NapiVersion.Napi6, "10.20.0 | 12.17.0 | 14.0.0"],
	[NapiVersion.Napi7, "10.23.0 | 12.19.0 | 14.12.0 | 15.0.0"],
	[NapiVersion.Napi8, "12.22.0 | 14.17.0 | 15.12.0 | 16.0.0"],
	[NapiVersion.Napi9, "18.17.0 | 20.3.0 | 21.1.0"]
]);
function parseNodeVersion(v) {
	const matches = v.match(/v?([0-9]+)\.([0-9]+)\.([0-9]+)/i);
	if (!matches) throw new Error("Unknown node version number: " + v);
	const [, major, minor, patch] = matches;
	return {
		major: parseInt(major),
		minor: parseInt(minor),
		patch: parseInt(patch)
	};
}
function requiredNodeVersions(napiVersion) {
	const requirement = NAPI_VERSION_MATRIX.get(napiVersion);
	if (!requirement) return [parseNodeVersion("10.0.0")];
	return requirement.split("|").map(parseNodeVersion);
}
function toEngineRequirement(versions) {
	const requirements = [];
	versions.forEach((v, i) => {
		let req = "";
		if (i !== 0) {
			const lastVersion = versions[i - 1];
			req += `< ${lastVersion.major + 1}`;
		}
		req += `${i === 0 ? "" : " || "}>= ${v.major}.${v.minor}.${v.patch}`;
		requirements.push(req);
	});
	return requirements.join(" ");
}
function napiEngineRequirement(napiVersion) {
	return toEngineRequirement(requiredNodeVersions(napiVersion));
}

//#endregion
//#region src/utils/metadata.ts
async function parseMetadata(manifestPath) {
	if (!fs.existsSync(manifestPath)) throw new Error(`No crate found in manifest: ${manifestPath}`);
	const childProcess = spawn("cargo", [
		"metadata",
		"--manifest-path",
		manifestPath,
		"--format-version",
		"1"
	], { stdio: "pipe" });
	let stdout = "";
	let stderr = "";
	let status = 0;
	childProcess.stdout.on("data", (data) => {
		stdout += data;
	});
	childProcess.stderr.on("data", (data) => {
		stderr += data;
	});
	await new Promise((resolve$1) => {
		childProcess.on("close", (code) => {
			status = code ?? 0;
			resolve$1();
		});
	});
	if (status !== 0) {
		const simpleMessage = `cargo metadata exited with code ${status}`;
		throw new Error(`${simpleMessage} and error message:\n\n${stderr}`, { cause: new Error(simpleMessage) });
	}
	try {
		return JSON.parse(stdout);
	} catch (e) {
		throw new Error("Failed to parse cargo metadata JSON", { cause: e });
	}
}

//#endregion
//#region src/utils/config.ts
async function readNapiConfig(path$1, configPath) {
	if (configPath && !await fileExists(configPath)) throw new Error(`NAPI-RS config not found at ${configPath}`);
	if (!await fileExists(path$1)) throw new Error(`package.json not found at ${path$1}`);
	const content = await readFileAsync(path$1, "utf8");
	let pkgJson;
	try {
		pkgJson = JSON.parse(content);
	} catch (e) {
		throw new Error(`Failed to parse package.json at ${path$1}`, { cause: e });
	}
	let separatedConfig;
	if (configPath) {
		const configContent = await readFileAsync(configPath, "utf8");
		try {
			separatedConfig = JSON.parse(configContent);
		} catch (e) {
			throw new Error(`Failed to parse NAPI-RS config at ${configPath}`, { cause: e });
		}
	}
	const userNapiConfig = pkgJson.napi ?? {};
	if (pkgJson.napi && separatedConfig) {
		const pkgJsonPath = underline(path$1);
		const configPathUnderline = underline(configPath);
		console.warn(yellow(`Both napi field in ${pkgJsonPath} and [NAPI-RS config](${configPathUnderline}) file are found, the NAPI-RS config file will be used.`));
		Object.assign(userNapiConfig, separatedConfig);
	}
	const napiConfig = merge({
		binaryName: "index",
		packageName: pkgJson.name,
		targets: [],
		packageJson: pkgJson,
		npmClient: "npm"
	}, omit(userNapiConfig, ["targets"]));
	let targets = userNapiConfig.targets ?? [];
	if (userNapiConfig === null || userNapiConfig === void 0 ? void 0 : userNapiConfig.name) {
		console.warn(yellow(`[DEPRECATED] napi.name is deprecated, use napi.binaryName instead.`));
		napiConfig.binaryName = userNapiConfig.name;
	}
	if (!targets.length) {
		var _userNapiConfig$tripl, _userNapiConfig$tripl2;
		let deprecatedWarned = false;
		const warning = yellow(`[DEPRECATED] napi.triples is deprecated, use napi.targets instead.`);
		if ((_userNapiConfig$tripl = userNapiConfig.triples) === null || _userNapiConfig$tripl === void 0 ? void 0 : _userNapiConfig$tripl.defaults) {
			deprecatedWarned = true;
			console.warn(warning);
			targets = targets.concat(DEFAULT_TARGETS);
		}
		if ((_userNapiConfig$tripl2 = userNapiConfig.triples) === null || _userNapiConfig$tripl2 === void 0 || (_userNapiConfig$tripl2 = _userNapiConfig$tripl2.additional) === null || _userNapiConfig$tripl2 === void 0 ? void 0 : _userNapiConfig$tripl2.length) {
			targets = targets.concat(userNapiConfig.triples.additional);
			if (!deprecatedWarned) console.warn(warning);
		}
	}
	if (new Set(targets).size !== targets.length) {
		const duplicateTarget = targets.find((target, index) => targets.indexOf(target) !== index);
		throw new Error(`Duplicate targets are not allowed: ${duplicateTarget}`);
	}
	napiConfig.targets = targets.map(parseTriple);
	return napiConfig;
}

//#endregion
//#region src/utils/cargo.ts
function tryInstallCargoBinary(name, bin) {
	if (detectCargoBinary(bin)) {
		debug$9("Cargo binary already installed: %s", name);
		return;
	}
	try {
		debug$9("Installing cargo binary: %s", name);
		execSync(`cargo install ${name}`, { stdio: "inherit" });
	} catch (e) {
		throw new Error(`Failed to install cargo binary: ${name}`, { cause: e });
	}
}
function detectCargoBinary(bin) {
	debug$9("Detecting cargo binary: %s", bin);
	try {
		execSync(`cargo help ${bin}`, { stdio: "ignore" });
		debug$9("Cargo binary detected: %s", bin);
		return true;
	} catch {
		debug$9("Cargo binary not detected: %s", bin);
		return false;
	}
}

//#endregion
//#region src/utils/typegen.ts
const TOP_LEVEL_NAMESPACE = "__TOP_LEVEL_MODULE__";
const DEFAULT_TYPE_DEF_HEADER = `/* auto-generated by NAPI-RS */
/* eslint-disable */
`;
var TypeDefKind = /* @__PURE__ */ function(TypeDefKind$1) {
	TypeDefKind$1["Const"] = "const";
	TypeDefKind$1["Enum"] = "enum";
	TypeDefKind$1["StringEnum"] = "string_enum";
	TypeDefKind$1["Interface"] = "interface";
	TypeDefKind$1["Type"] = "type";
	TypeDefKind$1["Fn"] = "fn";
	TypeDefKind$1["Struct"] = "struct";
	TypeDefKind$1["Extends"] = "extends";
	TypeDefKind$1["Impl"] = "impl";
	return TypeDefKind$1;
}(TypeDefKind || {});
function prettyPrint(line, constEnum, ident, ambient = false) {
	let s = line.js_doc ?? "";
	switch (line.kind) {
		case TypeDefKind.Interface:
			s += `export interface ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.Type:
			s += `export type ${line.name} = \n${line.def}`;
			break;
		case TypeDefKind.Enum:
			const enumName = constEnum ? "const enum" : "enum";
			s += `${exportDeclare(ambient)} ${enumName} ${line.name} {\n${line.def}\n}`;
			break;
		case TypeDefKind.StringEnum:
			if (constEnum) s += `${exportDeclare(ambient)} const enum ${line.name} {\n${line.def}\n}`;
			else s += `export type ${line.name} = ${line.def.replaceAll(/.*=/g, "").replaceAll(",", "|")};`;
			break;
		case TypeDefKind.Struct:
			const extendsDef = line.extends ? ` extends ${line.extends}` : "";
			if (line.extends) {
				const genericMatch = line.extends.match(/Iterator<(.+)>$/);
				if (genericMatch) {
					const [T, TResult, TNext] = genericMatch[1].split(",").map((p) => p.trim());
					line.def = line.def + `\nnext(value?: ${TNext}): IteratorResult<${T}, ${TResult}>`;
				}
			}
			s += `${exportDeclare(ambient)} class ${line.name}${extendsDef} {\n${line.def}\n}`;
			if (line.original_name && line.original_name !== line.name) s += `\nexport type ${line.original_name} = ${line.name}`;
			break;
		case TypeDefKind.Fn:
			s += `${exportDeclare(ambient)} ${line.def}`;
			break;
		default: s += line.def;
	}
	return correctStringIdent(s, ident);
}
function exportDeclare(ambient) {
	if (ambient) return "export";
	return "export declare";
}
async function processTypeDef(intermediateTypeFile, constEnum) {
	const exports = [];
	const groupedDefs = preprocessTypeDef(await readIntermediateTypeFile(intermediateTypeFile));
	return {
		dts: sortBy(Array.from(groupedDefs), [([namespace]) => namespace]).map(([namespace, defs]) => {
			if (namespace === TOP_LEVEL_NAMESPACE) return defs.map((def) => {
				switch (def.kind) {
					case TypeDefKind.Const:
					case TypeDefKind.Enum:
					case TypeDefKind.StringEnum:
					case TypeDefKind.Fn:
					case TypeDefKind.Struct:
						exports.push(def.name);
						if (def.original_name && def.original_name !== def.name) exports.push(def.original_name);
						break;
					default: break;
				}
				return prettyPrint(def, constEnum, 0);
			}).join("\n\n");
			else {
				exports.push(namespace);
				let declaration = "";
				declaration += `export declare namespace ${namespace} {\n`;
				for (const def of defs) declaration += prettyPrint(def, constEnum, 2, true) + "\n";
				declaration += "}";
				return declaration;
			}
		}).join("\n\n") + "\n",
		exports
	};
}
async function readIntermediateTypeFile(file) {
	return (await readFileAsync(file, "utf8")).split("\n").filter(Boolean).map((line) => {
		line = line.trim();
		const parsed = JSON.parse(line);
		if (parsed.js_doc) parsed.js_doc = parsed.js_doc.replace(/\\n/g, "\n");
		if (parsed.def) parsed.def = parsed.def.replace(/\\n/g, "\n");
		return parsed;
	}).sort((a, b) => {
		if (a.kind === TypeDefKind.Struct) {
			if (b.kind === TypeDefKind.Struct) return a.name.localeCompare(b.name);
			return -1;
		} else if (b.kind === TypeDefKind.Struct) return 1;
		else return a.name.localeCompare(b.name);
	});
}
function preprocessTypeDef(defs) {
	const namespaceGrouped = /* @__PURE__ */ new Map();
	const classDefs = /* @__PURE__ */ new Map();
	for (const def of defs) {
		const namespace = def.js_mod ?? TOP_LEVEL_NAMESPACE;
		if (!namespaceGrouped.has(namespace)) namespaceGrouped.set(namespace, []);
		const group = namespaceGrouped.get(namespace);
		if (def.kind === TypeDefKind.Struct) {
			group.push(def);
			classDefs.set(def.name, def);
		} else if (def.kind === TypeDefKind.Extends) {
			const classDef = classDefs.get(def.name);
			if (classDef) classDef.extends = def.def;
		} else if (def.kind === TypeDefKind.Impl) {
			const classDef = classDefs.get(def.name);
			if (classDef) {
				if (classDef.def) classDef.def += "\n";
				classDef.def += def.def;
				if (classDef.def) classDef.def = classDef.def.replace(/\\n/g, "\n");
			}
		} else group.push(def);
	}
	return namespaceGrouped;
}
function correctStringIdent(src, ident) {
	let bracketDepth = 0;
	return src.split("\n").map((line) => {
		line = line.trim();
		if (line === "") return "";
		const isInMultilineComment = line.startsWith("*");
		const isClosingBracket = line.endsWith("}");
		const isOpeningBracket = line.endsWith("{");
		const isTypeDeclaration = line.endsWith("=");
		const isTypeVariant = line.startsWith("|");
		let rightIndent = ident;
		if ((isOpeningBracket || isTypeDeclaration) && !isInMultilineComment) {
			bracketDepth += 1;
			rightIndent += (bracketDepth - 1) * 2;
		} else {
			if (isClosingBracket && bracketDepth > 0 && !isInMultilineComment && !isTypeVariant) bracketDepth -= 1;
			rightIndent += bracketDepth * 2;
		}
		if (isInMultilineComment) rightIndent += 1;
		return `${" ".repeat(rightIndent)}${line}`;
	}).join("\n");
}

//#endregion
//#region src/utils/read-config.ts
async function readConfig(options) {
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	return await readNapiConfig(resolvePath(options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0);
}

//#endregion
//#region src/api/artifacts.ts
const debug$8 = debugFactory("artifacts");
async function collectArtifacts(userOptions) {
	const options = applyDefaultArtifactsOptions(userOptions);
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const packageJsonPath = resolvePath(options.packageJsonPath);
	const { targets, binaryName, packageName } = await readNapiConfig(packageJsonPath, options.configPath ? resolvePath(options.configPath) : void 0);
	const distDirs = targets.map((platform) => join(options.cwd, options.npmDir, platform.platformArchABI));
	const universalSourceBins = new Set(targets.filter((platform) => platform.arch === "universal").flatMap((p) => {
		var _UniArchsByPlatform$p;
		return (_UniArchsByPlatform$p = UniArchsByPlatform[p.platform]) === null || _UniArchsByPlatform$p === void 0 ? void 0 : _UniArchsByPlatform$p.map((a) => `${p.platform}-${a}`);
	}).filter(Boolean));
	await collectNodeBinaries(join(options.cwd, options.outputDir)).then((output) => Promise.all(output.map(async (filePath) => {
		debug$8.info(`Read [${colors.yellowBright(filePath)}]`);
		const sourceContent = await readFileAsync(filePath);
		const parsedName = parse(filePath);
		const terms = parsedName.name.split(".");
		const platformArchABI = terms.pop();
		const _binaryName = terms.join(".");
		if (_binaryName !== binaryName) {
			debug$8.warn(`[${_binaryName}] is not matched with [${binaryName}], skip`);
			return;
		}
		const dir$1 = distDirs.find((dir$2) => dir$2.includes(platformArchABI));
		if (!dir$1 && universalSourceBins.has(platformArchABI)) {
			debug$8.warn(`[${platformArchABI}] has no dist dir but it is source bin for universal arch, skip`);
			return;
		}
		if (!dir$1) throw new Error(`No dist dir found for ${filePath}`);
		const distFilePath = join(dir$1, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePath)}]`);
		await writeFileAsync(distFilePath, sourceContent);
		const distFilePathLocal = join(parse(packageJsonPath).dir, parsedName.base);
		debug$8.info(`Write file content to [${colors.yellowBright(distFilePathLocal)}]`);
		await writeFileAsync(distFilePathLocal, sourceContent);
	})));
	const wasiTarget = targets.find((t) => t.platform === "wasi");
	if (wasiTarget) {
		const wasiDir = join(options.cwd, options.npmDir, wasiTarget.platformArchABI);
		const cjsFile = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi.cjs`);
		const workerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker.mjs`);
		const browserEntry = join(options.buildOutputDir ?? options.cwd, `${binaryName}.wasi-browser.js`);
		const browserWorkerFile = join(options.buildOutputDir ?? options.cwd, `wasi-worker-browser.mjs`);
		debug$8.info(`Move wasi binding file [${colors.yellowBright(cjsFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi.cjs`), await readFileAsync(cjsFile));
		debug$8.info(`Move wasi worker file [${colors.yellowBright(workerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker.mjs`), await readFileAsync(workerFile));
		debug$8.info(`Move wasi browser entry file [${colors.yellowBright(browserEntry)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `${binaryName}.wasi-browser.js`), (await readFileAsync(browserEntry, "utf8")).replace(`new URL('./wasi-worker-browser.mjs', import.meta.url)`, `new URL('${packageName}-wasm32-wasi/wasi-worker-browser.mjs', import.meta.url)`));
		debug$8.info(`Move wasi browser worker file [${colors.yellowBright(browserWorkerFile)}] to [${colors.yellowBright(wasiDir)}]`);
		await writeFileAsync(join(wasiDir, `wasi-worker-browser.mjs`), await readFileAsync(browserWorkerFile));
	}
}
async function collectNodeBinaries(root) {
	const files = await readdirAsync(root, { withFileTypes: true });
	const nodeBinaries = files.filter((file) => file.isFile() && (file.name.endsWith(".node") || file.name.endsWith(".wasm"))).map((file) => join(root, file.name));
	const dirs = files.filter((file) => file.isDirectory());
	for (const dir$1 of dirs) if (dir$1.name !== "node_modules") nodeBinaries.push(...await collectNodeBinaries(join(root, dir$1.name)));
	return nodeBinaries;
}

//#endregion
//#region src/api/templates/js-binding.ts
function createCjsBinding(localName, pkgName, idents, packageVersion) {
	return `${bindingHeader}
${createCommonBinding(localName, pkgName, packageVersion)}
module.exports = nativeBinding
${idents.map((ident) => `module.exports.${ident} = nativeBinding.${ident}`).join("\n")}
`;
}
function createEsmBinding(localName, pkgName, idents, packageVersion) {
	return `${bindingHeader}
import { createRequire } from 'node:module'
const require = createRequire(import.meta.url)
const __dirname = new URL('.', import.meta.url).pathname

${createCommonBinding(localName, pkgName, packageVersion)}
const { ${idents.join(", ")} } = nativeBinding
${idents.map((ident) => `export { ${ident} }`).join("\n")}
`;
}
const bindingHeader = `// prettier-ignore
/* eslint-disable */
// @ts-nocheck
/* auto-generated by NAPI-RS */
`;
function createCommonBinding(localName, pkgName, packageVersion) {
	function requireTuple(tuple, identSize = 8) {
		const identLow = " ".repeat(identSize - 2);
		const ident = " ".repeat(identSize);
		return `try {
${ident}return require('./${localName}.${tuple}.node')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}${packageVersion ? `
${identLow}try {
${ident}const binding = require('${pkgName}-${tuple}')
${ident}const bindingPackageVersion = require('${pkgName}-${tuple}/package.json').version
${ident}if (bindingPackageVersion !== '${packageVersion}' && process.env.NAPI_RS_ENFORCE_VERSION_CHECK && process.env.NAPI_RS_ENFORCE_VERSION_CHECK !== '0') {
${ident}  throw new Error(\`Native binding package version mismatch, expected ${packageVersion} but got \${bindingPackageVersion}. You can reinstall dependencies to fix this issue.\`)
${ident}}
${ident}return binding
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}` : `
${identLow}try {
${ident}return require('${pkgName}-${tuple}')
${identLow}} catch (e) {
${ident}loadErrors.push(e)
${identLow}}`}`;
	}
	return `const { readFileSync } = require('node:fs')
let nativeBinding = null
const loadErrors = []

const isMusl = () => {
  let musl = false
  if (process.platform === 'linux') {
    musl = isMuslFromFilesystem()
    if (musl === null) {
      musl = isMuslFromReport()
    }
    if (musl === null) {
      musl = isMuslFromChildProcess()
    }
  }
  return musl
}

const isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-')

const isMuslFromFilesystem = () => {
  try {
    return readFileSync('/usr/bin/ldd', 'utf-8').includes('musl')
  } catch {
    return null
  }
}

const isMuslFromReport = () => {
  let report = null
  if (typeof process.report?.getReport === 'function') {
    process.report.excludeNetwork = true
    report = process.report.getReport()
  }
  if (!report) {
    return null
  }
  if (report.header && report.header.glibcVersionRuntime) {
    return false
  }
  if (Array.isArray(report.sharedObjects)) {
    if (report.sharedObjects.some(isFileMusl)) {
      return true
    }
  }
  return false
}

const isMuslFromChildProcess = () => {
  try {
    return require('child_process').execSync('ldd --version', { encoding: 'utf8' }).includes('musl')
  } catch (e) {
    // If we reach this case, we don't know if the system is musl or not, so is better to just fallback to false
    return false
  }
}

function requireNative() {
  if (process.env.NAPI_RS_NATIVE_LIBRARY_PATH) {
    try {
      return require(process.env.NAPI_RS_NATIVE_LIBRARY_PATH);
    } catch (err) {
      loadErrors.push(err)
    }
  } else if (process.platform === 'android') {
    if (process.arch === 'arm64') {
      ${requireTuple("android-arm64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("android-arm-eabi")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Android \${process.arch}\`))
    }
  } else if (process.platform === 'win32') {
    if (process.arch === 'x64') {
      if (process.config?.variables?.shlib_suffix === 'dll.a' || process.config?.variables?.node_target_type === 'shared_library') {
        ${requireTuple("win32-x64-gnu")}
      } else {
        ${requireTuple("win32-x64-msvc")}
      }
    } else if (process.arch === 'ia32') {
      ${requireTuple("win32-ia32-msvc")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("win32-arm64-msvc")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Windows: \${process.arch}\`))
    }
  } else if (process.platform === 'darwin') {
    ${requireTuple("darwin-universal", 6)}
    if (process.arch === 'x64') {
      ${requireTuple("darwin-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("darwin-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on macOS: \${process.arch}\`))
    }
  } else if (process.platform === 'freebsd') {
    if (process.arch === 'x64') {
      ${requireTuple("freebsd-x64")}
    } else if (process.arch === 'arm64') {
      ${requireTuple("freebsd-arm64")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on FreeBSD: \${process.arch}\`))
    }
  } else if (process.platform === 'linux') {
    if (process.arch === 'x64') {
      if (isMusl()) {
        ${requireTuple("linux-x64-musl", 10)}
      } else {
        ${requireTuple("linux-x64-gnu", 10)}
      }
    } else if (process.arch === 'arm64') {
      if (isMusl()) {
        ${requireTuple("linux-arm64-musl", 10)}
      } else {
        ${requireTuple("linux-arm64-gnu", 10)}
      }
    } else if (process.arch === 'arm') {
      if (isMusl()) {
        ${requireTuple("linux-arm-musleabihf", 10)}
      } else {
        ${requireTuple("linux-arm-gnueabihf", 10)}
      }
    } else if (process.arch === 'loong64') {
      if (isMusl()) {
        ${requireTuple("linux-loong64-musl", 10)}
      } else {
        ${requireTuple("linux-loong64-gnu", 10)}
      }
    } else if (process.arch === 'riscv64') {
      if (isMusl()) {
        ${requireTuple("linux-riscv64-musl", 10)}
      } else {
        ${requireTuple("linux-riscv64-gnu", 10)}
      }
    } else if (process.arch === 'ppc64') {
      ${requireTuple("linux-ppc64-gnu")}
    } else if (process.arch === 's390x') {
      ${requireTuple("linux-s390x-gnu")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on Linux: \${process.arch}\`))
    }
  } else if (process.platform === 'openharmony') {
    if (process.arch === 'arm64') {
      ${requireTuple("openharmony-arm64")}
    } else if (process.arch === 'x64') {
      ${requireTuple("openharmony-x64")}
    } else if (process.arch === 'arm') {
      ${requireTuple("openharmony-arm")}
    } else {
      loadErrors.push(new Error(\`Unsupported architecture on OpenHarmony: \${process.arch}\`))
    }
  } else {
    loadErrors.push(new Error(\`Unsupported OS: \${process.platform}, architecture: \${process.arch}\`))
  }
}

nativeBinding = requireNative()

if (!nativeBinding || process.env.NAPI_RS_FORCE_WASI) {
  let wasiBinding = null
  let wasiBindingError = null
  try {
    wasiBinding = require('./${localName}.wasi.cjs')
    nativeBinding = wasiBinding
  } catch (err) {
    if (process.env.NAPI_RS_FORCE_WASI) {
      wasiBindingError = err
    }
  }
  if (!nativeBinding) {
    try {
      wasiBinding = require('${pkgName}-wasm32-wasi')
      nativeBinding = wasiBinding
    } catch (err) {
      if (process.env.NAPI_RS_FORCE_WASI) {
        wasiBindingError.cause = err
        loadErrors.push(err)
      }
    }
  }
  if (process.env.NAPI_RS_FORCE_WASI === 'error' && !wasiBinding) {
    const error = new Error('WASI binding not found and NAPI_RS_FORCE_WASI is set to error')
    error.cause = wasiBindingError
    throw error
  }
}

if (!nativeBinding) {
  if (loadErrors.length > 0) {
    throw new Error(
      \`Cannot find native binding. \` +
        \`npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). \` +
        'Please try \`npm i\` again after removing both package-lock.json and node_modules directory.',
      {
        cause: loadErrors.reduce((err, cur) => {
          cur.cause = err
          return cur
        }),
      },
    )
  }
  throw new Error(\`Failed to load native binding\`)
}
`;
}

//#endregion
//#region src/api/templates/load-wasi-template.ts
const createWasiBrowserBinding = (wasiFilename, initialMemory = 4e3, maximumMemory = 65536, fs$1 = false, asyncInit = false, buffer = false) => {
	return `import {
  createOnMessage as __wasmCreateOnMessageForFsProxy,
  getDefaultContext as __emnapiGetDefaultContext,
  ${asyncInit ? `instantiateNapiModule as __emnapiInstantiateNapiModule` : `instantiateNapiModuleSync as __emnapiInstantiateNapiModuleSync`},
  WASI as __WASI,
} from '@napi-rs/wasm-runtime'
${fs$1 ? buffer ? `import { memfs, Buffer } from '@napi-rs/wasm-runtime/fs'` : `import { memfs } from '@napi-rs/wasm-runtime/fs'` : ""}
${buffer && !fs$1 ? `import { Buffer } from 'buffer'` : ""}
${fs$1 ? `
export const { fs: __fs, vol: __volume } = memfs()

const __wasi = new __WASI({
  version: 'preview1',
  fs: __fs,
  preopens: {
    '/': '/',
  },
})` : `
const __wasi = new __WASI({
  version: 'preview1',
})`}

const __wasmUrl = new URL('./${wasiFilename}.wasm', import.meta.url).href
const __emnapiContext = __emnapiGetDefaultContext()
${buffer ? "__emnapiContext.feature.Buffer = Buffer" : ""}

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

const __wasmFile = await fetch(__wasmUrl).then((res) => res.arrayBuffer())

const {
  instance: __napiInstance,
  module: __wasiModule,
  napiModule: __napiModule,
} = ${asyncInit ? `await __emnapiInstantiateNapiModule` : `__emnapiInstantiateNapiModuleSync`}(__wasmFile, {
  context: __emnapiContext,
  asyncWorkPoolSize: 4,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(new URL('./wasi-worker-browser.mjs', import.meta.url), {
      type: 'module',
    })
${fs$1 ? `    worker.addEventListener('message', __wasmCreateOnMessageForFsProxy(__fs))\n` : ""}
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;
};
const createWasiBinding = (wasmFileName, packageName, initialMemory = 4e3, maximumMemory = 65536) => `/* eslint-disable */
/* prettier-ignore */

/* auto-generated by NAPI-RS */

const __nodeFs = require('node:fs')
const __nodePath = require('node:path')
const { WASI: __nodeWASI } = require('node:wasi')
const { Worker } = require('node:worker_threads')

const {
  createOnMessage: __wasmCreateOnMessageForFsProxy,
  getDefaultContext: __emnapiGetDefaultContext,
  instantiateNapiModuleSync: __emnapiInstantiateNapiModuleSync,
} = require('@napi-rs/wasm-runtime')

const __rootDir = __nodePath.parse(process.cwd()).root

const __wasi = new __nodeWASI({
  version: 'preview1',
  env: process.env,
  preopens: {
    [__rootDir]: __rootDir,
  }
})

const __emnapiContext = __emnapiGetDefaultContext()

const __sharedMemory = new WebAssembly.Memory({
  initial: ${initialMemory},
  maximum: ${maximumMemory},
  shared: true,
})

let __wasmFilePath = __nodePath.join(__dirname, '${wasmFileName}.wasm')
const __wasmDebugFilePath = __nodePath.join(__dirname, '${wasmFileName}.debug.wasm')

if (__nodeFs.existsSync(__wasmDebugFilePath)) {
  __wasmFilePath = __wasmDebugFilePath
} else if (!__nodeFs.existsSync(__wasmFilePath)) {
  try {
    __wasmFilePath = __nodePath.resolve('${packageName}-wasm32-wasi')
  } catch {
    throw new Error('Cannot find ${wasmFileName}.wasm file, and ${packageName}-wasm32-wasi package is not installed.')
  }
}

const { instance: __napiInstance, module: __wasiModule, napiModule: __napiModule } = __emnapiInstantiateNapiModuleSync(__nodeFs.readFileSync(__wasmFilePath), {
  context: __emnapiContext,
  asyncWorkPoolSize: (function() {
    const threadsSizeFromEnv = Number(process.env.NAPI_RS_ASYNC_WORK_POOL_SIZE ?? process.env.UV_THREADPOOL_SIZE)
    // NaN > 0 is false
    if (threadsSizeFromEnv > 0) {
      return threadsSizeFromEnv
    } else {
      return 4
    }
  })(),
  reuseWorker: true,
  wasi: __wasi,
  onCreateWorker() {
    const worker = new Worker(__nodePath.join(__dirname, 'wasi-worker.mjs'), {
      env: process.env,
    })
    worker.onmessage = ({ data }) => {
      __wasmCreateOnMessageForFsProxy(__nodeFs)(data)
    }

    // The main thread of Node.js waits for all the active handles before exiting.
    // But Rust threads are never waited without \`thread::join\`.
    // So here we hack the code of Node.js to prevent the workers from being referenced (active).
    // According to https://github.com/nodejs/node/blob/19e0d472728c79d418b74bddff588bea70a403d0/lib/internal/worker.js#L415,
    // a worker is consist of two handles: kPublicPort and kHandle.
    {
      const kPublicPort = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kPublicPort")
      );
      if (kPublicPort) {
        worker[kPublicPort].ref = () => {};
      }

      const kHandle = Object.getOwnPropertySymbols(worker).find(s =>
        s.toString().includes("kHandle")
      );
      if (kHandle) {
        worker[kHandle].ref = () => {};
      }

      worker.unref();
    }
    return worker
  },
  overwriteImports(importObject) {
    importObject.env = {
      ...importObject.env,
      ...importObject.napi,
      ...importObject.emnapi,
      memory: __sharedMemory,
    }
    return importObject
  },
  beforeInit({ instance }) {
    for (const name of Object.keys(instance.exports)) {
      if (name.startsWith('__napi_register__')) {
        instance.exports[name]()
      }
    }
  },
})
`;

//#endregion
//#region src/api/templates/wasi-worker-template.ts
const WASI_WORKER_TEMPLATE = `import fs from "node:fs";
import { createRequire } from "node:module";
import { parse } from "node:path";
import { WASI } from "node:wasi";
import { parentPort, Worker } from "node:worker_threads";

const require = createRequire(import.meta.url);

const { instantiateNapiModuleSync, MessageHandler, getDefaultContext } = require("@napi-rs/wasm-runtime");

if (parentPort) {
  parentPort.on("message", (data) => {
    globalThis.onmessage({ data });
  });
}

Object.assign(globalThis, {
  self: globalThis,
  require,
  Worker,
  importScripts: function (f) {
    ;(0, eval)(fs.readFileSync(f, "utf8") + "//# sourceURL=" + f);
  },
  postMessage: function (msg) {
    if (parentPort) {
      parentPort.postMessage(msg);
    }
  },
});

const emnapiContext = getDefaultContext();

const __rootDir = parse(process.cwd()).root;

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    const wasi = new WASI({
      version: 'preview1',
      env: process.env,
      preopens: {
        [__rootDir]: __rootDir,
      },
    });

    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      context: emnapiContext,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory
        };
      },
    });
  },
});

globalThis.onmessage = function (e) {
  handler.handle(e);
};
`;
const createWasiBrowserWorkerBinding = (fs$1) => {
	return `${fs$1 ? `import { instantiateNapiModuleSync, MessageHandler, WASI, createFsProxy } from '@napi-rs/wasm-runtime'
import { memfsExported as __memfsExported } from '@napi-rs/wasm-runtime/fs'

const fs = createFsProxy(__memfsExported)` : `import { instantiateNapiModuleSync, MessageHandler, WASI } from '@napi-rs/wasm-runtime'`}

const handler = new MessageHandler({
  onLoad({ wasmModule, wasmMemory }) {
    ${fs$1 ? `const wasi = new WASI({
      fs,
      preopens: {
        '/': '/',
      },
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })` : `const wasi = new WASI({
      print: function () {
        // eslint-disable-next-line no-console
        console.log.apply(console, arguments)
      },
      printErr: function() {
        // eslint-disable-next-line no-console
        console.error.apply(console, arguments)
      },
    })`}
    return instantiateNapiModuleSync(wasmModule, {
      childThread: true,
      wasi,
      overwriteImports(importObject) {
        importObject.env = {
          ...importObject.env,
          ...importObject.napi,
          ...importObject.emnapi,
          memory: wasmMemory,
        }
      },
    })
  },
})

globalThis.onmessage = function (e) {
  handler.handle(e)
}
`;
};

//#endregion
//#region src/api/build.ts
const debug$7 = debugFactory("build");
const require = createRequire(import.meta.url);
async function buildProject(rawOptions) {
	debug$7("napi build command receive options: %O", rawOptions);
	const options = {
		dtsCache: true,
		...rawOptions,
		cwd: rawOptions.cwd ?? process.cwd()
	};
	const resolvePath = (...paths) => resolve(options.cwd, ...paths);
	const manifestPath = resolvePath(options.manifestPath ?? "Cargo.toml");
	const metadata = await parseMetadata(manifestPath);
	const crate = metadata.packages.find((p) => {
		if (options.package) return p.name === options.package;
		else return p.manifest_path === manifestPath;
	});
	if (!crate) throw new Error("Unable to find crate to build. It seems you are trying to build a crate in a workspace, try using `--package` option to specify the package to build.");
	return new Builder(metadata, crate, await readNapiConfig(resolvePath(options.packageJsonPath ?? "package.json"), options.configPath ? resolvePath(options.configPath) : void 0), options).build();
}
var Builder = class {
	args = [];
	envs = {};
	outputs = [];
	target;
	crateDir;
	outputDir;
	targetDir;
	enableTypeDef = false;
	constructor(metadata, crate, config, options) {
		this.metadata = metadata;
		this.crate = crate;
		this.config = config;
		this.options = options;
		this.target = options.target ? parseTriple(options.target) : process.env.CARGO_BUILD_TARGET ? parseTriple(process.env.CARGO_BUILD_TARGET) : getSystemDefaultTarget();
		this.crateDir = parse(crate.manifest_path).dir;
		this.outputDir = resolve(this.options.cwd, options.outputDir ?? this.crateDir);
		this.targetDir = options.targetDir ?? process.env.CARGO_BUILD_TARGET_DIR ?? metadata.target_directory;
		this.enableTypeDef = this.crate.dependencies.some((dep) => dep.name === "napi-derive" && (dep.uses_default_features || dep.features.includes("type-def")));
		if (!this.enableTypeDef) {
			const requirementWarning = "`napi-derive` crate is not used or `type-def` feature is not enabled for `napi-derive` crate";
			debug$7.warn(`${requirementWarning}. Will skip binding generation for \`.node\`, \`.wasi\` and \`.d.ts\` files.`);
			if (this.options.dts || this.options.dtsHeader || this.config.dtsHeader || this.config.dtsHeaderFile) debug$7.warn(`${requirementWarning}. \`dts\` related options are enabled but will be ignored.`);
		}
	}
	get cdyLibName() {
		var _this$crate$targets$f;
		return (_this$crate$targets$f = this.crate.targets.find((t) => t.crate_types.includes("cdylib"))) === null || _this$crate$targets$f === void 0 ? void 0 : _this$crate$targets$f.name;
	}
	get binName() {
		var _this$crate$targets$f2;
		return this.options.bin ?? (this.cdyLibName ? null : (_this$crate$targets$f2 = this.crate.targets.find((t) => t.crate_types.includes("bin"))) === null || _this$crate$targets$f2 === void 0 ? void 0 : _this$crate$targets$f2.name);
	}
	build() {
		if (!this.cdyLibName) {
			const warning = "Missing `crate-type = [\"cdylib\"]` in [lib] config. The build result will not be available as node addon.";
			if (this.binName) debug$7.warn(warning);
			else throw new Error(warning);
		}
		return this.pickBinary().setPackage().setFeatures().setTarget().pickCrossToolchain().setEnvs().setBypassArgs().exec();
	}
	pickCrossToolchain() {
		if (!this.options.useNapiCross) return this;
		if (this.options.useCross) debug$7.warn("You are trying to use both `--cross` and `--use-napi-cross` options, `--use-cross` will be ignored.");
		if (this.options.crossCompile) debug$7.warn("You are trying to use both `--cross-compile` and `--use-napi-cross` options, `--cross-compile` will be ignored.");
		try {
			var _process$env$TARGET_C, _process$env$CC, _process$env$CXX, _process$env$TARGET_C2;
			const { version: version$2, download } = require("@napi-rs/cross-toolchain");
			const alias = { "s390x-unknown-linux-gnu": "s390x-ibm-linux-gnu" };
			const toolchainPath = join(homedir(), ".napi-rs", "cross-toolchain", version$2, this.target.triple);
			mkdirSync(toolchainPath, { recursive: true });
			if (existsSync(join(toolchainPath, "package.json"))) debug$7(`Toolchain ${toolchainPath} exists, skip extracting`);
			else download(process.arch, this.target.triple).unpack(toolchainPath);
			const upperCaseTarget = targetToEnvVar(this.target.triple);
			const crossTargetName = alias[this.target.triple] ?? this.target.triple;
			const linkerEnv = `CARGO_TARGET_${upperCaseTarget}_LINKER`;
			this.setEnvIfNotExists(linkerEnv, join(toolchainPath, "bin", `${crossTargetName}-gcc`));
			this.setEnvIfNotExists("TARGET_SYSROOT", join(toolchainPath, crossTargetName, "sysroot"));
			this.setEnvIfNotExists("TARGET_AR", join(toolchainPath, "bin", `${crossTargetName}-ar`));
			this.setEnvIfNotExists("TARGET_RANLIB", join(toolchainPath, "bin", `${crossTargetName}-ranlib`));
			this.setEnvIfNotExists("TARGET_READELF", join(toolchainPath, "bin", `${crossTargetName}-readelf`));
			this.setEnvIfNotExists("TARGET_C_INCLUDE_PATH", join(toolchainPath, crossTargetName, "sysroot", "usr", "include/"));
			this.setEnvIfNotExists("TARGET_CC", join(toolchainPath, "bin", `${crossTargetName}-gcc`));
			this.setEnvIfNotExists("TARGET_CXX", join(toolchainPath, "bin", `${crossTargetName}-g++`));
			this.setEnvIfNotExists("BINDGEN_EXTRA_CLANG_ARGS", `--sysroot=${this.envs.TARGET_SYSROOT}}`);
			if (((_process$env$TARGET_C = process.env.TARGET_CC) === null || _process$env$TARGET_C === void 0 ? void 0 : _process$env$TARGET_C.startsWith("clang")) || ((_process$env$CC = process.env.CC) === null || _process$env$CC === void 0 ? void 0 : _process$env$CC.startsWith("clang")) && !process.env.TARGET_CC) {
				const TARGET_CFLAGS = process.env.TARGET_CFLAGS ?? "";
				this.envs.TARGET_CFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CFLAGS}`;
			}
			if (((_process$env$CXX = process.env.CXX) === null || _process$env$CXX === void 0 ? void 0 : _process$env$CXX.startsWith("clang++")) && !process.env.TARGET_CXX || ((_process$env$TARGET_C2 = process.env.TARGET_CXX) === null || _process$env$TARGET_C2 === void 0 ? void 0 : _process$env$TARGET_C2.startsWith("clang++"))) {
				const TARGET_CXXFLAGS = process.env.TARGET_CXXFLAGS ?? "";
				this.envs.TARGET_CXXFLAGS = `--sysroot=${this.envs.TARGET_SYSROOT} --gcc-toolchain=${toolchainPath} ${TARGET_CXXFLAGS}`;
			}
			this.envs.PATH = this.envs.PATH ? `${toolchainPath}/bin:${this.envs.PATH}:${process.env.PATH}` : `${toolchainPath}/bin:${process.env.PATH}`;
		} catch (e) {
			debug$7.warn("Pick cross toolchain failed", e);
		}
		return this;
	}
	exec() {
		debug$7(`Start building crate: ${this.crate.name}`);
		debug$7("  %i", `cargo ${this.args.join(" ")}`);
		const controller = new AbortController();
		const watch = this.options.watch;
		return {
			task: new Promise((resolve$1, reject) => {
				var _buildProcess$stderr;
				if (this.options.useCross && this.options.crossCompile) throw new Error("`--use-cross` and `--cross-compile` can not be used together");
				const buildProcess = spawn(process.env.CARGO ?? (this.options.useCross ? "cross" : "cargo"), this.args, {
					env: {
						...process.env,
						...this.envs
					},
					stdio: watch ? [
						"inherit",
						"inherit",
						"pipe"
					] : "inherit",
					cwd: this.options.cwd,
					signal: controller.signal
				});
				buildProcess.once("exit", (code) => {
					if (code === 0) {
						debug$7("%i", `Build crate ${this.crate.name} successfully!`);
						resolve$1();
					} else reject(/* @__PURE__ */ new Error(`Build failed with exit code ${code}`));
				});
				buildProcess.once("error", (e) => {
					reject(new Error(`Build failed with error: ${e.message}`, { cause: e }));
				});
				(_buildProcess$stderr = buildProcess.stderr) === null || _buildProcess$stderr === void 0 || _buildProcess$stderr.on("data", (data) => {
					const output = data.toString();
					console.error(output);
					if (/Finished\s(`dev`|`release`)/.test(output)) this.postBuild().catch(() => {});
				});
			}).then(() => this.postBuild()),
			abort: () => controller.abort()
		};
	}
	pickBinary() {
		let set = false;
		if (this.options.watch) if (process.env.CI) debug$7.warn("Watch mode is not supported in CI environment");
		else {
			debug$7("Use %i", "cargo-watch");
			tryInstallCargoBinary("cargo-watch", "watch");
			this.args.push("watch", "--why", "-i", "*.{js,ts,node}", "-w", this.crateDir, "--", "cargo", "build");
			set = true;
		}
		if (this.options.crossCompile) if (this.target.platform === "win32") if (process.platform === "win32") debug$7.warn("You are trying to cross compile to win32 platform on win32 platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-xwin");
			tryInstallCargoBinary("cargo-xwin", "xwin");
			this.args.push("xwin", "build");
			if (this.target.arch === "ia32") this.envs.XWIN_ARCH = "x86";
			set = true;
		}
		else if (this.target.platform === "linux" && process.platform === "linux" && this.target.arch === process.arch && (function(abi) {
			var _process$report;
			return abi === (((_process$report = process.report) === null || _process$report === void 0 || (_process$report = _process$report.getReport()) === null || _process$report === void 0 || (_process$report = _process$report.header) === null || _process$report === void 0 ? void 0 : _process$report.glibcVersionRuntime) ? "gnu" : "musl");
		})(this.target.abi)) debug$7.warn("You are trying to cross compile to linux target on linux platform which is unnecessary.");
		else if (this.target.platform === "darwin" && process.platform === "darwin") debug$7.warn("You are trying to cross compile to darwin target on darwin platform which is unnecessary.");
		else {
			debug$7("Use %i", "cargo-zigbuild");
			tryInstallCargoBinary("cargo-zigbuild", "zigbuild");
			this.args.push("zigbuild");
			set = true;
		}
		if (!set) this.args.push("build");
		return this;
	}
	setPackage() {
		const args = [];
		if (this.options.package) args.push("--package", this.options.package);
		if (this.binName) args.push("--bin", this.binName);
		if (args.length) {
			debug$7("Set package flags: ");
			debug$7("  %O", args);
			this.args.push(...args);
		}
		return this;
	}
	setTarget() {
		debug$7("Set compiling target to: ");
		debug$7("  %i", this.target.triple);
		this.args.push("--target", this.target.triple);
		return this;
	}
	setEnvs() {
		var _this$target$abi;
		if (this.enableTypeDef) {
			this.envs.NAPI_TYPE_DEF_TMP_FOLDER = this.generateIntermediateTypeDefFolder();
			this.setForceBuildEnvs(this.envs.NAPI_TYPE_DEF_TMP_FOLDER);
		}
		let rustflags = process.env.RUSTFLAGS ?? process.env.CARGO_BUILD_RUSTFLAGS ?? "";
		if (((_this$target$abi = this.target.abi) === null || _this$target$abi === void 0 ? void 0 : _this$target$abi.includes("musl")) && !rustflags.includes("target-feature=-crt-static")) rustflags += " -C target-feature=-crt-static";
		if (this.options.strip && !rustflags.includes("link-arg=-s")) rustflags += " -C link-arg=-s";
		if (rustflags.length) this.envs.RUSTFLAGS = rustflags;
		const linker = this.options.crossCompile ? void 0 : getTargetLinker(this.target.triple);
		const linkerEnv = `CARGO_TARGET_${targetToEnvVar(this.target.triple)}_LINKER`;
		if (linker && !process.env[linkerEnv] && !this.envs[linkerEnv]) this.envs[linkerEnv] = linker;
		if (this.target.platform === "android") this.setAndroidEnv();
		if (this.target.platform === "wasi") this.setWasiEnv();
		if (this.target.platform === "openharmony") this.setOpenHarmonyEnv();
		debug$7("Set envs: ");
		Object.entries(this.envs).forEach(([k, v]) => {
			debug$7("  %i", `${k}=${v}`);
		});
		return this;
	}
	setForceBuildEnvs(typeDefTmpFolder) {
		this.metadata.packages.forEach((crate) => {
			if (crate.dependencies.some((d) => d.name === "napi-derive") && !existsSync(join(typeDefTmpFolder, crate.name))) this.envs[`NAPI_FORCE_BUILD_${crate.name.replace(/-/g, "_").toUpperCase()}`] = Date.now().toString();
		});
	}
	setAndroidEnv() {
		const { ANDROID_NDK_LATEST_HOME } = process.env;
		if (!ANDROID_NDK_LATEST_HOME) debug$7.warn(`${colors.red("ANDROID_NDK_LATEST_HOME")} environment variable is missing`);
		if (process.platform === "android") return;
		const targetArch = this.target.arch === "arm" ? "armv7a" : "aarch64";
		const targetPlatform = this.target.arch === "arm" ? "androideabi24" : "android24";
		const hostPlatform = process.platform === "darwin" ? "darwin" : process.platform === "win32" ? "windows" : "linux";
		Object.assign(this.envs, {
			CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-android24-clang`,
			CARGO_TARGET_ARMV7_LINUX_ANDROIDEABI_LINKER: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-androideabi24-clang`,
			TARGET_CC: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang`,
			TARGET_CXX: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/${targetArch}-linux-${targetPlatform}-clang++`,
			TARGET_AR: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ar`,
			TARGET_RANLIB: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin/llvm-ranlib`,
			ANDROID_NDK: ANDROID_NDK_LATEST_HOME,
			PATH: `${ANDROID_NDK_LATEST_HOME}/toolchains/llvm/prebuilt/${hostPlatform}-x86_64/bin${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`
		});
	}
	setWasiEnv() {
		const emnapi = join(require.resolve("emnapi"), "..", "lib", "wasm32-wasi-threads");
		this.envs.EMNAPI_LINK_DIR = emnapi;
		const { WASI_SDK_PATH } = process.env;
		if (WASI_SDK_PATH && existsSync(WASI_SDK_PATH)) {
			this.envs.CARGO_TARGET_WASM32_WASI_PREVIEW1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP1_THREADS_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.envs.CARGO_TARGET_WASM32_WASIP2_LINKER = join(WASI_SDK_PATH, "bin", "wasm-ld");
			this.setEnvIfNotExists("TARGET_CC", join(WASI_SDK_PATH, "bin", "clang"));
			this.setEnvIfNotExists("TARGET_CXX", join(WASI_SDK_PATH, "bin", "clang++"));
			this.setEnvIfNotExists("TARGET_AR", join(WASI_SDK_PATH, "bin", "ar"));
			this.setEnvIfNotExists("TARGET_RANLIB", join(WASI_SDK_PATH, "bin", "ranlib"));
			this.setEnvIfNotExists("TARGET_CFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists("TARGET_CXXFLAGS", `--target=wasm32-wasi-threads --sysroot=${WASI_SDK_PATH}/share/wasi-sysroot -pthread -mllvm -wasm-enable-sjlj`);
			this.setEnvIfNotExists(`TARGET_LDFLAGS`, `-fuse-ld=${WASI_SDK_PATH}/bin/wasm-ld --target=wasm32-wasi-threads`);
		}
	}
	setOpenHarmonyEnv() {
		const { OHOS_SDK_PATH, OHOS_SDK_NATIVE } = process.env;
		const ndkPath = OHOS_SDK_PATH ? `${OHOS_SDK_PATH}/native` : OHOS_SDK_NATIVE;
		if (!ndkPath && process.platform !== "openharmony") {
			debug$7.warn(`${colors.red("OHOS_SDK_PATH")} or ${colors.red("OHOS_SDK_NATIVE")} environment variable is missing`);
			return;
		}
		const linkerName = `CARGO_TARGET_${this.target.triple.toUpperCase().replace(/-/g, "_")}_LINKER`;
		const ranPath = `${ndkPath}/llvm/bin/llvm-ranlib`;
		const arPath = `${ndkPath}/llvm/bin/llvm-ar`;
		const ccPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang`;
		const cxxPath = `${ndkPath}/llvm/bin/${this.target.triple}-clang++`;
		const asPath = `${ndkPath}/llvm/bin/llvm-as`;
		const ldPath = `${ndkPath}/llvm/bin/ld.lld`;
		const stripPath = `${ndkPath}/llvm/bin/llvm-strip`;
		const objDumpPath = `${ndkPath}/llvm/bin/llvm-objdump`;
		const objCopyPath = `${ndkPath}/llvm/bin/llvm-objcopy`;
		const nmPath = `${ndkPath}/llvm/bin/llvm-nm`;
		const binPath = `${ndkPath}/llvm/bin`;
		const libPath = `${ndkPath}/llvm/lib`;
		this.setEnvIfNotExists("LIBCLANG_PATH", libPath);
		this.setEnvIfNotExists("DEP_ATOMIC", "clang_rt.builtins");
		this.setEnvIfNotExists(linkerName, ccPath);
		this.setEnvIfNotExists("TARGET_CC", ccPath);
		this.setEnvIfNotExists("TARGET_CXX", cxxPath);
		this.setEnvIfNotExists("TARGET_AR", arPath);
		this.setEnvIfNotExists("TARGET_RANLIB", ranPath);
		this.setEnvIfNotExists("TARGET_AS", asPath);
		this.setEnvIfNotExists("TARGET_LD", ldPath);
		this.setEnvIfNotExists("TARGET_STRIP", stripPath);
		this.setEnvIfNotExists("TARGET_OBJDUMP", objDumpPath);
		this.setEnvIfNotExists("TARGET_OBJCOPY", objCopyPath);
		this.setEnvIfNotExists("TARGET_NM", nmPath);
		this.envs.PATH = `${binPath}${process.platform === "win32" ? ";" : ":"}${process.env.PATH}`;
	}
	setFeatures() {
		const args = [];
		if (this.options.allFeatures && this.options.noDefaultFeatures) throw new Error("Cannot specify --all-features and --no-default-features together");
		if (this.options.allFeatures) args.push("--all-features");
		else if (this.options.noDefaultFeatures) args.push("--no-default-features");
		if (this.options.features) args.push("--features", ...this.options.features);
		debug$7("Set features flags: ");
		debug$7("  %O", args);
		this.args.push(...args);
		return this;
	}
	setBypassArgs() {
		var _this$options$cargoOp;
		if (this.options.release) this.args.push("--release");
		if (this.options.verbose) this.args.push("--verbose");
		if (this.options.targetDir) this.args.push("--target-dir", this.options.targetDir);
		if (this.options.profile) this.args.push("--profile", this.options.profile);
		if (this.options.manifestPath) this.args.push("--manifest-path", this.options.manifestPath);
		if ((_this$options$cargoOp = this.options.cargoOptions) === null || _this$options$cargoOp === void 0 ? void 0 : _this$options$cargoOp.length) this.args.push(...this.options.cargoOptions);
		return this;
	}
	generateIntermediateTypeDefFolder() {
		let folder = join(this.targetDir, "napi-rs", `${this.crate.name}-${createHash("sha256").update(this.crate.manifest_path).update(CLI_VERSION).digest("hex").substring(0, 8)}`);
		if (!this.options.dtsCache) {
			rmSync(folder, {
				recursive: true,
				force: true
			});
			folder += `_${Date.now()}`;
		}
		mkdirAsync(folder, { recursive: true });
		return folder;
	}
	async postBuild() {
		try {
			debug$7(`Try to create output directory:`);
			debug$7("  %i", this.outputDir);
			await mkdirAsync(this.outputDir, { recursive: true });
			debug$7(`Output directory created`);
		} catch (e) {
			throw new Error(`Failed to create output directory ${this.outputDir}`, { cause: e });
		}
		const wasmBinaryName = await this.copyArtifact();
		if (this.cdyLibName) {
			const idents = await this.generateTypeDef();
			const jsOutput = await this.writeJsBinding(idents);
			const wasmBindingsOutput = await this.writeWasiBinding(wasmBinaryName, idents);
			if (jsOutput) this.outputs.push(jsOutput);
			if (wasmBindingsOutput) this.outputs.push(...wasmBindingsOutput);
		}
		return this.outputs;
	}
	async copyArtifact() {
		const [srcName, destName, wasmBinaryName] = this.getArtifactNames();
		if (!srcName || !destName) return;
		const profile = this.options.profile ?? (this.options.release ? "release" : "debug");
		const src = join(this.targetDir, this.target.triple, profile, srcName);
		debug$7(`Copy artifact from: [${src}]`);
		const dest = join(this.outputDir, destName);
		const isWasm = dest.endsWith(".wasm");
		try {
			if (await fileExists(dest)) {
				debug$7("Old artifact found, remove it first");
				await unlinkAsync(dest);
			}
			debug$7("Copy artifact to:");
			debug$7("  %i", dest);
			if (isWasm) {
				const { ModuleConfig } = await import("@napi-rs/wasm-tools");
				debug$7("Generate debug wasm module");
				try {
					const debugWasmBinary = new ModuleConfig().generateDwarf(true).generateNameSection(true).generateProducersSection(true).preserveCodeTransform(true).strictValidate(false).parse(await readFileAsync(src)).emitWasm(true);
					await writeFileAsync(dest.replace(/\.wasm$/, ".debug.wasm"), debugWasmBinary);
					debug$7("Generate release wasm module");
					await writeFileAsync(dest, new ModuleConfig().generateDwarf(false).generateNameSection(false).generateProducersSection(false).preserveCodeTransform(false).strictValidate(false).onlyStableFeatures(false).parse(debugWasmBinary).emitWasm(false));
				} catch (e) {
					debug$7.warn(`Failed to generate debug wasm module: ${e.message ?? e}`);
					await copyFileAsync(src, dest);
				}
			} else await copyFileAsync(src, dest);
			this.outputs.push({
				kind: dest.endsWith(".node") ? "node" : isWasm ? "wasm" : "exe",
				path: dest
			});
			return wasmBinaryName ? join(this.outputDir, wasmBinaryName) : null;
		} catch (e) {
			throw new Error("Failed to copy artifact", { cause: e });
		}
	}
	getArtifactNames() {
		if (this.cdyLibName) {
			const cdyLib = this.cdyLibName.replace(/-/g, "_");
			const wasiTarget = this.config.targets.find((t) => t.platform === "wasi");
			const srcName = this.target.platform === "darwin" ? `lib${cdyLib}.dylib` : this.target.platform === "win32" ? `${cdyLib}.dll` : this.target.platform === "wasi" || this.target.platform === "wasm" ? `${cdyLib}.wasm` : `lib${cdyLib}.so`;
			let destName = this.config.binaryName;
			if (this.options.platform) destName += `.${this.target.platformArchABI}`;
			if (srcName.endsWith(".wasm")) destName += ".wasm";
			else destName += ".node";
			return [
				srcName,
				destName,
				wasiTarget ? `${this.config.binaryName}.${wasiTarget.platformArchABI}.wasm` : null
			];
		} else if (this.binName) {
			const srcName = this.target.platform === "win32" ? `${this.binName}.exe` : this.binName;
			return [srcName, srcName];
		}
		return [];
	}
	async generateTypeDef() {
		const typeDefDir = this.envs.NAPI_TYPE_DEF_TMP_FOLDER;
		if (!this.enableTypeDef) return [];
		const { exports, dts } = await generateTypeDef({
			typeDefDir,
			noDtsHeader: this.options.noDtsHeader,
			dtsHeader: this.options.dtsHeader,
			configDtsHeader: this.config.dtsHeader,
			configDtsHeaderFile: this.config.dtsHeaderFile,
			constEnum: this.options.constEnum ?? this.config.constEnum,
			cwd: this.options.cwd
		});
		const dest = join(this.outputDir, this.options.dts ?? "index.d.ts");
		try {
			debug$7("Writing type def to:");
			debug$7("  %i", dest);
			await writeFileAsync(dest, dts, "utf-8");
		} catch (e) {
			debug$7.error("Failed to write type def file");
			debug$7.error(e);
		}
		if (exports.length > 0) {
			const dest$1 = join(this.outputDir, this.options.dts ?? "index.d.ts");
			this.outputs.push({
				kind: "dts",
				path: dest$1
			});
		}
		return exports;
	}
	async writeJsBinding(idents) {
		return writeJsBinding({
			platform: this.options.platform,
			noJsBinding: this.options.noJsBinding,
			idents,
			jsBinding: this.options.jsBinding,
			esm: this.options.esm,
			binaryName: this.config.binaryName,
			packageName: this.options.jsPackageName ?? this.config.packageName,
			version: process.env.npm_new_version ?? this.config.packageJson.version,
			outputDir: this.outputDir
		});
	}
	async writeWasiBinding(distFileName, idents) {
		if (distFileName) {
			var _this$config$wasm, _this$config$wasm2, _this$config$wasm3, _this$config$wasm4, _this$config$wasm5, _this$config$wasm6, _this$config$wasm7, _this$config$wasm8;
			const { name, dir: dir$1 } = parse(distFileName);
			const bindingPath = join(dir$1, `${this.config.binaryName}.wasi.cjs`);
			const browserBindingPath = join(dir$1, `${this.config.binaryName}.wasi-browser.js`);
			const workerPath = join(dir$1, "wasi-worker.mjs");
			const browserWorkerPath = join(dir$1, "wasi-worker-browser.mjs");
			const browserEntryPath = join(dir$1, "browser.js");
			const exportsCode = `module.exports = __napiModule.exports\n` + idents.map((ident) => `module.exports.${ident} = __napiModule.exports.${ident}`).join("\n");
			await writeFileAsync(bindingPath, createWasiBinding(name, this.config.packageName, (_this$config$wasm = this.config.wasm) === null || _this$config$wasm === void 0 ? void 0 : _this$config$wasm.initialMemory, (_this$config$wasm2 = this.config.wasm) === null || _this$config$wasm2 === void 0 ? void 0 : _this$config$wasm2.maximumMemory) + exportsCode + "\n", "utf8");
			await writeFileAsync(browserBindingPath, createWasiBrowserBinding(name, (_this$config$wasm3 = this.config.wasm) === null || _this$config$wasm3 === void 0 ? void 0 : _this$config$wasm3.initialMemory, (_this$config$wasm4 = this.config.wasm) === null || _this$config$wasm4 === void 0 ? void 0 : _this$config$wasm4.maximumMemory, (_this$config$wasm5 = this.config.wasm) === null || _this$config$wasm5 === void 0 || (_this$config$wasm5 = _this$config$wasm5.browser) === null || _this$config$wasm5 === void 0 ? void 0 : _this$config$wasm5.fs, (_this$config$wasm6 = this.config.wasm) === null || _this$config$wasm6 === void 0 || (_this$config$wasm6 = _this$config$wasm6.browser) === null || _this$config$wasm6 === void 0 ? void 0 : _this$config$wasm6.asyncInit, (_this$config$wasm7 = this.config.wasm) === null || _this$config$wasm7 === void 0 || (_this$config$wasm7 = _this$config$wasm7.browser) === null || _this$config$wasm7 === void 0 ? void 0 : _this$config$wasm7.buffer) + `export default __napiModule.exports\n` + idents.map((ident) => `export const ${ident} = __napiModule.exports.${ident}`).join("\n") + "\n", "utf8");
			await writeFileAsync(workerPath, WASI_WORKER_TEMPLATE, "utf8");
			await writeFileAsync(browserWorkerPath, createWasiBrowserWorkerBinding(((_this$config$wasm8 = this.config.wasm) === null || _this$config$wasm8 === void 0 || (_this$config$wasm8 = _this$config$wasm8.browser) === null || _this$config$wasm8 === void 0 ? void 0 : _this$config$wasm8.fs) ?? false), "utf8");
			await writeFileAsync(browserEntryPath, `export * from '${this.config.packageName}-wasm32-wasi'\n`);
			return [
				{
					kind: "js",
					path: bindingPath
				},
				{
					kind: "js",
					path: browserBindingPath
				},
				{
					kind: "js",
					path: workerPath
				},
				{
					kind: "js",
					path: browserWorkerPath
				},
				{
					kind: "js",
					path: browserEntryPath
				}
			];
		}
		return [];
	}
	setEnvIfNotExists(env, value$1) {
		if (!process.env[env]) this.envs[env] = value$1;
	}
};
async function writeJsBinding(options) {
	if (!options.platform || options.noJsBinding || options.idents.length === 0) return;
	const name = options.jsBinding ?? "index.js";
	const binding = (options.esm ? createEsmBinding : createCjsBinding)(options.binaryName, options.packageName, options.idents, options.version);
	try {
		const dest = join(options.outputDir, name);
		debug$7("Writing js binding to:");
		debug$7("  %i", dest);
		await writeFileAsync(dest, binding, "utf-8");
		return {
			kind: "js",
			path: dest
		};
	} catch (e) {
		throw new Error("Failed to write js binding file", { cause: e });
	}
}
async function generateTypeDef(options) {
	if (!await dirExistsAsync(options.typeDefDir)) return {
		exports: [],
		dts: ""
	};
	let header = "";
	let dts = "";
	let exports = [];
	if (!options.noDtsHeader) {
		const dtsHeader = options.dtsHeader ?? options.configDtsHeader;
		if (options.configDtsHeaderFile) try {
			header = await readFileAsync(join(options.cwd, options.configDtsHeaderFile), "utf-8");
		} catch (e) {
			debug$7.warn(`Failed to read dts header file ${options.configDtsHeaderFile}`, e);
		}
		else if (dtsHeader) header = dtsHeader;
		else header = DEFAULT_TYPE_DEF_HEADER;
	}
	const files = await readdirAsync(options.typeDefDir, { withFileTypes: true });
	if (!files.length) {
		debug$7("No type def files found. Skip generating dts file.");
		return {
			exports: [],
			dts: ""
		};
	}
	for (const file of files) {
		if (!file.isFile()) continue;
		const { dts: fileDts, exports: fileExports } = await processTypeDef(join(options.typeDefDir, file.name), options.constEnum ?? true);
		dts += fileDts;
		exports.push(...fileExports);
	}
	if (dts.indexOf("ExternalObject<") > -1) header += `
export declare class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
`;
	if (dts.indexOf("TypedArray") > -1) header += `
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array
`;
	dts = header + dts;
	return {
		exports,
		dts
	};
}

//#endregion
//#region src/def/create-npm-dirs.ts
var BaseCreateNpmDirsCommand = class extends Command {
	static paths = [["create-npm-dirs"]];
	static usage = Command.Usage({ description: "Create npm package dirs for different platforms" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultCreateNpmDirsOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/api/create-npm-dirs.ts
const debug$6 = debugFactory("create-npm-dirs");
async function createNpmDirs(userOptions) {
	const options = applyDefaultCreateNpmDirsOptions(userOptions);
	async function mkdirAsync$1(dir$1) {
		debug$6("Try to create dir: %i", dir$1);
		if (options.dryRun) return;
		await mkdirAsync(dir$1, { recursive: true });
	}
	async function writeFileAsync$1(file, content) {
		debug$6("Writing file %i", file);
		if (options.dryRun) {
			debug$6(content);
			return;
		}
		await writeFileAsync(file, content);
	}
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const npmPath = resolve(options.cwd, options.npmDir);
	debug$6(`Read content from [${options.configPath ?? packageJsonPath}]`);
	const { targets, binaryName, packageName, packageJson } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of targets) {
		const targetDir = join(npmPath, `${target.platformArchABI}`);
		await mkdirAsync$1(targetDir);
		const binaryFileName = target.arch === "wasm32" ? `${binaryName}.${target.platformArchABI}.wasm` : `${binaryName}.${target.platformArchABI}.node`;
		const scopedPackageJson = {
			name: `${packageName}-${target.platformArchABI}`,
			version: packageJson.version,
			cpu: target.arch !== "universal" ? [target.arch] : void 0,
			main: binaryFileName,
			files: [binaryFileName],
			...pick$1(packageJson, "description", "keywords", "author", "authors", "homepage", "license", "engines", "repository", "bugs")
		};
		if (packageJson.publishConfig) scopedPackageJson.publishConfig = pick$1(packageJson.publishConfig, "registry", "access");
		if (target.arch !== "wasm32") scopedPackageJson.os = [target.platform];
		else {
			var _scopedPackageJson$fi, _scopedPackageJson$en;
			const entry = `${binaryName}.wasi.cjs`;
			scopedPackageJson.main = entry;
			scopedPackageJson.browser = `${binaryName}.wasi-browser.js`;
			(_scopedPackageJson$fi = scopedPackageJson.files) === null || _scopedPackageJson$fi === void 0 || _scopedPackageJson$fi.push(entry, scopedPackageJson.browser, `wasi-worker.mjs`, `wasi-worker-browser.mjs`);
			let needRestrictNodeVersion = true;
			if ((_scopedPackageJson$en = scopedPackageJson.engines) === null || _scopedPackageJson$en === void 0 ? void 0 : _scopedPackageJson$en.node) try {
				const { major } = parse$1(scopedPackageJson.engines.node) ?? { major: 0 };
				if (major >= 14) needRestrictNodeVersion = false;
			} catch {}
			if (needRestrictNodeVersion) scopedPackageJson.engines = { node: ">=14.0.0" };
			const wasmRuntime = await fetch(`https://registry.npmjs.org/@napi-rs/wasm-runtime`).then((res) => res.json());
			scopedPackageJson.dependencies = { "@napi-rs/wasm-runtime": `^${wasmRuntime["dist-tags"].latest}` };
		}
		if (target.abi === "gnu") scopedPackageJson.libc = ["glibc"];
		else if (target.abi === "musl") scopedPackageJson.libc = ["musl"];
		await writeFileAsync$1(join(targetDir, "package.json"), JSON.stringify(scopedPackageJson, null, 2) + "\n");
		await writeFileAsync$1(join(targetDir, "README.md"), readme(packageName, target));
		debug$6.info(`${packageName} -${target.platformArchABI} created`);
	}
}
function readme(packageName, target) {
	return `# \`${packageName}-${target.platformArchABI}\`

This is the **${target.triple}** binary for \`${packageName}\`
`;
}

//#endregion
//#region src/def/new.ts
var BaseNewCommand = class extends Command {
	static paths = [["new"]];
	static usage = Command.Usage({ description: "Create a new project with pre-configured boilerplate" });
	$$path = Option.String({ required: false });
	$$name = Option.String("--name,-n", { description: "The name of the project, default to the name of the directory if not provided" });
	minNodeApiVersion = Option.String("--min-node-api,-v", "4", {
		validator: typanion.isNumber(),
		description: "The minimum Node-API version to support"
	});
	packageManager = Option.String("--package-manager", "yarn", { description: "The package manager to use. Only support yarn 4.x for now." });
	license = Option.String("--license,-l", "MIT", { description: "License for open-sourced project" });
	targets = Option.Array("--targets,-t", [], { description: "All targets the crate will be compiled for." });
	enableDefaultTargets = Option.Boolean("--enable-default-targets", true, { description: "Whether enable default targets" });
	enableAllTargets = Option.Boolean("--enable-all-targets", false, { description: "Whether enable all targets" });
	enableTypeDef = Option.Boolean("--enable-type-def", true, { description: "Whether enable the `type-def` feature for typescript definitions auto-generation" });
	enableGithubActions = Option.Boolean("--enable-github-actions", true, { description: "Whether generate preconfigured GitHub Actions workflow" });
	testFramework = Option.String("--test-framework", "ava", { description: "The JavaScript test framework to use, only support `ava` for now" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Whether to run the command in dry-run mode" });
	getOptions() {
		return {
			path: this.$$path,
			name: this.$$name,
			minNodeApiVersion: this.minNodeApiVersion,
			packageManager: this.packageManager,
			license: this.license,
			targets: this.targets,
			enableDefaultTargets: this.enableDefaultTargets,
			enableAllTargets: this.enableAllTargets,
			enableTypeDef: this.enableTypeDef,
			enableGithubActions: this.enableGithubActions,
			testFramework: this.testFramework,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultNewOptions(options) {
	return {
		minNodeApiVersion: 4,
		packageManager: "yarn",
		license: "MIT",
		targets: [],
		enableDefaultTargets: true,
		enableAllTargets: false,
		enableTypeDef: true,
		enableGithubActions: true,
		testFramework: "ava",
		dryRun: false,
		...options
	};
}

//#endregion
//#region ../node_modules/@std/toml/stringify.js
function joinKeys(keys) {
	return keys.map((str) => {
		return str.length === 0 || str.match(/[^A-Za-z0-9_-]/) ? JSON.stringify(str) : str;
	}).join(".");
}
var Dumper = class {
	maxPad = 0;
	srcObject;
	output = [];
	#arrayTypeCache = /* @__PURE__ */ new Map();
	constructor(srcObjc) {
		this.srcObject = srcObjc;
	}
	dump(fmtOptions = {}) {
		this.output = this.#printObject(this.srcObject);
		this.output = this.#format(fmtOptions);
		return this.output;
	}
	#printObject(obj, keys = []) {
		const out = [];
		const props = Object.keys(obj);
		const inlineProps = [];
		const multilineProps = [];
		for (const prop of props) if (this.#isSimplySerializable(obj[prop])) inlineProps.push(prop);
		else multilineProps.push(prop);
		const sortedProps = inlineProps.concat(multilineProps);
		for (const prop of sortedProps) {
			const value$1 = obj[prop];
			if (value$1 instanceof Date) out.push(this.#dateDeclaration([prop], value$1));
			else if (typeof value$1 === "string" || value$1 instanceof RegExp) out.push(this.#strDeclaration([prop], value$1.toString()));
			else if (typeof value$1 === "number") out.push(this.#numberDeclaration([prop], value$1));
			else if (typeof value$1 === "boolean") out.push(this.#boolDeclaration([prop], value$1));
			else if (value$1 instanceof Array) {
				const arrayType = this.#getTypeOfArray(value$1);
				if (arrayType === "ONLY_PRIMITIVE") out.push(this.#arrayDeclaration([prop], value$1));
				else if (arrayType === "ONLY_OBJECT_EXCLUDING_ARRAY") for (let i = 0; i < value$1.length; i++) {
					out.push("");
					out.push(this.#headerGroup([...keys, prop]));
					out.push(...this.#printObject(value$1[i], [...keys, prop]));
				}
				else {
					const str = value$1.map((x) => this.#printAsInlineValue(x)).join(",");
					out.push(`${this.#declaration([prop])}[${str}]`);
				}
			} else if (typeof value$1 === "object") {
				out.push("");
				out.push(this.#header([...keys, prop]));
				if (value$1) {
					const toParse = value$1;
					out.push(...this.#printObject(toParse, [...keys, prop]));
				}
			}
		}
		out.push("");
		return out;
	}
	#isPrimitive(value$1) {
		return value$1 instanceof Date || value$1 instanceof RegExp || [
			"string",
			"number",
			"boolean"
		].includes(typeof value$1);
	}
	#getTypeOfArray(arr) {
		if (this.#arrayTypeCache.has(arr)) return this.#arrayTypeCache.get(arr);
		const type = this.#doGetTypeOfArray(arr);
		this.#arrayTypeCache.set(arr, type);
		return type;
	}
	#doGetTypeOfArray(arr) {
		if (!arr.length) return "ONLY_PRIMITIVE";
		const onlyPrimitive = this.#isPrimitive(arr[0]);
		if (arr[0] instanceof Array) return "MIXED";
		for (let i = 1; i < arr.length; i++) if (onlyPrimitive !== this.#isPrimitive(arr[i]) || arr[i] instanceof Array) return "MIXED";
		return onlyPrimitive ? "ONLY_PRIMITIVE" : "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#printAsInlineValue(value$1) {
		if (value$1 instanceof Date) return `"${this.#printDate(value$1)}"`;
		else if (typeof value$1 === "string" || value$1 instanceof RegExp) return JSON.stringify(value$1.toString());
		else if (typeof value$1 === "number") return value$1;
		else if (typeof value$1 === "boolean") return value$1.toString();
		else if (value$1 instanceof Array) return `[${value$1.map((x) => this.#printAsInlineValue(x)).join(",")}]`;
		else if (typeof value$1 === "object") {
			if (!value$1) throw new Error("Should never reach");
			return `{${Object.keys(value$1).map((key) => {
				return `${joinKeys([key])} = ${this.#printAsInlineValue(value$1[key])}`;
			}).join(",")}}`;
		}
		throw new Error("Should never reach");
	}
	#isSimplySerializable(value$1) {
		return typeof value$1 === "string" || typeof value$1 === "number" || typeof value$1 === "boolean" || value$1 instanceof RegExp || value$1 instanceof Date || value$1 instanceof Array && this.#getTypeOfArray(value$1) !== "ONLY_OBJECT_EXCLUDING_ARRAY";
	}
	#header(keys) {
		return `[${joinKeys(keys)}]`;
	}
	#headerGroup(keys) {
		return `[[${joinKeys(keys)}]]`;
	}
	#declaration(keys) {
		const title = joinKeys(keys);
		if (title.length > this.maxPad) this.maxPad = title.length;
		return `${title} = `;
	}
	#arrayDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#strDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${JSON.stringify(value$1)}`;
	}
	#numberDeclaration(keys, value$1) {
		if (Number.isNaN(value$1)) return `${this.#declaration(keys)}nan`;
		switch (value$1) {
			case Infinity: return `${this.#declaration(keys)}inf`;
			case -Infinity: return `${this.#declaration(keys)}-inf`;
			default: return `${this.#declaration(keys)}${value$1}`;
		}
	}
	#boolDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${value$1}`;
	}
	#printDate(value$1) {
		function dtPad(v, lPad = 2) {
			return v.padStart(lPad, "0");
		}
		const m = dtPad((value$1.getUTCMonth() + 1).toString());
		const d = dtPad(value$1.getUTCDate().toString());
		const h = dtPad(value$1.getUTCHours().toString());
		const min = dtPad(value$1.getUTCMinutes().toString());
		const s = dtPad(value$1.getUTCSeconds().toString());
		const ms = dtPad(value$1.getUTCMilliseconds().toString(), 3);
		return `${value$1.getUTCFullYear()}-${m}-${d}T${h}:${min}:${s}.${ms}`;
	}
	#dateDeclaration(keys, value$1) {
		return `${this.#declaration(keys)}${this.#printDate(value$1)}`;
	}
	#format(options = {}) {
		const { keyAlignment = false } = options;
		const rDeclaration = /^(\".*\"|[^=]*)\s=/;
		const out = [];
		for (let i = 0; i < this.output.length; i++) {
			const l = this.output[i];
			if (l[0] === "[" && l[1] !== "[") {
				var _this$output;
				if (this.output[i + 1] === "" && ((_this$output = this.output[i + 2]) === null || _this$output === void 0 ? void 0 : _this$output.slice(0, l.length)) === l.slice(0, -1) + ".") {
					i += 1;
					continue;
				}
				out.push(l);
			} else if (keyAlignment) {
				const m = rDeclaration.exec(l);
				if (m && m[1]) out.push(l.replace(m[1], m[1].padEnd(this.maxPad)));
				else out.push(l);
			} else out.push(l);
		}
		const cleanedOutput = [];
		for (let i = 0; i < out.length; i++) {
			const l = out[i];
			if (!(l === "" && out[i + 1] === "")) cleanedOutput.push(l);
		}
		return cleanedOutput;
	}
};
/**
* Converts an object to a {@link https://toml.io | TOML} string.
*
* @example Usage
* ```ts
* import { stringify } from "@std/toml/stringify";
* import { assertEquals } from "@std/assert";
*
* const obj = {
*   title: "TOML Example",
*   owner: {
*     name: "Bob",
*     bio: "Bob is a cool guy",
*  }
* };
* const tomlString = stringify(obj);
* assertEquals(tomlString, `title = "TOML Example"\n\n[owner]\nname = "Bob"\nbio = "Bob is a cool guy"\n`);
* ```
* @param obj Source object
* @param options Options for stringifying.
* @returns TOML string
*/ function stringify(obj, options) {
	return new Dumper(obj).dump(options).join("\n");
}

//#endregion
//#region ../node_modules/@jsr/std__collections/_utils.js
/**
* Filters the given array, removing all elements that do not match the given predicate
* **in place. This means `array` will be modified!**.
*/ function filterInPlace(array, predicate) {
	let outputIndex = 0;
	for (const cur of array) {
		if (!predicate(cur)) continue;
		array[outputIndex] = cur;
		outputIndex += 1;
	}
	array.splice(outputIndex);
	return array;
}

//#endregion
//#region ../node_modules/@jsr/std__collections/deep_merge.js
function deepMerge(record, other, options) {
	return deepMergeInternal(record, other, /* @__PURE__ */ new Set(), options);
}
function deepMergeInternal(record, other, seen, options) {
	const result = {};
	const keys = new Set([...getKeys(record), ...getKeys(other)]);
	for (const key of keys) {
		if (key === "__proto__") continue;
		const a = record[key];
		if (!Object.hasOwn(other, key)) {
			result[key] = a;
			continue;
		}
		const b = other[key];
		if (isNonNullObject(a) && isNonNullObject(b) && !seen.has(a) && !seen.has(b)) {
			seen.add(a);
			seen.add(b);
			result[key] = mergeObjects(a, b, seen, options);
			continue;
		}
		result[key] = b;
	}
	return result;
}
function mergeObjects(left, right, seen, options = {
	arrays: "merge",
	sets: "merge",
	maps: "merge"
}) {
	if (isMergeable(left) && isMergeable(right)) return deepMergeInternal(left, right, seen, options);
	if (isIterable(left) && isIterable(right)) {
		if (Array.isArray(left) && Array.isArray(right)) {
			if (options.arrays === "merge") return left.concat(right);
			return right;
		}
		if (left instanceof Map && right instanceof Map) {
			if (options.maps === "merge") return new Map([...left, ...right]);
			return right;
		}
		if (left instanceof Set && right instanceof Set) {
			if (options.sets === "merge") return new Set([...left, ...right]);
			return right;
		}
	}
	return right;
}
/**
* Test whether a value is mergeable or not
* Builtins that look like objects, null and user defined classes
* are not considered mergeable (it means that reference will be copied)
*/ function isMergeable(value$1) {
	return Object.getPrototypeOf(value$1) === Object.prototype;
}
function isIterable(value$1) {
	return typeof value$1[Symbol.iterator] === "function";
}
function isNonNullObject(value$1) {
	return value$1 !== null && typeof value$1 === "object";
}
function getKeys(record) {
	const result = Object.getOwnPropertySymbols(record);
	filterInPlace(result, (key) => Object.prototype.propertyIsEnumerable.call(record, key));
	result.push(...Object.keys(record));
	return result;
}

//#endregion
//#region ../node_modules/@std/toml/_parser.js
/**
* Copy of `import { isLeap } from "@std/datetime";` because it cannot be impoted as long as it is unstable.
*/ function isLeap(yearNumber) {
	return yearNumber % 4 === 0 && yearNumber % 100 !== 0 || yearNumber % 400 === 0;
}
var Scanner = class {
	#whitespace = /[ \t]/;
	#position = 0;
	#source;
	constructor(source) {
		this.#source = source;
	}
	get position() {
		return this.#position;
	}
	get source() {
		return this.#source;
	}
	/**
	* Get current character
	* @param index - relative index from current position
	*/ char(index = 0) {
		return this.#source[this.#position + index] ?? "";
	}
	/**
	* Get sliced string
	* @param start - start position relative from current position
	* @param end - end position relative from current position
	*/ slice(start, end) {
		return this.#source.slice(this.#position + start, this.#position + end);
	}
	/**
	* Move position to next
	*/ next(count = 1) {
		this.#position += count;
	}
	skipWhitespaces() {
		while (this.#whitespace.test(this.char()) && !this.eof()) this.next();
		if (!this.isCurrentCharEOL() && /\s/.test(this.char())) {
			const escaped = "\\u" + this.char().charCodeAt(0).toString(16);
			const position = this.#position;
			throw new SyntaxError(`Cannot parse the TOML: It contains invalid whitespace at position '${position}': \`${escaped}\``);
		}
	}
	nextUntilChar(options = { skipComments: true }) {
		while (!this.eof()) {
			const char = this.char();
			if (this.#whitespace.test(char) || this.isCurrentCharEOL()) this.next();
			else if (options.skipComments && this.char() === "#") while (!this.isCurrentCharEOL() && !this.eof()) this.next();
			else break;
		}
	}
	/**
	* Position reached EOF or not
	*/ eof() {
		return this.#position >= this.#source.length;
	}
	isCurrentCharEOL() {
		return this.char() === "\n" || this.startsWith("\r\n");
	}
	startsWith(searchString) {
		return this.#source.startsWith(searchString, this.#position);
	}
	match(regExp) {
		if (!regExp.sticky) throw new Error(`RegExp ${regExp} does not have a sticky 'y' flag`);
		regExp.lastIndex = this.#position;
		return this.#source.match(regExp);
	}
};
function success(body) {
	return {
		ok: true,
		body
	};
}
function failure() {
	return { ok: false };
}
/**
* Creates a nested object from the keys and values.
*
* e.g. `unflat(["a", "b", "c"], 1)` returns `{ a: { b: { c: 1 } } }`
*/ function unflat(keys, values = { __proto__: null }) {
	return keys.reduceRight((acc, key) => ({ [key]: acc }), values);
}
function isObject(value$1) {
	return typeof value$1 === "object" && value$1 !== null;
}
function getTargetValue(target, keys) {
	const key = keys[0];
	if (!key) throw new Error("Cannot parse the TOML: key length is not a positive number");
	return target[key];
}
function deepAssignTable(target, table$1) {
	const { keys, type, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, value$1));
	if (Array.isArray(currentValue)) {
		deepAssign(currentValue.at(-1), {
			type,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssignTableArray(target, table$1) {
	const { type, keys, value: value$1 } = table$1;
	const currentValue = getTargetValue(target, keys);
	if (currentValue === void 0) return Object.assign(target, unflat(keys, [value$1]));
	if (Array.isArray(currentValue)) {
		if (table$1.keys.length === 1) currentValue.push(value$1);
		else deepAssign(currentValue.at(-1), {
			type: table$1.type,
			keys: table$1.keys.slice(1),
			value: table$1.value
		});
		return target;
	}
	if (isObject(currentValue)) {
		deepAssign(currentValue, {
			type,
			keys: keys.slice(1),
			value: value$1
		});
		return target;
	}
	throw new Error("Unexpected assign");
}
function deepAssign(target, body) {
	switch (body.type) {
		case "Block": return deepMerge(target, body.value);
		case "Table": return deepAssignTable(target, body);
		case "TableArray": return deepAssignTableArray(target, body);
	}
}
function or(parsers) {
	return (scanner) => {
		for (const parse$3 of parsers) {
			const result = parse$3(scanner);
			if (result.ok) return result;
		}
		return failure();
	};
}
/** Join the parse results of the given parser into an array.
*
* If the parser fails at the first attempt, it will return an empty array.
*/ function join$1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const out = [];
		const first = parser(scanner);
		if (!first.ok) return success(out);
		out.push(first.body);
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
/** Join the parse results of the given parser into an array.
*
* This requires the parser to succeed at least once.
*/ function join1(parser, separator) {
	const Separator = character(separator);
	return (scanner) => {
		const first = parser(scanner);
		if (!first.ok) return failure();
		const out = [first.body];
		while (!scanner.eof()) {
			if (!Separator(scanner).ok) break;
			const result = parser(scanner);
			if (!result.ok) throw new SyntaxError(`Invalid token after "${separator}"`);
			out.push(result.body);
		}
		return success(out);
	};
}
function kv(keyParser, separator, valueParser) {
	const Separator = character(separator);
	return (scanner) => {
		const position = scanner.position;
		const key = keyParser(scanner);
		if (!key.ok) return failure();
		if (!Separator(scanner).ok) throw new SyntaxError(`key/value pair doesn't have "${separator}"`);
		const value$1 = valueParser(scanner);
		if (!value$1.ok) {
			const lineEndIndex = scanner.source.indexOf("\n", scanner.position);
			const endPosition = lineEndIndex > 0 ? lineEndIndex : scanner.source.length;
			const line = scanner.source.slice(position, endPosition);
			throw new SyntaxError(`Cannot parse value on line '${line}'`);
		}
		return success(unflat(key.body, value$1.body));
	};
}
function merge$1(parser) {
	return (scanner) => {
		const result = parser(scanner);
		if (!result.ok) return failure();
		let body = { __proto__: null };
		for (const record of result.body) if (typeof record === "object" && record !== null) body = deepMerge(body, record);
		return success(body);
	};
}
function repeat(parser) {
	return (scanner) => {
		const body = [];
		while (!scanner.eof()) {
			const result = parser(scanner);
			if (!result.ok) break;
			body.push(result.body);
			scanner.nextUntilChar();
		}
		if (body.length === 0) return failure();
		return success(body);
	};
}
function surround(left, parser, right) {
	const Left = character(left);
	const Right = character(right);
	return (scanner) => {
		if (!Left(scanner).ok) return failure();
		const result = parser(scanner);
		if (!result.ok) throw new SyntaxError(`Invalid token after "${left}"`);
		if (!Right(scanner).ok) throw new SyntaxError(`Not closed by "${right}" after started with "${left}"`);
		return success(result.body);
	};
}
function character(str) {
	return (scanner) => {
		scanner.skipWhitespaces();
		if (!scanner.startsWith(str)) return failure();
		scanner.next(str.length);
		scanner.skipWhitespaces();
		return success(void 0);
	};
}
const BARE_KEY_REGEXP = /[A-Za-z0-9_-]+/y;
function bareKey(scanner) {
	var _scanner$match;
	scanner.skipWhitespaces();
	const key = (_scanner$match = scanner.match(BARE_KEY_REGEXP)) === null || _scanner$match === void 0 ? void 0 : _scanner$match[0];
	if (!key) return failure();
	scanner.next(key.length);
	return success(key);
}
function escapeSequence(scanner) {
	if (scanner.char() !== "\\") return failure();
	scanner.next();
	switch (scanner.char()) {
		case "b":
			scanner.next();
			return success("\b");
		case "t":
			scanner.next();
			return success("	");
		case "n":
			scanner.next();
			return success("\n");
		case "f":
			scanner.next();
			return success("\f");
		case "r":
			scanner.next();
			return success("\r");
		case "u":
		case "U": {
			const codePointLen = scanner.char() === "u" ? 4 : 6;
			const codePoint = parseInt("0x" + scanner.slice(1, 1 + codePointLen), 16);
			const str = String.fromCodePoint(codePoint);
			scanner.next(codePointLen + 1);
			return success(str);
		}
		case "\"":
			scanner.next();
			return success("\"");
		case "\\":
			scanner.next();
			return success("\\");
		default: throw new SyntaxError(`Invalid escape sequence: \\${scanner.char()}`);
	}
}
function basicString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "\"") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "\"" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function literalString(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "'") return failure();
	scanner.next();
	const acc = [];
	while (scanner.char() !== "'" && !scanner.eof()) {
		if (scanner.char() === "\n") throw new SyntaxError("Single-line string cannot contain EOL");
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Single-line string is not closed:\n${acc.join("")}`);
	scanner.next();
	return success(acc.join(""));
}
function multilineBasicString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("\"\"\"")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("\"\"\"") && !scanner.eof()) {
		if (scanner.startsWith("\\\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		} else if (scanner.startsWith("\\\r\n")) {
			scanner.next();
			scanner.nextUntilChar({ skipComments: false });
			continue;
		}
		const escapedChar = escapeSequence(scanner);
		if (escapedChar.ok) acc.push(escapedChar.body);
		else {
			acc.push(scanner.char());
			scanner.next();
		}
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "\"") {
		acc.push("\"");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
function multilineLiteralString(scanner) {
	scanner.skipWhitespaces();
	if (!scanner.startsWith("'''")) return failure();
	scanner.next(3);
	if (scanner.char() === "\n") scanner.next();
	else if (scanner.startsWith("\r\n")) scanner.next(2);
	const acc = [];
	while (!scanner.startsWith("'''") && !scanner.eof()) {
		acc.push(scanner.char());
		scanner.next();
	}
	if (scanner.eof()) throw new SyntaxError(`Multi-line string is not closed:\n${acc.join("")}`);
	if (scanner.char(3) === "'") {
		acc.push("'");
		scanner.next();
	}
	scanner.next(3);
	return success(acc.join(""));
}
const BOOLEAN_REGEXP = /(?:true|false)\b/y;
function boolean(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(BOOLEAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	return success(string === "true");
}
const INFINITY_MAP = new Map([
	["inf", Infinity],
	["+inf", Infinity],
	["-inf", -Infinity]
]);
const INFINITY_REGEXP = /[+-]?inf\b/y;
function infinity(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(INFINITY_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	return success(INFINITY_MAP.get(string));
}
const NAN_REGEXP = /[+-]?nan\b/y;
function nan(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(NAN_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	return success(NaN);
}
const dottedKey = join1(or([
	bareKey,
	basicString,
	literalString
]), ".");
const BINARY_REGEXP = /0b[01]+(?:_[01]+)*\b/y;
function binary(scanner) {
	var _scanner$match2;
	scanner.skipWhitespaces();
	const match = (_scanner$match2 = scanner.match(BINARY_REGEXP)) === null || _scanner$match2 === void 0 ? void 0 : _scanner$match2[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 2);
	return isNaN(number) ? failure() : success(number);
}
const OCTAL_REGEXP = /0o[0-7]+(?:_[0-7]+)*\b/y;
function octal(scanner) {
	var _scanner$match3;
	scanner.skipWhitespaces();
	const match = (_scanner$match3 = scanner.match(OCTAL_REGEXP)) === null || _scanner$match3 === void 0 ? void 0 : _scanner$match3[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 8);
	return isNaN(number) ? failure() : success(number);
}
const HEX_REGEXP = /0x[0-9a-f]+(?:_[0-9a-f]+)*\b/iy;
function hex(scanner) {
	var _scanner$match4;
	scanner.skipWhitespaces();
	const match = (_scanner$match4 = scanner.match(HEX_REGEXP)) === null || _scanner$match4 === void 0 ? void 0 : _scanner$match4[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.slice(2).replaceAll("_", "");
	const number = parseInt(value$1, 16);
	return isNaN(number) ? failure() : success(number);
}
const INTEGER_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)\b/y;
function integer(scanner) {
	var _scanner$match5;
	scanner.skipWhitespaces();
	const match = (_scanner$match5 = scanner.match(INTEGER_REGEXP)) === null || _scanner$match5 === void 0 ? void 0 : _scanner$match5[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	return success(parseInt(value$1, 10));
}
const FLOAT_REGEXP = /[+-]?(?:0|[1-9][0-9]*(?:_[0-9]+)*)(?:\.[0-9]+(?:_[0-9]+)*)?(?:e[+-]?[0-9]+(?:_[0-9]+)*)?\b/iy;
function float(scanner) {
	var _scanner$match6;
	scanner.skipWhitespaces();
	const match = (_scanner$match6 = scanner.match(FLOAT_REGEXP)) === null || _scanner$match6 === void 0 ? void 0 : _scanner$match6[0];
	if (!match) return failure();
	scanner.next(match.length);
	const value$1 = match.replaceAll("_", "");
	const float$1 = parseFloat(value$1);
	if (isNaN(float$1)) return failure();
	return success(float$1);
}
const DATE_TIME_REGEXP = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})(?:[ 0-9TZ.:+-]+)?\b/y;
function dateTime(scanner) {
	scanner.skipWhitespaces();
	const match = scanner.match(DATE_TIME_REGEXP);
	if (!match) return failure();
	const string = match[0];
	scanner.next(string.length);
	const groups = match.groups;
	if (groups.month == "02") {
		const days = parseInt(groups.day);
		if (days > 29) throw new SyntaxError(`Invalid date string "${match}"`);
		const year = parseInt(groups.year);
		if (days > 28 && !isLeap(year)) throw new SyntaxError(`Invalid date string "${match}"`);
	}
	const date = new Date(string.trim());
	if (isNaN(date.getTime())) throw new SyntaxError(`Invalid date string "${match}"`);
	return success(date);
}
const LOCAL_TIME_REGEXP = /(\d{2}):(\d{2}):(\d{2})(?:\.[0-9]+)?\b/y;
function localTime(scanner) {
	var _scanner$match7;
	scanner.skipWhitespaces();
	const match = (_scanner$match7 = scanner.match(LOCAL_TIME_REGEXP)) === null || _scanner$match7 === void 0 ? void 0 : _scanner$match7[0];
	if (!match) return failure();
	scanner.next(match.length);
	return success(match);
}
function arrayValue(scanner) {
	scanner.skipWhitespaces();
	if (scanner.char() !== "[") return failure();
	scanner.next();
	const array = [];
	while (!scanner.eof()) {
		scanner.nextUntilChar();
		const result = value(scanner);
		if (!result.ok) break;
		array.push(result.body);
		scanner.skipWhitespaces();
		if (scanner.char() !== ",") break;
		scanner.next();
	}
	scanner.nextUntilChar();
	if (scanner.char() !== "]") throw new SyntaxError("Array is not closed");
	scanner.next();
	return success(array);
}
function inlineTable(scanner) {
	scanner.nextUntilChar();
	if (scanner.char(1) === "}") {
		scanner.next(2);
		return success({ __proto__: null });
	}
	const pairs = surround("{", join$1(pair, ","), "}")(scanner);
	if (!pairs.ok) return failure();
	let table$1 = { __proto__: null };
	for (const pair$1 of pairs.body) table$1 = deepMerge(table$1, pair$1);
	return success(table$1);
}
const value = or([
	multilineBasicString,
	multilineLiteralString,
	basicString,
	literalString,
	boolean,
	infinity,
	nan,
	dateTime,
	localTime,
	binary,
	octal,
	hex,
	float,
	integer,
	arrayValue,
	inlineTable
]);
const pair = kv(dottedKey, "=", value);
function block(scanner) {
	scanner.nextUntilChar();
	const result = merge$1(repeat(pair))(scanner);
	if (result.ok) return success({
		type: "Block",
		value: result.body
	});
	return failure();
}
const tableHeader = surround("[", dottedKey, "]");
function table(scanner) {
	scanner.nextUntilChar();
	const header = tableHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "Table",
		keys: header.body,
		value: b.ok ? b.body.value : { __proto__: null }
	});
}
const tableArrayHeader = surround("[[", dottedKey, "]]");
function tableArray(scanner) {
	scanner.nextUntilChar();
	const header = tableArrayHeader(scanner);
	if (!header.ok) return failure();
	scanner.nextUntilChar();
	const b = block(scanner);
	return success({
		type: "TableArray",
		keys: header.body,
		value: b.ok ? b.body.value : { __proto__: null }
	});
}
function toml(scanner) {
	const blocks = repeat(or([
		block,
		tableArray,
		table
	]))(scanner);
	if (!blocks.ok) return success({ __proto__: null });
	return success(blocks.body.reduce(deepAssign, { __proto__: null }));
}
function createParseErrorMessage(scanner, message) {
	var _lines$at;
	const lines = scanner.source.slice(0, scanner.position).split("\n");
	return `Parse error on line ${lines.length}, column ${((_lines$at = lines.at(-1)) === null || _lines$at === void 0 ? void 0 : _lines$at.length) ?? 0}: ${message}`;
}
function parserFactory(parser) {
	return (tomlString) => {
		const scanner = new Scanner(tomlString);
		try {
			const result = parser(scanner);
			if (result.ok && scanner.eof()) return result.body;
			const message = `Unexpected character: "${scanner.char()}"`;
			throw new SyntaxError(createParseErrorMessage(scanner, message));
		} catch (error) {
			if (error instanceof Error) throw new SyntaxError(createParseErrorMessage(scanner, error.message));
			throw new SyntaxError(createParseErrorMessage(scanner, "Invalid error type caught"));
		}
	};
}

//#endregion
//#region ../node_modules/@std/toml/parse.js
/**
* Parses a {@link https://toml.io | TOML} string into an object.
*
* @example Usage
* ```ts
* import { parse } from "@std/toml/parse";
* import { assertEquals } from "@std/assert";
*
* const tomlString = `title = "TOML Example"
* [owner]
* name = "Alice"
* bio = "Alice is a programmer."`;
*
* const obj = parse(tomlString);
* assertEquals(obj, { title: "TOML Example", owner: { name: "Alice", bio: "Alice is a programmer." } });
* ```
* @param tomlString TOML string to be parsed.
* @returns The parsed JS object.
*/ function parse$2(tomlString) {
	return parserFactory(toml)(tomlString);
}

//#endregion
//#region ../node_modules/empathic/resolve.mjs
/**
* Resolve an absolute path from {@link root}, but only
* if {@link input} isn't already absolute.
*
* @param input The path to resolve.
* @param root The base path; default = process.cwd()
* @returns The resolved absolute path.
*/
function absolute(input$1, root) {
	return isAbsolute(input$1) ? input$1 : resolve(root || ".", input$1);
}

//#endregion
//#region ../node_modules/empathic/walk.mjs
/**
* Get all parent directories of {@link base}.
* Stops after {@link Options['last']} is processed.
*
* @returns An array of absolute paths of all parent directories.
*/
function up(base, options) {
	let { last, cwd } = options || {};
	let tmp = absolute(base, cwd);
	let root = absolute(last || "/", cwd);
	let prev, arr = [];
	while (prev !== root) {
		arr.push(tmp);
		tmp = dirname(prev = tmp);
		if (tmp === prev) break;
	}
	return arr;
}

//#endregion
//#region ../node_modules/empathic/find.mjs
/**
* Find a directory by name, walking parent directories until found.
*
* > [NOTE]
* > This function only returns a value for directory matches.
* > A file match with the same name will be ignored.
*
* @param name The directory name to find.
* @returns The absolute path to the file, if found.
*/
function dir(name, options) {
	let dir$1, tmp;
	let start = options && options.cwd || "";
	for (dir$1 of up(start, options)) try {
		tmp = join(dir$1, name);
		if (statSync(tmp).isDirectory()) return tmp;
	} catch {}
}

//#endregion
//#region src/def/rename.ts
var BaseRenameCommand = class extends Command {
	static paths = [["rename"]];
	static usage = Command.Usage({ description: "Rename the NAPI-RS project" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	$$name = Option.String("--name,-n", { description: "The new name of the project" });
	binaryName = Option.String("--binary-name,-b", { description: "The new binary name *.node files" });
	packageName = Option.String("--package-name", { description: "The new package name of the project" });
	manifestPath = Option.String("--manifest-path", "Cargo.toml", { description: "Path to `Cargo.toml`" });
	repository = Option.String("--repository", { description: "The new repository of the project" });
	description = Option.String("--description", { description: "The new description of the project" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			name: this.$$name,
			binaryName: this.binaryName,
			packageName: this.packageName,
			manifestPath: this.manifestPath,
			repository: this.repository,
			description: this.description
		};
	}
};
function applyDefaultRenameOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		manifestPath: "Cargo.toml",
		...options
	};
}

//#endregion
//#region src/api/rename.ts
async function renameProject(userOptions) {
	const options = applyDefaultRenameOptions(userOptions);
	const oldName = (await readConfig(options)).binaryName;
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const cargoTomlPath = resolve(options.cwd, options.manifestPath);
	const packageJsonContent = await readFileAsync(packageJsonPath, "utf8");
	const packageJsonData = JSON.parse(packageJsonContent);
	merge(merge(packageJsonData, omitBy(pick(options, [
		"name",
		"description",
		"author",
		"license"
	]), isNil)), { napi: omitBy({
		binaryName: options.binaryName,
		packageName: options.packageName
	}, isNil) });
	if (options.configPath) {
		const configPath = resolve(options.cwd, options.configPath);
		const configContent = await readFileAsync(configPath, "utf8");
		const configData = JSON.parse(configContent);
		configData.binaryName = options.binaryName;
		configData.packageName = options.packageName;
		await writeFileAsync(configPath, JSON.stringify(configData, null, 2));
	}
	await writeFileAsync(packageJsonPath, JSON.stringify(packageJsonData, null, 2));
	const cargoToml = parse$2(await readFileAsync(cargoTomlPath, "utf8"));
	if (cargoToml.package && options.binaryName) {
		const sanitizedName = options.binaryName.replace("@", "").replace("/", "_").replace(/-/g, "_").toLowerCase();
		cargoToml.package.name = sanitizedName;
	}
	await writeFileAsync(cargoTomlPath, stringify(cargoToml));
	if (oldName !== options.binaryName) {
		const githubActionsPath = dir(".github", { cwd: options.cwd });
		if (githubActionsPath) {
			const githubActionsCIYmlPath = join(githubActionsPath, "workflows", "CI.yml");
			if (existsSync(githubActionsCIYmlPath)) {
				var _githubActionsData$en;
				const githubActionsData = load(await readFileAsync(githubActionsCIYmlPath, "utf8"));
				if ((_githubActionsData$en = githubActionsData.env) === null || _githubActionsData$en === void 0 ? void 0 : _githubActionsData$en.APP_NAME) {
					githubActionsData.env.APP_NAME = options.binaryName;
					await writeFileAsync(githubActionsCIYmlPath, dump(githubActionsData, {
						lineWidth: -1,
						noRefs: true,
						sortKeys: false
					}));
				}
			}
		}
		const oldWasiBrowserBindingPath = join(options.cwd, `${oldName}.wasi-browser.js`);
		if (existsSync(oldWasiBrowserBindingPath)) await rename(oldWasiBrowserBindingPath, join(options.cwd, `${options.binaryName}.wasi-browser.js`));
		const oldWasiBindingPath = join(options.cwd, `${oldName}.wasi.cjs`);
		if (existsSync(oldWasiBindingPath)) await rename(oldWasiBindingPath, join(options.cwd, `${options.binaryName}.wasi.cjs`));
		const gitAttributesPath = join(options.cwd, ".gitattributes");
		if (existsSync(gitAttributesPath)) await writeFileAsync(gitAttributesPath, (await readFileAsync(gitAttributesPath, "utf8")).split("\n").map((line) => {
			return line.replace(`${oldName}.wasi-browser.js`, `${options.binaryName}.wasi-browser.js`).replace(`${oldName}.wasi.cjs`, `${options.binaryName}.wasi.cjs`);
		}).join("\n"));
	}
}

//#endregion
//#region src/api/new.ts
const debug$5 = debugFactory("new");
const TEMPLATE_REPOS = {
	yarn: "https://github.com/napi-rs/package-template",
	pnpm: "https://github.com/napi-rs/package-template-pnpm"
};
async function checkGitCommand() {
	try {
		await new Promise((resolve$1) => {
			const cp = exec("git --version");
			cp.on("error", () => {
				resolve$1(false);
			});
			cp.on("exit", (code) => {
				if (code === 0) resolve$1(true);
				else resolve$1(false);
			});
		});
		return true;
	} catch {
		return false;
	}
}
async function ensureCacheDir(packageManager) {
	const cacheDir = path.join(homedir(), ".napi-rs", "template", packageManager);
	await mkdirAsync(cacheDir, { recursive: true });
	return cacheDir;
}
async function downloadTemplate(packageManager, cacheDir) {
	const repoUrl = TEMPLATE_REPOS[packageManager];
	const templatePath = path.join(cacheDir, "repo");
	if (existsSync(templatePath)) {
		debug$5(`Template cache found at ${templatePath}, updating...`);
		try {
			await new Promise((resolve$1, reject) => {
				const cp = exec("git fetch origin", { cwd: templatePath });
				cp.on("error", reject);
				cp.on("exit", (code) => {
					if (code === 0) resolve$1();
					else reject(/* @__PURE__ */ new Error(`Failed to fetch latest changes, git process exited with code ${code}`));
				});
			});
			execSync("git reset --hard origin/main", {
				cwd: templatePath,
				stdio: "ignore"
			});
			debug$5("Template updated successfully");
		} catch (error) {
			debug$5(`Failed to update template: ${error}`);
			throw new Error(`Failed to update template from ${repoUrl}: ${error}`);
		}
	} else {
		debug$5(`Cloning template from ${repoUrl}...`);
		try {
			execSync(`git clone ${repoUrl} repo`, {
				cwd: cacheDir,
				stdio: "inherit"
			});
			debug$5("Template cloned successfully");
		} catch (error) {
			throw new Error(`Failed to clone template from ${repoUrl}: ${error}`);
		}
	}
}
async function copyDirectory(src, dest, includeWasiBindings) {
	await mkdirAsync(dest, { recursive: true });
	const entries = await promises.readdir(src, { withFileTypes: true });
	for (const entry of entries) {
		const srcPath = path.join(src, entry.name);
		const destPath = path.join(dest, entry.name);
		if (entry.name === ".git") continue;
		if (entry.isDirectory()) await copyDirectory(srcPath, destPath, includeWasiBindings);
		else {
			if (!includeWasiBindings && (entry.name.endsWith(".wasi-browser.js") || entry.name.endsWith(".wasi.cjs") || entry.name.endsWith("wasi-worker.browser.mjs ") || entry.name.endsWith("wasi-worker.mjs") || entry.name.endsWith("browser.js"))) continue;
			await promises.copyFile(srcPath, destPath);
		}
	}
}
async function filterTargetsInPackageJson(filePath, enabledTargets) {
	var _packageJson$napi;
	const content = await promises.readFile(filePath, "utf-8");
	const packageJson = JSON.parse(content);
	if ((_packageJson$napi = packageJson.napi) === null || _packageJson$napi === void 0 ? void 0 : _packageJson$napi.targets) packageJson.napi.targets = packageJson.napi.targets.filter((target) => enabledTargets.includes(target));
	await promises.writeFile(filePath, JSON.stringify(packageJson, null, 2) + "\n");
}
async function filterTargetsInGithubActions(filePath, enabledTargets) {
	var _yaml$jobs, _yaml$jobs5;
	const yaml = load(await promises.readFile(filePath, "utf-8"));
	const macOSAndWindowsTargets = new Set([
		"x86_64-pc-windows-msvc",
		"x86_64-pc-windows-gnu",
		"aarch64-pc-windows-msvc",
		"x86_64-apple-darwin"
	]);
	const linuxTargets = new Set([
		"x86_64-unknown-linux-gnu",
		"x86_64-unknown-linux-musl",
		"aarch64-unknown-linux-gnu",
		"aarch64-unknown-linux-musl",
		"armv7-unknown-linux-gnueabihf",
		"armv7-unknown-linux-musleabihf",
		"loongarch64-unknown-linux-gnu",
		"riscv64gc-unknown-linux-gnu",
		"powerpc64le-unknown-linux-gnu",
		"s390x-unknown-linux-gnu",
		"aarch64-linux-android",
		"armv7-linux-androideabi"
	]);
	const hasLinuxTargets = enabledTargets.some((target) => linuxTargets.has(target));
	if (yaml === null || yaml === void 0 || (_yaml$jobs = yaml.jobs) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.build) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.strategy) === null || _yaml$jobs === void 0 || (_yaml$jobs = _yaml$jobs.matrix) === null || _yaml$jobs === void 0 ? void 0 : _yaml$jobs.settings) yaml.jobs.build.strategy.matrix.settings = yaml.jobs.build.strategy.matrix.settings.filter((setting) => {
		if (setting.target) return enabledTargets.includes(setting.target);
		return true;
	});
	const jobsToRemove = [];
	if (enabledTargets.every((target) => !macOSAndWindowsTargets.has(target))) jobsToRemove.push("test-macOS-windows-binding");
	else {
		var _yaml$jobs2;
		if (yaml === null || yaml === void 0 || (_yaml$jobs2 = yaml.jobs) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2["test-macOS-windows-binding"]) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2.strategy) === null || _yaml$jobs2 === void 0 || (_yaml$jobs2 = _yaml$jobs2.matrix) === null || _yaml$jobs2 === void 0 ? void 0 : _yaml$jobs2.settings) yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings = yaml.jobs["test-macOS-windows-binding"].strategy.matrix.settings.filter((setting) => {
			if (setting.target) return enabledTargets.includes(setting.target);
			return true;
		});
	}
	if (!hasLinuxTargets) {
		var _yaml$jobs3;
		if (yaml === null || yaml === void 0 || (_yaml$jobs3 = yaml.jobs) === null || _yaml$jobs3 === void 0 ? void 0 : _yaml$jobs3["test-linux-binding"]) jobsToRemove.push("test-linux-binding");
	} else {
		var _yaml$jobs4;
		if (yaml === null || yaml === void 0 || (_yaml$jobs4 = yaml.jobs) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4["test-linux-binding"]) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4.strategy) === null || _yaml$jobs4 === void 0 || (_yaml$jobs4 = _yaml$jobs4.matrix) === null || _yaml$jobs4 === void 0 ? void 0 : _yaml$jobs4.target) yaml.jobs["test-linux-binding"].strategy.matrix.target = yaml.jobs["test-linux-binding"].strategy.matrix.target.filter((target) => {
			if (target) return enabledTargets.includes(target);
			return true;
		});
	}
	if (!enabledTargets.includes("wasm32-wasip1-threads")) jobsToRemove.push("test-wasi");
	if (!enabledTargets.includes("x86_64-unknown-freebsd")) jobsToRemove.push("build-freebsd");
	for (const [jobName, jobConfig] of Object.entries(yaml.jobs || {})) if (jobName.startsWith("test-") && jobName !== "test-macOS-windows-binding" && jobName !== "test-linux-x64-gnu-binding") {
		var _job$strategy;
		const job = jobConfig;
		if ((_job$strategy = job.strategy) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy.matrix) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy.settings) === null || _job$strategy === void 0 || (_job$strategy = _job$strategy[0]) === null || _job$strategy === void 0 ? void 0 : _job$strategy.target) {
			const target = job.strategy.matrix.settings[0].target;
			if (!enabledTargets.includes(target)) jobsToRemove.push(jobName);
		}
	}
	for (const jobName of jobsToRemove) delete yaml.jobs[jobName];
	if (Array.isArray((_yaml$jobs5 = yaml.jobs) === null || _yaml$jobs5 === void 0 || (_yaml$jobs5 = _yaml$jobs5.publish) === null || _yaml$jobs5 === void 0 ? void 0 : _yaml$jobs5.needs)) yaml.jobs.publish.needs = yaml.jobs.publish.needs.filter((need) => !jobsToRemove.includes(need));
	const updatedYaml = dump(yaml, {
		lineWidth: -1,
		noRefs: true,
		sortKeys: false
	});
	await promises.writeFile(filePath, updatedYaml);
}
function processOptions(options) {
	var _options$targets;
	debug$5("Processing options...");
	if (!options.path) throw new Error("Please provide the path as the argument");
	options.path = path.resolve(process.cwd(), options.path);
	debug$5(`Resolved target path to: ${options.path}`);
	if (!options.name) {
		options.name = path.parse(options.path).base;
		debug$5(`No project name provided, fix it to dir name: ${options.name}`);
	}
	if (!((_options$targets = options.targets) === null || _options$targets === void 0 ? void 0 : _options$targets.length)) if (options.enableAllTargets) {
		options.targets = AVAILABLE_TARGETS.concat();
		debug$5("Enable all targets");
	} else if (options.enableDefaultTargets) {
		options.targets = DEFAULT_TARGETS.concat();
		debug$5("Enable default targets");
	} else throw new Error("At least one target must be enabled");
	if (options.targets.some((target) => target === "wasm32-wasi-preview1-threads")) {
		if (execSync(`rustup target list`, { encoding: "utf8" }).includes("wasm32-wasip1-threads")) options.targets = options.targets.map((target) => target === "wasm32-wasi-preview1-threads" ? "wasm32-wasip1-threads" : target);
	}
	return applyDefaultNewOptions(options);
}
async function newProject(userOptions) {
	debug$5("Will create napi-rs project with given options:");
	debug$5(userOptions);
	const options = processOptions(userOptions);
	debug$5("Targets to be enabled:");
	debug$5(options.targets);
	if (!await checkGitCommand()) throw new Error("Git is not installed or not available in PATH. Please install Git to continue.");
	const packageManager = options.packageManager;
	await ensurePath(options.path, options.dryRun);
	if (!options.dryRun) try {
		const cacheDir = await ensureCacheDir(packageManager);
		await downloadTemplate(packageManager, cacheDir);
		await copyDirectory(path.join(cacheDir, "repo"), options.path, options.targets.includes("wasm32-wasip1-threads"));
		await renameProject({
			cwd: options.path,
			name: options.name,
			binaryName: getBinaryName(options.name)
		});
		const packageJsonPath = path.join(options.path, "package.json");
		if (existsSync(packageJsonPath)) await filterTargetsInPackageJson(packageJsonPath, options.targets);
		const ciPath = path.join(options.path, ".github", "workflows", "CI.yml");
		if (existsSync(ciPath) && options.enableGithubActions) await filterTargetsInGithubActions(ciPath, options.targets);
		else if (!options.enableGithubActions && existsSync(path.join(options.path, ".github"))) await promises.rm(path.join(options.path, ".github"), {
			recursive: true,
			force: true
		});
		const pkgJsonContent = await promises.readFile(packageJsonPath, "utf-8");
		const pkgJson = JSON.parse(pkgJsonContent);
		if (!pkgJson.engines) pkgJson.engines = {};
		pkgJson.engines.node = napiEngineRequirement(options.minNodeApiVersion);
		if (options.license && pkgJson.license !== options.license) pkgJson.license = options.license;
		if (options.testFramework !== "ava") debug$5(`Test framework ${options.testFramework} requested but not yet implemented`);
		await promises.writeFile(packageJsonPath, JSON.stringify(pkgJson, null, 2) + "\n");
	} catch (error) {
		throw new Error(`Failed to create project: ${error}`);
	}
	debug$5(`Project created at: ${options.path}`);
}
async function ensurePath(path$1, dryRun = false) {
	const stat$1 = await statAsync(path$1, {}).catch(() => void 0);
	if (stat$1) {
		if (stat$1.isFile()) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not a directory.`);
		else if (stat$1.isDirectory()) {
			if ((await readdirAsync(path$1)).length) throw new Error(`Path ${path$1} for creating new napi-rs project already exists and it's not empty.`);
		}
	}
	if (!dryRun) try {
		debug$5(`Try to create target directory: ${path$1}`);
		if (!dryRun) await mkdirAsync(path$1, { recursive: true });
	} catch (e) {
		throw new Error(`Failed to create target directory: ${path$1}`, { cause: e });
	}
}
function getBinaryName(name) {
	return name.split("/").pop();
}

//#endregion
//#region src/def/pre-publish.ts
var BasePrePublishCommand = class extends Command {
	static paths = [["pre-publish"], ["prepublish"]];
	static usage = Command.Usage({ description: "Update package.json and copy addons into per platform packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir,-p", "npm", { description: "Path to the folder where the npm packages put" });
	tagStyle = Option.String("--tag-style,--tagstyle,-t", "lerna", { description: "git tag style, `npm` or `lerna`" });
	ghRelease = Option.Boolean("--gh-release", true, { description: "Whether create GitHub release" });
	ghReleaseName = Option.String("--gh-release-name", { description: "GitHub release name" });
	ghReleaseId = Option.String("--gh-release-id", { description: "Existing GitHub release id" });
	skipOptionalPublish = Option.Boolean("--skip-optional-publish", false, { description: "Whether skip optionalDependencies packages publish" });
	dryRun = Option.Boolean("--dry-run", false, { description: "Dry run without touching file system" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir,
			tagStyle: this.tagStyle,
			ghRelease: this.ghRelease,
			ghReleaseName: this.ghReleaseName,
			ghReleaseId: this.ghReleaseId,
			skipOptionalPublish: this.skipOptionalPublish,
			dryRun: this.dryRun
		};
	}
};
function applyDefaultPrePublishOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		tagStyle: "lerna",
		ghRelease: true,
		skipOptionalPublish: false,
		dryRun: false,
		...options
	};
}

//#endregion
//#region src/def/version.ts
var BaseVersionCommand = class extends Command {
	static paths = [["version"]];
	static usage = Command.Usage({ description: "Update version in created npm packages" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	npmDir = Option.String("--npm-dir", "npm", { description: "Path to the folder where the npm packages put" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			npmDir: this.npmDir
		};
	}
};
function applyDefaultVersionOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		npmDir: "npm",
		...options
	};
}

//#endregion
//#region src/api/version.ts
const debug$4 = debugFactory("version");
async function version(userOptions) {
	const options = applyDefaultVersionOptions(userOptions);
	const config = await readNapiConfig(resolve(options.cwd, options.packageJsonPath), options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	for (const target of config.targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, target.platformArchABI);
		debug$4(`Update version to %i in [%i]`, config.packageJson.version, pkgDir);
		await updatePackageJson(join(pkgDir, "package.json"), { version: config.packageJson.version });
	}
}

//#endregion
//#region src/api/pre-publish.ts
const debug$3 = debugFactory("pre-publish");
async function prePublish(userOptions) {
	debug$3("Receive pre-publish options:");
	debug$3("  %O", userOptions);
	const options = applyDefaultPrePublishOptions(userOptions);
	const packageJsonPath = resolve(options.cwd, options.packageJsonPath);
	const { packageJson, targets, packageName, binaryName, npmClient } = await readNapiConfig(packageJsonPath, options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	async function createGhRelease(packageName$1, version$2) {
		if (!options.ghRelease) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		const { repo: repo$1, owner: owner$1, pkgInfo: pkgInfo$1, octokit: octokit$1 } = getRepoInfo(packageName$1, version$2);
		if (!repo$1 || !owner$1) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		if (!options.dryRun) try {
			await octokit$1.repos.createRelease({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag,
				name: options.ghReleaseName,
				prerelease: version$2.includes("alpha") || version$2.includes("beta") || version$2.includes("rc")
			});
		} catch (e) {
			debug$3(`Params: ${JSON.stringify({
				owner: owner$1,
				repo: repo$1,
				tag_name: pkgInfo$1.tag
			}, null, 2)}`);
			console.error(e);
		}
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	function getRepoInfo(packageName$1, version$2) {
		const headCommit = execSync("git log -1 --pretty=%B", { encoding: "utf-8" }).trim();
		const { GITHUB_REPOSITORY } = process.env;
		if (!GITHUB_REPOSITORY) return {
			owner: null,
			repo: null,
			pkgInfo: {
				name: null,
				version: null,
				tag: null
			}
		};
		debug$3(`Github repository: ${GITHUB_REPOSITORY}`);
		const [owner$1, repo$1] = GITHUB_REPOSITORY.split("/");
		const octokit$1 = new Octokit({ auth: process.env.GITHUB_TOKEN });
		let pkgInfo$1;
		if (options.tagStyle === "lerna") {
			pkgInfo$1 = headCommit.split("\n").map((line) => line.trim()).filter((line, index) => line.length && index).map((line) => line.substring(2)).map(parseTag).find((pkgInfo$2) => pkgInfo$2.name === packageName$1);
			if (!pkgInfo$1) throw new TypeError(`No release commit found with ${packageName$1}, original commit info: ${headCommit}`);
		} else pkgInfo$1 = {
			tag: `v${version$2}`,
			version: version$2,
			name: packageName$1
		};
		return {
			owner: owner$1,
			repo: repo$1,
			pkgInfo: pkgInfo$1,
			octokit: octokit$1
		};
	}
	if (!options.dryRun) {
		await version(userOptions);
		await updatePackageJson(packageJsonPath, { optionalDependencies: targets.reduce((deps, target) => {
			deps[`${packageName}-${target.platformArchABI}`] = packageJson.version;
			return deps;
		}, {}) });
	}
	const { owner, repo, pkgInfo, octokit } = options.ghReleaseId ? getRepoInfo(packageName, packageJson.version) : await createGhRelease(packageName, packageJson.version);
	for (const target of targets) {
		const pkgDir = resolve(options.cwd, options.npmDir, `${target.platformArchABI}`);
		const ext = target.platform === "wasi" || target.platform === "wasm" ? "wasm" : "node";
		const filename = `${binaryName}.${target.platformArchABI}.${ext}`;
		const dstPath = join(pkgDir, filename);
		if (!options.dryRun) {
			if (!existsSync(dstPath)) {
				debug$3.warn(`%s doesn't exist`, dstPath);
				continue;
			}
			if (!options.skipOptionalPublish) try {
				const output = execSync(`${npmClient} publish`, {
					cwd: pkgDir,
					env: process.env,
					stdio: "pipe"
				});
				process.stdout.write(output);
			} catch (e) {
				if (e instanceof Error && e.message.includes("You cannot publish over the previously published versions")) {
					console.info(e.message);
					debug$3.warn(`${pkgDir} has been published, skipping`);
				} else throw e;
			}
			if (options.ghRelease && repo && owner) {
				debug$3.info(`Creating GitHub release ${pkgInfo.tag}`);
				try {
					const releaseId = options.ghReleaseId ? Number(options.ghReleaseId) : (await octokit.repos.getReleaseByTag({
						repo,
						owner,
						tag: pkgInfo.tag
					})).data.id;
					const dstFileStats = statSync(dstPath);
					const assetInfo = await octokit.repos.uploadReleaseAsset({
						owner,
						repo,
						name: filename,
						release_id: releaseId,
						mediaType: { format: "raw" },
						headers: {
							"content-length": dstFileStats.size,
							"content-type": "application/octet-stream"
						},
						data: await readFileAsync(dstPath)
					});
					debug$3.info(`GitHub release created`);
					debug$3.info(`Download URL: %s`, assetInfo.data.browser_download_url);
				} catch (e) {
					debug$3.error(`Param: ${JSON.stringify({
						owner,
						repo,
						tag: pkgInfo.tag,
						filename: dstPath
					}, null, 2)}`);
					debug$3.error(e);
				}
			}
		}
	}
}
function parseTag(tag) {
	const segments = tag.split("@");
	const version$2 = segments.pop();
	return {
		name: segments.join("@"),
		version: version$2,
		tag
	};
}

//#endregion
//#region src/def/universalize.ts
var BaseUniversalizeCommand = class extends Command {
	static paths = [["universalize"]];
	static usage = Command.Usage({ description: "Combile built binaries into one universal binary" });
	cwd = Option.String("--cwd", process.cwd(), { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", "package.json", { description: "Path to `package.json`" });
	outputDir = Option.String("--output-dir,-o", "./", { description: "Path to the folder where all built `.node` files put, same as `--output-dir` of build command" });
	getOptions() {
		return {
			cwd: this.cwd,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			outputDir: this.outputDir
		};
	}
};
function applyDefaultUniversalizeOptions(options) {
	return {
		cwd: process.cwd(),
		packageJsonPath: "package.json",
		outputDir: "./",
		...options
	};
}

//#endregion
//#region src/api/universalize.ts
const debug$2 = debugFactory("universalize");
const universalizers = { darwin: (inputs, output) => {
	spawnSync("lipo", [
		"-create",
		"-output",
		output,
		...inputs
	], { stdio: "inherit" });
} };
async function universalizeBinaries(userOptions) {
	var _UniArchsByPlatform$p, _universalizers$proce;
	const options = applyDefaultUniversalizeOptions(userOptions);
	const config = await readNapiConfig(join(options.cwd, options.packageJsonPath), options.configPath ? resolve(options.cwd, options.configPath) : void 0);
	if (!config.targets.find((t) => t.platform === process.platform && t.arch === "universal")) throw new Error(`'universal' arch for platform '${process.platform}' not found in config!`);
	const srcFiles = (_UniArchsByPlatform$p = UniArchsByPlatform[process.platform]) === null || _UniArchsByPlatform$p === void 0 ? void 0 : _UniArchsByPlatform$p.map((arch) => resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-${arch}.node`));
	if (!srcFiles || !universalizers[process.platform]) throw new Error(`'universal' arch for platform '${process.platform}' not supported.`);
	debug$2(`Looking up source binaries to combine: `);
	debug$2("  %O", srcFiles);
	const srcFileLookup = await Promise.all(srcFiles.map((f) => fileExists(f)));
	const notFoundFiles = srcFiles.filter((_, i) => !srcFileLookup[i]);
	if (notFoundFiles.length) throw new Error(`Some binary files were not found: ${JSON.stringify(notFoundFiles)}`);
	const output = resolve(options.cwd, options.outputDir, `${config.binaryName}.${process.platform}-universal.node`);
	(_universalizers$proce = universalizers[process.platform]) === null || _universalizers$proce === void 0 || _universalizers$proce.call(universalizers, srcFiles, output);
	debug$2(`Produced universal binary: ${output}`);
}

//#endregion
//#region src/commands/artifacts.ts
var ArtifactsCommand = class extends BaseArtifactsCommand {
	static usage = Command.Usage({
		description: "Copy artifacts from Github Actions into specified dir",
		examples: [["$0 artifacts --output-dir ./artifacts --dist ./npm", `Copy [binaryName].[platform].node under current dir(.) into packages under npm dir.
e.g: index.linux-x64-gnu.node --> ./npm/linux-x64-gnu/index.linux-x64-gnu.node`]]
	});
	static paths = [["artifacts"]];
	async execute() {
		await collectArtifacts(this.getOptions());
	}
};

//#endregion
//#region src/def/build.ts
var BaseBuildCommand = class extends Command {
	static paths = [["build"]];
	static usage = Command.Usage({ description: "Build the NAPI-RS project" });
	target = Option.String("--target,-t", { description: "Build for the target triple, bypassed to `cargo build --target`" });
	cwd = Option.String("--cwd", { description: "The working directory of where napi command will be executed in, all other paths options are relative to this path" });
	manifestPath = Option.String("--manifest-path", { description: "Path to `Cargo.toml`" });
	configPath = Option.String("--config-path,-c", { description: "Path to `napi` config json file" });
	packageJsonPath = Option.String("--package-json-path", { description: "Path to `package.json`" });
	targetDir = Option.String("--target-dir", { description: "Directory for all crate generated artifacts, see `cargo build --target-dir`" });
	outputDir = Option.String("--output-dir,-o", { description: "Path to where all the built files would be put. Default to the crate folder" });
	platform = Option.Boolean("--platform", { description: "Add platform triple to the generated nodejs binding file, eg: `[name].linux-x64-gnu.node`" });
	jsPackageName = Option.String("--js-package-name", { description: "Package name in generated js binding file. Only works with `--platform` flag" });
	constEnum = Option.Boolean("--const-enum", { description: "Whether generate const enum for typescript bindings" });
	jsBinding = Option.String("--js", { description: "Path and filename of generated JS binding file. Only works with `--platform` flag. Relative to `--output-dir`." });
	noJsBinding = Option.Boolean("--no-js", { description: "Whether to disable the generation JS binding file. Only works with `--platform` flag." });
	dts = Option.String("--dts", { description: "Path and filename of generated type def file. Relative to `--output-dir`" });
	dtsHeader = Option.String("--dts-header", { description: "Custom file header for generated type def file. Only works when `typedef` feature enabled." });
	noDtsHeader = Option.Boolean("--no-dts-header", { description: "Whether to disable the default file header for generated type def file. Only works when `typedef` feature enabled." });
	dtsCache = Option.Boolean("--dts-cache", true, { description: "Whether to enable the dts cache, default to true" });
	esm = Option.Boolean("--esm", { description: "Whether to emit an ESM JS binding file instead of CJS format. Only works with `--platform` flag." });
	strip = Option.Boolean("--strip,-s", { description: "Whether strip the library to achieve the minimum file size" });
	release = Option.Boolean("--release,-r", { description: "Build in release mode" });
	verbose = Option.Boolean("--verbose,-v", { description: "Verbosely log build command trace" });
	bin = Option.String("--bin", { description: "Build only the specified binary" });
	package = Option.String("--package,-p", { description: "Build the specified library or the one at cwd" });
	profile = Option.String("--profile", { description: "Build artifacts with the specified profile" });
	crossCompile = Option.Boolean("--cross-compile,-x", { description: "[experimental] cross-compile for the specified target with `cargo-xwin` on windows and `cargo-zigbuild` on other platform" });
	useCross = Option.Boolean("--use-cross", { description: "[experimental] use [cross](https://github.com/cross-rs/cross) instead of `cargo`" });
	useNapiCross = Option.Boolean("--use-napi-cross", { description: "[experimental] use @napi-rs/cross-toolchain to cross-compile Linux arm/arm64/x64 gnu targets." });
	watch = Option.Boolean("--watch,-w", { description: "watch the crate changes and build continuously with `cargo-watch` crates" });
	features = Option.Array("--features,-F", { description: "Space-separated list of features to activate" });
	allFeatures = Option.Boolean("--all-features", { description: "Activate all available features" });
	noDefaultFeatures = Option.Boolean("--no-default-features", { description: "Do not activate the `default` feature" });
	getOptions() {
		return {
			target: this.target,
			cwd: this.cwd,
			manifestPath: this.manifestPath,
			configPath: this.configPath,
			packageJsonPath: this.packageJsonPath,
			targetDir: this.targetDir,
			outputDir: this.outputDir,
			platform: this.platform,
			jsPackageName: this.jsPackageName,
			constEnum: this.constEnum,
			jsBinding: this.jsBinding,
			noJsBinding: this.noJsBinding,
			dts: this.dts,
			dtsHeader: this.dtsHeader,
			noDtsHeader: this.noDtsHeader,
			dtsCache: this.dtsCache,
			esm: this.esm,
			strip: this.strip,
			release: this.release,
			verbose: this.verbose,
			bin: this.bin,
			package: this.package,
			profile: this.profile,
			crossCompile: this.crossCompile,
			useCross: this.useCross,
			useNapiCross: this.useNapiCross,
			watch: this.watch,
			features: this.features,
			allFeatures: this.allFeatures,
			noDefaultFeatures: this.noDefaultFeatures
		};
	}
};

//#endregion
//#region src/commands/build.ts
const debug$1 = debugFactory("build");
var BuildCommand = class extends BaseBuildCommand {
	pipe = Option.String("--pipe", { description: "Pipe all outputs file to given command. e.g. `napi build --pipe \"npx prettier --write\"`" });
	cargoOptions = Option.Rest();
	async execute() {
		const { task } = await buildProject({
			...this.getOptions(),
			cargoOptions: this.cargoOptions
		});
		const outputs = await task;
		if (this.pipe) for (const output of outputs) {
			debug$1("Piping output file to command: %s", this.pipe);
			try {
				execSync(`${this.pipe} ${output.path}`, {
					stdio: "inherit",
					cwd: this.cwd
				});
			} catch (e) {
				debug$1.error(`Failed to pipe output file ${output.path} to command`);
				debug$1.error(e);
			}
		}
	}
};

//#endregion
//#region src/commands/create-npm-dirs.ts
var CreateNpmDirsCommand = class extends BaseCreateNpmDirsCommand {
	async execute() {
		await createNpmDirs(this.getOptions());
	}
};

//#endregion
//#region src/commands/help.ts
/**
* A command that prints the usage of all commands.
*
* Paths: `-h`, `--help`
*/
var HelpCommand = class extends Command {
	static paths = [[`-h`], [`--help`]];
	async execute() {
		await this.context.stdout.write(this.cli.usage());
	}
};

//#endregion
//#region src/commands/new.ts
const debug = debugFactory("new");
var NewCommand = class extends BaseNewCommand {
	interactive = Option.Boolean("--interactive,-i", true, { description: "Ask project basic information interactively without just using the default." });
	async execute() {
		try {
			await newProject(await this.fetchOptions());
			return 0;
		} catch (e) {
			debug("Failed to create new project");
			debug.error(e);
			return 1;
		}
	}
	async fetchOptions() {
		const cmdOptions = super.getOptions();
		if (this.interactive) {
			const targetPath = cmdOptions.path ? cmdOptions.path : await inquirerProjectPath();
			cmdOptions.path = targetPath;
			return {
				...cmdOptions,
				name: await this.fetchName(path.parse(targetPath).base),
				minNodeApiVersion: await this.fetchNapiVersion(),
				targets: await this.fetchTargets(),
				license: await this.fetchLicense(),
				enableTypeDef: await this.fetchTypeDef(),
				enableGithubActions: await this.fetchGithubActions()
			};
		}
		return cmdOptions;
	}
	async fetchName(defaultName) {
		return this.$$name ?? input({
			message: "Package name (the name field in your package.json file)",
			default: defaultName
		});
	}
	async fetchLicense() {
		return input({
			message: "License for open-sourced project",
			default: this.license
		});
	}
	async fetchNapiVersion() {
		return select({
			message: "Minimum node-api version (with node version requirement)",
			loop: false,
			pageSize: 10,
			choices: Array.from({ length: 8 }, (_, i) => ({
				name: `napi${i + 1} (${napiEngineRequirement(i + 1)})`,
				value: i + 1
			})),
			default: this.minNodeApiVersion - 1
		});
	}
	async fetchTargets() {
		if (this.enableAllTargets) return AVAILABLE_TARGETS.concat();
		return await checkbox({
			loop: false,
			message: "Choose target(s) your crate will be compiled to",
			choices: AVAILABLE_TARGETS.map((target) => ({
				name: target,
				value: target,
				checked: DEFAULT_TARGETS.includes(target)
			}))
		});
	}
	async fetchTypeDef() {
		return await confirm({
			message: "Enable type definition auto-generation",
			default: this.enableTypeDef
		});
	}
	async fetchGithubActions() {
		return await confirm({
			message: "Enable Github Actions CI",
			default: this.enableGithubActions
		});
	}
};
async function inquirerProjectPath() {
	return input({ message: "Target path to create the project, relative to cwd." }).then((path$1) => {
		if (!path$1) return inquirerProjectPath();
		return path$1;
	});
}

//#endregion
//#region src/commands/pre-publish.ts
var PrePublishCommand = class extends BasePrePublishCommand {
	async execute() {
		await prePublish(this.getOptions());
	}
};

//#endregion
//#region src/commands/rename.ts
var RenameCommand = class extends BaseRenameCommand {
	async execute() {
		const options = this.getOptions();
		if (!options.name) options.name = await input({
			message: `Enter the new package name in the package.json`,
			required: true
		});
		if (!options.binaryName) options.binaryName = await input({
			message: `Enter the new binary name`,
			required: true
		});
		await renameProject(options);
	}
};

//#endregion
//#region src/commands/universalize.ts
var UniversalizeCommand = class extends BaseUniversalizeCommand {
	async execute() {
		await universalizeBinaries(this.getOptions());
	}
};

//#endregion
//#region src/commands/version.ts
var VersionCommand = class extends BaseVersionCommand {
	async execute() {
		await version(this.getOptions());
	}
};

//#endregion
//#region src/index.ts
const cli = new Cli({
	binaryName: "napi",
	binaryVersion: CLI_VERSION
});
cli.register(NewCommand);
cli.register(BuildCommand);
cli.register(CreateNpmDirsCommand);
cli.register(ArtifactsCommand);
cli.register(UniversalizeCommand);
cli.register(RenameCommand);
cli.register(PrePublishCommand);
cli.register(VersionCommand);
cli.register(HelpCommand);
/**
*
* @usage
*
* ```ts
* const cli = new NapiCli()
*
* cli.build({
*   cwd: '/path/to/your/project',
* })
* ```
*/
var NapiCli = class {
	artifacts = collectArtifacts;
	new = newProject;
	build = buildProject;
	createNpmDirs = createNpmDirs;
	prePublish = prePublish;
	rename = renameProject;
	universalize = universalizeBinaries;
	version = version;
};
function createBuildCommand(args) {
	return cli.process(["build", ...args]);
}
function createArtifactsCommand(args) {
	return cli.process(["artifacts", ...args]);
}
function createCreateNpmDirsCommand(args) {
	return cli.process(["create-npm-dirs", ...args]);
}
function createPrePublishCommand(args) {
	return cli.process(["pre-publish", ...args]);
}
function createRenameCommand(args) {
	return cli.process(["rename", ...args]);
}
function createUniversalizeCommand(args) {
	return cli.process(["universalize", ...args]);
}
function createVersionCommand(args) {
	return cli.process(["version", ...args]);
}
function createNewCommand(args) {
	return cli.process(["new", ...args]);
}

//#endregion
export { NapiCli, cli, createArtifactsCommand, createBuildCommand, createCreateNpmDirsCommand, createNewCommand, createPrePublishCommand, createRenameCommand, createUniversalizeCommand, createVersionCommand, generateTypeDef, parseTriple, readNapiConfig, writeJsBinding };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJuYW1lcyI6WyJkZWJ1ZyIsInBhdGgiLCJwaWNrIiwicGtnSnNvbi52ZXJzaW9uIiwiVEFSR0VUX0xJTktFUjogUmVjb3JkPHN0cmluZywgc3RyaW5nPiIsIkNwdVRvTm9kZUFyY2g6IFJlY29yZDxzdHJpbmcsIE5vZGVKU0FyY2g+IiwiU3lzVG9Ob2RlUGxhdGZvcm06IFJlY29yZDxzdHJpbmcsIFBsYXRmb3JtPiIsIlVuaUFyY2hzQnlQbGF0Zm9ybTogUGFydGlhbDxSZWNvcmQ8UGxhdGZvcm0sIE5vZGVKU0FyY2hbXT4+IiwiY3B1OiBzdHJpbmciLCJzeXM6IHN0cmluZyIsImFiaTogc3RyaW5nIHwgbnVsbCIsInJlcXVpcmVtZW50czogc3RyaW5nW10iLCJwYXRoIiwic2VwYXJhdGVkQ29uZmlnOiBVc2VyTmFwaUNvbmZpZyB8IHVuZGVmaW5lZCIsIm5hcGlDb25maWc6IE5hcGlDb25maWciLCJ0YXJnZXRzOiBzdHJpbmdbXSIsImV4cG9ydHM6IHN0cmluZ1tdIiwiZGVidWciLCJkaXIiLCJmcyIsImZzIiwiZGVidWciLCJvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMiLCJtZXRhZGF0YTogQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSIsImNyYXRlOiBDcmF0ZSIsImNvbmZpZzogTmFwaUNvbmZpZyIsImFsaWFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IiwidmVyc2lvbiIsImRlc3QiLCJkaXIiLCJ2YWx1ZSIsImV4cG9ydHM6IHN0cmluZ1tdIiwiZGVidWciLCJta2RpckFzeW5jIiwiZGlyIiwicmF3TWtkaXJBc3luYyIsIndyaXRlRmlsZUFzeW5jIiwicmF3V3JpdGVGaWxlQXN5bmMiLCJzY29wZWRQYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHMiLCJwaWNrIiwicGFyc2UiLCIjcHJpbnRPYmplY3QiLCIjZm9ybWF0IiwiI2lzU2ltcGx5U2VyaWFsaXphYmxlIiwidmFsdWUiLCIjZGF0ZURlY2xhcmF0aW9uIiwiI3N0ckRlY2xhcmF0aW9uIiwiI251bWJlckRlY2xhcmF0aW9uIiwiI2Jvb2xEZWNsYXJhdGlvbiIsIiNnZXRUeXBlT2ZBcnJheSIsIiNhcnJheURlY2xhcmF0aW9uIiwiI2hlYWRlckdyb3VwIiwiI3ByaW50QXNJbmxpbmVWYWx1ZSIsIiNkZWNsYXJhdGlvbiIsIiNoZWFkZXIiLCIjYXJyYXlUeXBlQ2FjaGUiLCIjZG9HZXRUeXBlT2ZBcnJheSIsIiNpc1ByaW1pdGl2ZSIsIiNwcmludERhdGUiLCJ2YWx1ZSIsIiNzb3VyY2UiLCIjcG9zaXRpb24iLCIjd2hpdGVzcGFjZSIsInZhbHVlIiwidGFibGUiLCJwYXJzZSIsImpvaW4iLCJtZXJnZSIsImZsb2F0IiwicGFpciIsInBhcnNlIiwiaW5wdXQiLCJkaXIiLCJ3YWxrLnVwIiwicGFyc2VUb21sIiwic3RyaW5naWZ5VG9tbCIsImZpbmQuZGlyIiwieWFtbFBhcnNlIiwieWFtbFN0cmluZ2lmeSIsImRlYnVnIiwiZnMiLCJ5YW1sTG9hZCIsImpvYnNUb1JlbW92ZTogc3RyaW5nW10iLCJ5YW1sRHVtcCIsInN0YXQiLCJwYXRoIiwiZGVidWciLCJkZWJ1ZyIsInBhY2thZ2VOYW1lIiwidmVyc2lvbiIsInJlcG8iLCJvd25lciIsIm9jdG9raXQiLCJwa2dJbmZvIiwicGtnSW5mbzogUGFja2FnZUluZm8gfCB1bmRlZmluZWQiLCJkZWJ1ZyIsInVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+IiwiZGVidWciLCJ0YXJnZXRQYXRoOiBzdHJpbmciLCJwYXRoIl0sInNvdXJjZXMiOlsiLi4vc3JjL2RlZi9hcnRpZmFjdHMudHMiLCIuLi9zcmMvdXRpbHMvbG9nLnRzIiwiLi4vcGFja2FnZS5qc29uIiwiLi4vc3JjL3V0aWxzL21pc2MudHMiLCIuLi9zcmMvdXRpbHMvdGFyZ2V0LnRzIiwiLi4vc3JjL3V0aWxzL3ZlcnNpb24udHMiLCIuLi9zcmMvdXRpbHMvbWV0YWRhdGEudHMiLCIuLi9zcmMvdXRpbHMvY29uZmlnLnRzIiwiLi4vc3JjL3V0aWxzL2NhcmdvLnRzIiwiLi4vc3JjL3V0aWxzL3R5cGVnZW4udHMiLCIuLi9zcmMvdXRpbHMvcmVhZC1jb25maWcudHMiLCIuLi9zcmMvYXBpL2FydGlmYWN0cy50cyIsIi4uL3NyYy9hcGkvdGVtcGxhdGVzL2pzLWJpbmRpbmcudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy9sb2FkLXdhc2ktdGVtcGxhdGUudHMiLCIuLi9zcmMvYXBpL3RlbXBsYXRlcy93YXNpLXdvcmtlci10ZW1wbGF0ZS50cyIsIi4uL3NyYy9hcGkvYnVpbGQudHMiLCIuLi9zcmMvZGVmL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9hcGkvY3JlYXRlLW5wbS1kaXJzLnRzIiwiLi4vc3JjL2RlZi9uZXcudHMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQHN0ZC90b21sL3N0cmluZ2lmeS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AanNyL3N0ZF9fY29sbGVjdGlvbnMvX3V0aWxzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0Bqc3Ivc3RkX19jb2xsZWN0aW9ucy9kZWVwX21lcmdlLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9fcGFyc2VyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BzdGQvdG9tbC9wYXJzZS5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbXBhdGhpYy9yZXNvbHZlLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbXBhdGhpYy93YWxrLm1qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9lbXBhdGhpYy9maW5kLm1qcyIsIi4uL3NyYy9kZWYvcmVuYW1lLnRzIiwiLi4vc3JjL2FwaS9yZW5hbWUudHMiLCIuLi9zcmMvYXBpL25ldy50cyIsIi4uL3NyYy9kZWYvcHJlLXB1Ymxpc2gudHMiLCIuLi9zcmMvZGVmL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ZlcnNpb24udHMiLCIuLi9zcmMvYXBpL3ByZS1wdWJsaXNoLnRzIiwiLi4vc3JjL2RlZi91bml2ZXJzYWxpemUudHMiLCIuLi9zcmMvYXBpL3VuaXZlcnNhbGl6ZS50cyIsIi4uL3NyYy9jb21tYW5kcy9hcnRpZmFjdHMudHMiLCIuLi9zcmMvZGVmL2J1aWxkLnRzIiwiLi4vc3JjL2NvbW1hbmRzL2J1aWxkLnRzIiwiLi4vc3JjL2NvbW1hbmRzL2NyZWF0ZS1ucG0tZGlycy50cyIsIi4uL3NyYy9jb21tYW5kcy9oZWxwLnRzIiwiLi4vc3JjL2NvbW1hbmRzL25ldy50cyIsIi4uL3NyYy9jb21tYW5kcy9wcmUtcHVibGlzaC50cyIsIi4uL3NyYy9jb21tYW5kcy9yZW5hbWUudHMiLCIuLi9zcmMvY29tbWFuZHMvdW5pdmVyc2FsaXplLnRzIiwiLi4vc3JjL2NvbW1hbmRzL3ZlcnNpb24udHMiLCIuLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VBcnRpZmFjdHNDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ2FydGlmYWN0cyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0NvcHkgYXJ0aWZhY3RzIGZyb20gR2l0aHViIEFjdGlvbnMgaW50byBucG0gcGFja2FnZXMgYW5kIHJlYWR5IHRvIHB1Ymxpc2gnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG91dHB1dERpciA9IE9wdGlvbi5TdHJpbmcoJy0tb3V0cHV0LWRpciwtbywtZCcsICcuL2FydGlmYWN0cycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmQnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIGJ1aWxkT3V0cHV0RGlyPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1idWlsZC1vdXRwdXQtZGlyJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGJ1aWxkIG91dHB1dCBkaXIsIG9ubHkgbmVlZGVkIHdoZW4gdGFyZ2V0cyBjb250YWlucyBgd2FzbTMyLXdhc2ktKmAnLFxuICB9KVxuXG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBjb25maWdQYXRoOiB0aGlzLmNvbmZpZ1BhdGgsXG4gICAgICBwYWNrYWdlSnNvblBhdGg6IHRoaXMucGFja2FnZUpzb25QYXRoLFxuICAgICAgb3V0cHV0RGlyOiB0aGlzLm91dHB1dERpcixcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICBidWlsZE91dHB1dERpcjogdGhpcy5idWlsZE91dHB1dERpcixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5IGFydGlmYWN0cyBmcm9tIEdpdGh1YiBBY3Rpb25zIGludG8gbnBtIHBhY2thZ2VzIGFuZCByZWFkeSB0byBwdWJsaXNoXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXJ0aWZhY3RzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZFxuICAgKlxuICAgKiBAZGVmYXVsdCAnLi9hcnRpZmFjdHMnXG4gICAqL1xuICBvdXRwdXREaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBidWlsZCBvdXRwdXQgZGlyLCBvbmx5IG5lZWRlZCB3aGVuIHRhcmdldHMgY29udGFpbnMgYHdhc20zMi13YXNpLSpgXG4gICAqL1xuICBidWlsZE91dHB1dERpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0QXJ0aWZhY3RzT3B0aW9ucyhvcHRpb25zOiBBcnRpZmFjdHNPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgb3V0cHV0RGlyOiAnLi9hcnRpZmFjdHMnLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0ICogYXMgY29sb3JzIGZyb20gJ2NvbG9yZXR0ZSdcbmltcG9ydCB7IGNyZWF0ZURlYnVnIH0gZnJvbSAnb2J1ZydcblxuZGVjbGFyZSBtb2R1bGUgJ29idWcnIHtcbiAgaW50ZXJmYWNlIERlYnVnZ2VyIHtcbiAgICBpbmZvOiB0eXBlb2YgY29uc29sZS5lcnJvclxuICAgIHdhcm46IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gICAgZXJyb3I6IHR5cGVvZiBjb25zb2xlLmVycm9yXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlYnVnRmFjdG9yeSA9IChuYW1lc3BhY2U6IHN0cmluZykgPT4ge1xuICBjb25zdCBkZWJ1ZyA9IGNyZWF0ZURlYnVnKGBuYXBpOiR7bmFtZXNwYWNlfWAsIHtcbiAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAvLyBkZWJ1ZygnJWknLCAnVGhpcyBpcyBhbiBpbmZvJylcbiAgICAgIGkodikge1xuICAgICAgICByZXR1cm4gY29sb3JzLmdyZWVuKHYpXG4gICAgICB9LFxuICAgIH0sXG4gIH0pXG5cbiAgZGVidWcuaW5mbyA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKGNvbG9ycy5ibGFjayhjb2xvcnMuYmdHcmVlbignIElORk8gJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy53YXJuID0gKC4uLmFyZ3M6IGFueVtdKSA9PlxuICAgIGNvbnNvbGUuZXJyb3IoY29sb3JzLmJsYWNrKGNvbG9ycy5iZ1llbGxvdygnIFdBUk5JTkcgJykpLCAuLi5hcmdzKVxuICBkZWJ1Zy5lcnJvciA9ICguLi5hcmdzOiBhbnlbXSkgPT5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgY29sb3JzLndoaXRlKGNvbG9ycy5iZ1JlZCgnIEVSUk9SICcpKSxcbiAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgIGFyZyBpbnN0YW5jZW9mIEVycm9yID8gKGFyZy5zdGFjayA/PyBhcmcubWVzc2FnZSkgOiBhcmcsXG4gICAgICApLFxuICAgIClcblxuICByZXR1cm4gZGVidWdcbn1cbmV4cG9ydCBjb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgndXRpbHMnKVxuIiwie1xuICBcIm5hbWVcIjogXCJAbmFwaS1ycy9jbGlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMy41LjBcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkNsaSB0b29scyBmb3IgbmFwaS1yc1wiLFxuICBcImF1dGhvclwiOiBcIkxvbmdZaW5hbiA8bHlud2VrbG1AZ21haWwuY29tPlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1yc1wiLFxuICBcImxpY2Vuc2VcIjogXCJNSVRcIixcbiAgXCJ0eXBlXCI6IFwibW9kdWxlXCIsXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0gMTZcIlxuICB9LFxuICBcImJpblwiOiB7XG4gICAgXCJuYXBpXCI6IFwiLi9kaXN0L2NsaS5qc1wiLFxuICAgIFwibmFwaS1yYXdcIjogXCIuL2NsaS5tanNcIlxuICB9LFxuICBcIm1haW5cIjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIFwibW9kdWxlXCI6IFwiLi9kaXN0L2luZGV4LmpzXCIsXG4gIFwidHlwZXNcIjogXCIuL2Rpc3QvaW5kZXguZC50c1wiLFxuICBcImV4cG9ydHNcIjoge1xuICAgIFwiLlwiOiB7XG4gICAgICBcImltcG9ydFwiOiBcIi4vZGlzdC9pbmRleC5qc1wiLFxuICAgICAgXCJyZXF1aXJlXCI6IFwiLi9kaXN0L2luZGV4LmNqc1wiXG4gICAgfSxcbiAgICBcIi4vcGFja2FnZS5qc29uXCI6IFwiLi9wYWNrYWdlLmpzb25cIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcImRpc3RcIixcbiAgICBcInNyY1wiLFxuICAgIFwiIV9fdGVzdHNfX1wiXG4gIF0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2xpXCIsXG4gICAgXCJydXN0XCIsXG4gICAgXCJuYXBpXCIsXG4gICAgXCJuLWFwaVwiLFxuICAgIFwibm9kZS1hcGlcIixcbiAgICBcIm5vZGUtYWRkb25cIixcbiAgICBcIm5lb25cIlxuICBdLFxuICBcIm1haW50YWluZXJzXCI6IFtcbiAgICB7XG4gICAgICBcIm5hbWVcIjogXCJMb25nWWluYW5cIixcbiAgICAgIFwiZW1haWxcIjogXCJseW53ZWtsbUBnbWFpbC5jb21cIixcbiAgICAgIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vQnJvb29vb29rbHluXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcImZvcmVoYWxvXCIsXG4gICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ZvcmVoYWxvXCJcbiAgICB9XG4gIF0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL25hcGktcnMvbmFwaS1ycy5naXRcIlxuICB9LFxuICBcInB1Ymxpc2hDb25maWdcIjoge1xuICAgIFwicmVnaXN0cnlcIjogXCJodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy9cIixcbiAgICBcImFjY2Vzc1wiOiBcInB1YmxpY1wiXG4gIH0sXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9uYXBpLXJzL2lzc3Vlc1wiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBpbnF1aXJlci9wcm9tcHRzXCI6IFwiXjguMC4wXCIsXG4gICAgXCJAbmFwaS1ycy9jcm9zcy10b29sY2hhaW5cIjogXCJeMS4wLjNcIixcbiAgICBcIkBuYXBpLXJzL3dhc20tdG9vbHNcIjogXCJeMS4wLjFcIixcbiAgICBcIkBvY3Rva2l0L3Jlc3RcIjogXCJeMjIuMC4xXCIsXG4gICAgXCJjbGlwYW5pb25cIjogXCJeNC4wLjAtcmMuNFwiLFxuICAgIFwiY29sb3JldHRlXCI6IFwiXjIuMC4yMFwiLFxuICAgIFwiZW1uYXBpXCI6IFwiXjEuNy4xXCIsXG4gICAgXCJlcy10b29sa2l0XCI6IFwiXjEuNDEuMFwiLFxuICAgIFwianMteWFtbFwiOiBcIl40LjEuMFwiLFxuICAgIFwib2J1Z1wiOiBcIl4yLjAuMFwiLFxuICAgIFwic2VtdmVyXCI6IFwiXjcuNy4zXCIsXG4gICAgXCJ0eXBhbmlvblwiOiBcIl4zLjE0LjBcIlxuICB9LFxuICBcImRldkRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJAZW1uYXBpL3J1bnRpbWVcIjogXCJeMS43LjFcIixcbiAgICBcIkBveGMtbm9kZS9jb3JlXCI6IFwiXjAuMC4zNVwiLFxuICAgIFwiQHN0ZC90b21sXCI6IFwibnBtOkBqc3Ivc3RkX190b21sQF4xLjAuMTFcIixcbiAgICBcIkB0eXBlcy9pbnF1aXJlclwiOiBcIl45LjAuOVwiLFxuICAgIFwiQHR5cGVzL2pzLXlhbWxcIjogXCJeNC4wLjlcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjI0LjEwLjBcIixcbiAgICBcIkB0eXBlcy9zZW12ZXJcIjogXCJeNy43LjFcIixcbiAgICBcImF2YVwiOiBcIl42LjQuMVwiLFxuICAgIFwiZW1wYXRoaWNcIjogXCJeMi4wLjBcIixcbiAgICBcImVudi1wYXRoc1wiOiBcIl4zLjAuMFwiLFxuICAgIFwicHJldHRpZXJcIjogXCJeMy42LjJcIixcbiAgICBcInRzZG93blwiOiBcIl4wLjE2LjFcIixcbiAgICBcInRzbGliXCI6IFwiXjIuOC4xXCIsXG4gICAgXCJ0eXBlc2NyaXB0XCI6IFwiXjUuOS4zXCJcbiAgfSxcbiAgXCJwZWVyRGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBlbW5hcGkvcnVudGltZVwiOiBcIl4xLjcuMVwiXG4gIH0sXG4gIFwicGVlckRlcGVuZGVuY2llc01ldGFcIjoge1xuICAgIFwiQGVtbmFwaS9ydW50aW1lXCI6IHtcbiAgICAgIFwib3B0aW9uYWxcIjogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgXCJmdW5kaW5nXCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRodWJcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zcG9uc29ycy9Ccm9vb29vb2tseW5cIlxuICB9LFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwiY29kZWdlblwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi9jb2RlZ2VuL2luZGV4LnRzXCIsXG4gICAgXCJidWlsZFwiOiBcInRzZG93blwiLFxuICAgIFwidGVzdFwiOiBcIm5vZGUgLS1pbXBvcnQgQG94Yy1ub2RlL2NvcmUvcmVnaXN0ZXIgLi4vbm9kZV9tb2R1bGVzL2F2YS9lbnRyeXBvaW50cy9jbGkubWpzXCJcbiAgfSxcbiAgXCJhdmFcIjoge1xuICAgIFwiZXh0ZW5zaW9uc1wiOiB7XG4gICAgICBcInRzXCI6IFwibW9kdWxlXCJcbiAgICB9LFxuICAgIFwidGltZW91dFwiOiBcIjJtXCIsXG4gICAgXCJ3b3JrZXJUaHJlYWRzXCI6IGZhbHNlLFxuICAgIFwiZmlsZXNcIjogW1xuICAgICAgXCIqKi9fX3Rlc3RzX18vKiovKi5zcGVjLnRzXCIsXG4gICAgICBcImUyZS8qKi8qLnNwZWMudHNcIlxuICAgIF1cbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgcmVhZEZpbGUsXG4gIHdyaXRlRmlsZSxcbiAgdW5saW5rLFxuICBjb3B5RmlsZSxcbiAgbWtkaXIsXG4gIHN0YXQsXG4gIHJlYWRkaXIsXG4gIGFjY2Vzcyxcbn0gZnJvbSAnbm9kZTpmcy9wcm9taXNlcydcblxuaW1wb3J0IHBrZ0pzb24gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJyB3aXRoIHsgdHlwZTogJ2pzb24nIH1cbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi9sb2cuanMnXG5cbmV4cG9ydCBjb25zdCByZWFkRmlsZUFzeW5jID0gcmVhZEZpbGVcbmV4cG9ydCBjb25zdCB3cml0ZUZpbGVBc3luYyA9IHdyaXRlRmlsZVxuZXhwb3J0IGNvbnN0IHVubGlua0FzeW5jID0gdW5saW5rXG5leHBvcnQgY29uc3QgY29weUZpbGVBc3luYyA9IGNvcHlGaWxlXG5leHBvcnQgY29uc3QgbWtkaXJBc3luYyA9IG1rZGlyXG5leHBvcnQgY29uc3Qgc3RhdEFzeW5jID0gc3RhdFxuZXhwb3J0IGNvbnN0IHJlYWRkaXJBc3luYyA9IHJlYWRkaXJcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVFeGlzdHMocGF0aDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHJldHVybiBhY2Nlc3MocGF0aCkudGhlbihcbiAgICAoKSA9PiB0cnVlLFxuICAgICgpID0+IGZhbHNlLFxuICApXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkaXJFeGlzdHNBc3luYyhwYXRoOiBzdHJpbmcpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0cyA9IGF3YWl0IHN0YXRBc3luYyhwYXRoKVxuICAgIHJldHVybiBzdGF0cy5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwaWNrPE8sIEsgZXh0ZW5kcyBrZXlvZiBPPihvOiBPLCAuLi5rZXlzOiBLW10pOiBQaWNrPE8sIEs+IHtcbiAgcmV0dXJuIGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gb1trZXldXG4gICAgcmV0dXJuIGFjY1xuICB9LCB7fSBhcyBPKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFja2FnZUpzb24oXG4gIHBhdGg6IHN0cmluZyxcbiAgcGFydGlhbDogUmVjb3JkPHN0cmluZywgYW55Pixcbikge1xuICBjb25zdCBleGlzdHMgPSBhd2FpdCBmaWxlRXhpc3RzKHBhdGgpXG4gIGlmICghZXhpc3RzKSB7XG4gICAgZGVidWcoYEZpbGUgbm90IGV4aXN0cyAke3BhdGh9YClcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBvbGQgPSBKU09OLnBhcnNlKGF3YWl0IHJlYWRGaWxlQXN5bmMocGF0aCwgJ3V0ZjgnKSlcbiAgYXdhaXQgd3JpdGVGaWxlQXN5bmMocGF0aCwgSlNPTi5zdHJpbmdpZnkoeyAuLi5vbGQsIC4uLnBhcnRpYWwgfSwgbnVsbCwgMikpXG59XG5cbmV4cG9ydCBjb25zdCBDTElfVkVSU0lPTiA9IHBrZ0pzb24udmVyc2lvblxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmV4cG9ydCB0eXBlIFBsYXRmb3JtID0gTm9kZUpTLlBsYXRmb3JtIHwgJ3dhc20nIHwgJ3dhc2knIHwgJ29wZW5oYXJtb255J1xuXG5leHBvcnQgY29uc3QgVU5JVkVSU0FMX1RBUkdFVFMgPSB7XG4gICd1bml2ZXJzYWwtYXBwbGUtZGFyd2luJzogWydhYXJjaDY0LWFwcGxlLWRhcndpbicsICd4ODZfNjQtYXBwbGUtZGFyd2luJ10sXG59IGFzIGNvbnN0XG5cbmNvbnN0IFNVQl9TWVNURU1TID0gbmV3IFNldChbJ2FuZHJvaWQnLCAnb2hvcyddKVxuXG5leHBvcnQgY29uc3QgQVZBSUxBQkxFX1RBUkdFVFMgPSBbXG4gICdhYXJjaDY0LWFwcGxlLWRhcndpbicsXG4gICdhYXJjaDY0LWxpbnV4LWFuZHJvaWQnLFxuICAnYWFyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICdhYXJjaDY0LXVua25vd24tbGludXgtb2hvcycsXG4gICdhYXJjaDY0LXBjLXdpbmRvd3MtbXN2YycsXG4gICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LXBjLXdpbmRvd3MtZ251JyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LWdudScsXG4gICd4ODZfNjQtdW5rbm93bi1saW51eC1tdXNsJyxcbiAgJ3g4Nl82NC11bmtub3duLWxpbnV4LW9ob3MnLFxuICAneDg2XzY0LXVua25vd24tZnJlZWJzZCcsXG4gICdpNjg2LXBjLXdpbmRvd3MtbXN2YycsXG4gICdhcm12Ny11bmtub3duLWxpbnV4LWdudWVhYmloZicsXG4gICdhcm12Ny11bmtub3duLWxpbnV4LW11c2xlYWJpaGYnLFxuICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICAndW5pdmVyc2FsLWFwcGxlLWRhcndpbicsXG4gICdsb29uZ2FyY2g2NC11bmtub3duLWxpbnV4LWdudScsXG4gICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAncG93ZXJwYzY0bGUtdW5rbm93bi1saW51eC1nbnUnLFxuICAnczM5MHgtdW5rbm93bi1saW51eC1nbnUnLFxuICAnd2FzbTMyLXdhc2ktcHJldmlldzEtdGhyZWFkcycsXG4gICd3YXNtMzItd2FzaXAxLXRocmVhZHMnLFxuXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBUYXJnZXRUcmlwbGUgPSAodHlwZW9mIEFWQUlMQUJMRV9UQVJHRVRTKVtudW1iZXJdXG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1RBUkdFVFMgPSBbXG4gICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgJ2FhcmNoNjQtYXBwbGUtZGFyd2luJyxcbiAgJ3g4Nl82NC1wYy13aW5kb3dzLW1zdmMnLFxuICAneDg2XzY0LXVua25vd24tbGludXgtZ251Jyxcbl0gYXMgY29uc3RcblxuZXhwb3J0IGNvbnN0IFRBUkdFVF9MSU5LRVI6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCc6ICdhYXJjaDY0LWxpbnV4LW11c2wtZ2NjJyxcbiAgLy8gVE9ETzogU3dpdGNoIHRvIGxvb25nYXJjaDY0LWxpbnV4LWdudS1nY2Mgd2hlbiBhdmFpbGFibGVcbiAgJ2xvb25nYXJjaDY0LXVua25vd24tbGludXgtZ251JzogJ2xvb25nYXJjaDY0LWxpbnV4LWdudS1nY2MtMTMnLFxuICAncmlzY3Y2NGdjLXVua25vd24tbGludXgtZ251JzogJ3Jpc2N2NjQtbGludXgtZ251LWdjYycsXG4gICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudSc6ICdwb3dlcnBjNjRsZS1saW51eC1nbnUtZ2NjJyxcbiAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWxpbnV4LWdudS1nY2MnLFxufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzX3Byb2Nlc3NfYXJjaFxudHlwZSBOb2RlSlNBcmNoID1cbiAgfCAnYXJtJ1xuICB8ICdhcm02NCdcbiAgfCAnaWEzMidcbiAgfCAnbG9vbmc2NCdcbiAgfCAnbWlwcydcbiAgfCAnbWlwc2VsJ1xuICB8ICdwcGMnXG4gIHwgJ3BwYzY0J1xuICB8ICdyaXNjdjY0J1xuICB8ICdzMzkwJ1xuICB8ICdzMzkweCdcbiAgfCAneDMyJ1xuICB8ICd4NjQnXG4gIHwgJ3VuaXZlcnNhbCdcbiAgfCAnd2FzbTMyJ1xuXG5jb25zdCBDcHVUb05vZGVBcmNoOiBSZWNvcmQ8c3RyaW5nLCBOb2RlSlNBcmNoPiA9IHtcbiAgeDg2XzY0OiAneDY0JyxcbiAgYWFyY2g2NDogJ2FybTY0JyxcbiAgaTY4NjogJ2lhMzInLFxuICBhcm12NzogJ2FybScsXG4gIGxvb25nYXJjaDY0OiAnbG9vbmc2NCcsXG4gIHJpc2N2NjRnYzogJ3Jpc2N2NjQnLFxuICBwb3dlcnBjNjRsZTogJ3BwYzY0Jyxcbn1cblxuZXhwb3J0IGNvbnN0IE5vZGVBcmNoVG9DcHU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIHg2NDogJ3g4Nl82NCcsXG4gIGFybTY0OiAnYWFyY2g2NCcsXG4gIGlhMzI6ICdpNjg2JyxcbiAgYXJtOiAnYXJtdjcnLFxuICBsb29uZzY0OiAnbG9vbmdhcmNoNjQnLFxuICByaXNjdjY0OiAncmlzY3Y2NGdjJyxcbiAgcHBjNjQ6ICdwb3dlcnBjNjRsZScsXG59XG5cbmNvbnN0IFN5c1RvTm9kZVBsYXRmb3JtOiBSZWNvcmQ8c3RyaW5nLCBQbGF0Zm9ybT4gPSB7XG4gIGxpbnV4OiAnbGludXgnLFxuICBmcmVlYnNkOiAnZnJlZWJzZCcsXG4gIGRhcndpbjogJ2RhcndpbicsXG4gIHdpbmRvd3M6ICd3aW4zMicsXG4gIG9ob3M6ICdvcGVuaGFybW9ueScsXG59XG5cbmV4cG9ydCBjb25zdCBVbmlBcmNoc0J5UGxhdGZvcm06IFBhcnRpYWw8UmVjb3JkPFBsYXRmb3JtLCBOb2RlSlNBcmNoW10+PiA9IHtcbiAgZGFyd2luOiBbJ3g2NCcsICdhcm02NCddLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhcmdldCB7XG4gIHRyaXBsZTogc3RyaW5nXG4gIHBsYXRmb3JtQXJjaEFCSTogc3RyaW5nXG4gIHBsYXRmb3JtOiBQbGF0Zm9ybVxuICBhcmNoOiBOb2RlSlNBcmNoXG4gIGFiaTogc3RyaW5nIHwgbnVsbFxufVxuXG4vKipcbiAqIEEgdHJpcGxlIGlzIGEgc3BlY2lmaWMgZm9ybWF0IGZvciBzcGVjaWZ5aW5nIGEgdGFyZ2V0IGFyY2hpdGVjdHVyZS5cbiAqIFRyaXBsZXMgbWF5IGJlIHJlZmVycmVkIHRvIGFzIGEgdGFyZ2V0IHRyaXBsZSB3aGljaCBpcyB0aGUgYXJjaGl0ZWN0dXJlIGZvciB0aGUgYXJ0aWZhY3QgcHJvZHVjZWQsIGFuZCB0aGUgaG9zdCB0cmlwbGUgd2hpY2ggaXMgdGhlIGFyY2hpdGVjdHVyZSB0aGF0IHRoZSBjb21waWxlciBpcyBydW5uaW5nIG9uLlxuICogVGhlIGdlbmVyYWwgZm9ybWF0IG9mIHRoZSB0cmlwbGUgaXMgYDxhcmNoPjxzdWI+LTx2ZW5kb3I+LTxzeXM+LTxhYmk+YCB3aGVyZTpcbiAqICAgLSBgYXJjaGAgPSBUaGUgYmFzZSBDUFUgYXJjaGl0ZWN0dXJlLCBmb3IgZXhhbXBsZSBgeDg2XzY0YCwgYGk2ODZgLCBgYXJtYCwgYHRodW1iYCwgYG1pcHNgLCBldGMuXG4gKiAgIC0gYHN1YmAgPSBUaGUgQ1BVIHN1Yi1hcmNoaXRlY3R1cmUsIGZvciBleGFtcGxlIGBhcm1gIGhhcyBgdjdgLCBgdjdzYCwgYHY1dGVgLCBldGMuXG4gKiAgIC0gYHZlbmRvcmAgPSBUaGUgdmVuZG9yLCBmb3IgZXhhbXBsZSBgdW5rbm93bmAsIGBhcHBsZWAsIGBwY2AsIGBudmlkaWFgLCBldGMuXG4gKiAgIC0gYHN5c2AgPSBUaGUgc3lzdGVtIG5hbWUsIGZvciBleGFtcGxlIGBsaW51eGAsIGB3aW5kb3dzYCwgYGRhcndpbmAsIGV0Yy4gbm9uZSBpcyB0eXBpY2FsbHkgdXNlZCBmb3IgYmFyZS1tZXRhbCB3aXRob3V0IGFuIE9TLlxuICogICAtIGBhYmlgID0gVGhlIEFCSSwgZm9yIGV4YW1wbGUgYGdudWAsIGBhbmRyb2lkYCwgYGVhYmlgLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyaXBsZShyYXdUcmlwbGU6IHN0cmluZyk6IFRhcmdldCB7XG4gIGlmIChcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaScgfHxcbiAgICByYXdUcmlwbGUgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJyB8fFxuICAgIHJhd1RyaXBsZS5zdGFydHNXaXRoKCd3YXNtMzItd2FzaXAnKVxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgICBwbGF0Zm9ybUFyY2hBQkk6ICd3YXNtMzItd2FzaScsXG4gICAgICBwbGF0Zm9ybTogJ3dhc2knLFxuICAgICAgYXJjaDogJ3dhc20zMicsXG4gICAgICBhYmk6ICd3YXNpJyxcbiAgICB9XG4gIH1cbiAgY29uc3QgdHJpcGxlID0gcmF3VHJpcGxlLmVuZHNXaXRoKCdlYWJpJylcbiAgICA/IGAke3Jhd1RyaXBsZS5zbGljZSgwLCAtNCl9LWVhYmlgXG4gICAgOiByYXdUcmlwbGVcbiAgY29uc3QgdHJpcGxlcyA9IHRyaXBsZS5zcGxpdCgnLScpXG4gIGxldCBjcHU6IHN0cmluZ1xuICBsZXQgc3lzOiBzdHJpbmdcbiAgbGV0IGFiaTogc3RyaW5nIHwgbnVsbCA9IG51bGxcbiAgaWYgKHRyaXBsZXMubGVuZ3RoID09PSAyKSB7XG4gICAgLy8gYWFyY2g2NC1mdWNoc2lhXG4gICAgLy8gXiBjcHUgICBeIHN5c1xuICAgIDtbY3B1LCBzeXNdID0gdHJpcGxlc1xuICB9IGVsc2Uge1xuICAgIC8vIGFhcmNoNjQtdW5rbm93bi1saW51eC1tdXNsXG4gICAgLy8gXiBjcHUgICBedmVuZG9yIF4gc3lzIF4gYWJpXG4gICAgLy8gYWFyY2g2NC1hcHBsZS1kYXJ3aW5cbiAgICAvLyBeIGNwdSAgICAgICAgIF4gc3lzICAoYWJpIGlzIE5vbmUpXG4gICAgO1tjcHUsICwgc3lzLCBhYmkgPSBudWxsXSA9IHRyaXBsZXNcbiAgfVxuXG4gIGlmIChhYmkgJiYgU1VCX1NZU1RFTVMuaGFzKGFiaSkpIHtcbiAgICBzeXMgPSBhYmlcbiAgICBhYmkgPSBudWxsXG4gIH1cbiAgY29uc3QgcGxhdGZvcm0gPSBTeXNUb05vZGVQbGF0Zm9ybVtzeXNdID8/IChzeXMgYXMgUGxhdGZvcm0pXG4gIGNvbnN0IGFyY2ggPSBDcHVUb05vZGVBcmNoW2NwdV0gPz8gKGNwdSBhcyBOb2RlSlNBcmNoKVxuXG4gIHJldHVybiB7XG4gICAgdHJpcGxlOiByYXdUcmlwbGUsXG4gICAgcGxhdGZvcm1BcmNoQUJJOiBhYmkgPyBgJHtwbGF0Zm9ybX0tJHthcmNofS0ke2FiaX1gIDogYCR7cGxhdGZvcm19LSR7YXJjaH1gLFxuICAgIHBsYXRmb3JtLFxuICAgIGFyY2gsXG4gICAgYWJpLFxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTeXN0ZW1EZWZhdWx0VGFyZ2V0KCk6IFRhcmdldCB7XG4gIGNvbnN0IGhvc3QgPSBleGVjU3luYyhgcnVzdGMgLXZWYCwge1xuICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gIH0pXG4gICAgLnRvU3RyaW5nKCd1dGY4JylcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLmZpbmQoKGxpbmUpID0+IGxpbmUuc3RhcnRzV2l0aCgnaG9zdDogJykpXG4gIGNvbnN0IHRyaXBsZSA9IGhvc3Q/LnNsaWNlKCdob3N0OiAnLmxlbmd0aClcbiAgaWYgKCF0cmlwbGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4gbm90IHBhcnNlIHRhcmdldCB0cmlwbGUgZnJvbSBob3N0YClcbiAgfVxuICByZXR1cm4gcGFyc2VUcmlwbGUodHJpcGxlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0TGlua2VyKHRhcmdldDogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIFRBUkdFVF9MSU5LRVJbdGFyZ2V0XVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG9FbnZWYXIodGFyZ2V0OiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdGFyZ2V0LnJlcGxhY2UoLy0vZywgJ18nKS50b1VwcGVyQ2FzZSgpXG59XG4iLCJleHBvcnQgZW51bSBOYXBpVmVyc2lvbiB7XG4gIE5hcGkxID0gMSxcbiAgTmFwaTIsXG4gIE5hcGkzLFxuICBOYXBpNCxcbiAgTmFwaTUsXG4gIE5hcGk2LFxuICBOYXBpNyxcbiAgTmFwaTgsXG4gIE5hcGk5LFxufVxuXG4vLy8gYmVjYXVzZSBub2RlIHN1cHBvcnQgbmV3IG5hcGkgdmVyc2lvbiBpbiBzb21lIG1pbm9yIHZlcnNpb24gdXBkYXRlcywgc28gd2UgbWlnaHQgbWVldCBzdWNoIHNpdHVhdGlvbjpcbi8vLyBgbm9kZSB2MTAuMjAuMGAgc3VwcG9ydHMgYG5hcGk1YCBhbmQgYG5hcGk2YCwgYnV0IGBub2RlIHYxMi4wLjBgIG9ubHkgc3VwcG9ydCBgbmFwaTRgLFxuLy8vIGJ5IHdoaWNoLCB3ZSBjYW4gbm90IHRlbGwgZGlyZWN0bHkgbmFwaSB2ZXJzaW9uIHN1cHBvcnRsZXNzIGZyb20gbm9kZSB2ZXJzaW9uIGRpcmVjdGx5LlxuY29uc3QgTkFQSV9WRVJTSU9OX01BVFJJWCA9IG5ldyBNYXA8TmFwaVZlcnNpb24sIHN0cmluZz4oW1xuICBbTmFwaVZlcnNpb24uTmFwaTEsICc4LjYuMCB8IDkuMC4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMiwgJzguMTAuMCB8IDkuMy4wIHwgMTAuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpMywgJzYuMTQuMiB8IDguMTEuMiB8IDkuMTEuMCB8IDEwLjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTQsICcxMC4xNi4wIHwgMTEuOC4wIHwgMTIuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNSwgJzEwLjE3LjAgfCAxMi4xMS4wIHwgMTMuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNiwgJzEwLjIwLjAgfCAxMi4xNy4wIHwgMTQuMC4wJ10sXG4gIFtOYXBpVmVyc2lvbi5OYXBpNywgJzEwLjIzLjAgfCAxMi4xOS4wIHwgMTQuMTIuMCB8IDE1LjAuMCddLFxuICBbTmFwaVZlcnNpb24uTmFwaTgsICcxMi4yMi4wIHwgMTQuMTcuMCB8IDE1LjEyLjAgfCAxNi4wLjAnXSxcbiAgW05hcGlWZXJzaW9uLk5hcGk5LCAnMTguMTcuMCB8IDIwLjMuMCB8IDIxLjEuMCddLFxuXSlcblxuaW50ZXJmYWNlIE5vZGVWZXJzaW9uIHtcbiAgbWFqb3I6IG51bWJlclxuICBtaW5vcjogbnVtYmVyXG4gIHBhdGNoOiBudW1iZXJcbn1cblxuZnVuY3Rpb24gcGFyc2VOb2RlVmVyc2lvbih2OiBzdHJpbmcpOiBOb2RlVmVyc2lvbiB7XG4gIGNvbnN0IG1hdGNoZXMgPSB2Lm1hdGNoKC92PyhbMC05XSspXFwuKFswLTldKylcXC4oWzAtOV0rKS9pKVxuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlIHZlcnNpb24gbnVtYmVyOiAnICsgdilcbiAgfVxuXG4gIGNvbnN0IFssIG1ham9yLCBtaW5vciwgcGF0Y2hdID0gbWF0Y2hlc1xuXG4gIHJldHVybiB7XG4gICAgbWFqb3I6IHBhcnNlSW50KG1ham9yKSxcbiAgICBtaW5vcjogcGFyc2VJbnQobWlub3IpLFxuICAgIHBhdGNoOiBwYXJzZUludChwYXRjaCksXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogTm9kZVZlcnNpb25bXSB7XG4gIGNvbnN0IHJlcXVpcmVtZW50ID0gTkFQSV9WRVJTSU9OX01BVFJJWC5nZXQobmFwaVZlcnNpb24pXG5cbiAgaWYgKCFyZXF1aXJlbWVudCkge1xuICAgIHJldHVybiBbcGFyc2VOb2RlVmVyc2lvbignMTAuMC4wJyldXG4gIH1cblxuICByZXR1cm4gcmVxdWlyZW1lbnQuc3BsaXQoJ3wnKS5tYXAocGFyc2VOb2RlVmVyc2lvbilcbn1cblxuZnVuY3Rpb24gdG9FbmdpbmVSZXF1aXJlbWVudCh2ZXJzaW9uczogTm9kZVZlcnNpb25bXSk6IHN0cmluZyB7XG4gIGNvbnN0IHJlcXVpcmVtZW50czogc3RyaW5nW10gPSBbXVxuICB2ZXJzaW9ucy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgbGV0IHJlcSA9ICcnXG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGxhc3RWZXJzaW9uID0gdmVyc2lvbnNbaSAtIDFdXG4gICAgICByZXEgKz0gYDwgJHtsYXN0VmVyc2lvbi5tYWpvciArIDF9YFxuICAgIH1cblxuICAgIHJlcSArPSBgJHtpID09PSAwID8gJycgOiAnIHx8ICd9Pj0gJHt2Lm1ham9yfS4ke3YubWlub3J9LiR7di5wYXRjaH1gXG4gICAgcmVxdWlyZW1lbnRzLnB1c2gocmVxKVxuICB9KVxuXG4gIHJldHVybiByZXF1aXJlbWVudHMuam9pbignICcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBuYXBpRW5naW5lUmVxdWlyZW1lbnQobmFwaVZlcnNpb246IE5hcGlWZXJzaW9uKTogc3RyaW5nIHtcbiAgcmV0dXJuIHRvRW5naW5lUmVxdWlyZW1lbnQocmVxdWlyZWROb2RlVmVyc2lvbnMobmFwaVZlcnNpb24pKVxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgZnMgZnJvbSAnbm9kZTpmcydcblxuZXhwb3J0IHR5cGUgQ3JhdGVUYXJnZXRLaW5kID1cbiAgfCAnYmluJ1xuICB8ICdleGFtcGxlJ1xuICB8ICd0ZXN0J1xuICB8ICdiZW5jaCdcbiAgfCAnbGliJ1xuICB8ICdybGliJ1xuICB8ICdjZHlsaWInXG4gIHwgJ2N1c3RvbS1idWlsZCdcblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZVRhcmdldCB7XG4gIG5hbWU6IHN0cmluZ1xuICBraW5kOiBDcmF0ZVRhcmdldEtpbmRbXVxuICBjcmF0ZV90eXBlczogQ3JhdGVUYXJnZXRLaW5kW11cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDcmF0ZSB7XG4gIGlkOiBzdHJpbmdcbiAgbmFtZTogc3RyaW5nXG4gIHNyY19wYXRoOiBzdHJpbmdcbiAgdmVyc2lvbjogc3RyaW5nXG4gIGVkaXRpb246IHN0cmluZ1xuICB0YXJnZXRzOiBDcmF0ZVRhcmdldFtdXG4gIGZlYXR1cmVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT5cbiAgbWFuaWZlc3RfcGF0aDogc3RyaW5nXG4gIGRlcGVuZGVuY2llczogQXJyYXk8e1xuICAgIG5hbWU6IHN0cmluZ1xuICAgIHNvdXJjZTogc3RyaW5nXG4gICAgcmVxOiBzdHJpbmdcbiAgICBraW5kOiBzdHJpbmcgfCBudWxsXG4gICAgcmVuYW1lOiBzdHJpbmcgfCBudWxsXG4gICAgb3B0aW9uYWw6IGJvb2xlYW5cbiAgICB1c2VzX2RlZmF1bHRfZmVhdHVyZXM6IGJvb2xlYW5cbiAgICBmZWF0dXJlczogc3RyaW5nW11cbiAgICB0YXJnZXQ6IHN0cmluZyB8IG51bGxcbiAgICByZWdpc3RyeTogc3RyaW5nIHwgbnVsbFxuICB9PlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhcmdvV29ya3NwYWNlTWV0YWRhdGEge1xuICB2ZXJzaW9uOiBudW1iZXJcbiAgcGFja2FnZXM6IENyYXRlW11cbiAgd29ya3NwYWNlX21lbWJlcnM6IHN0cmluZ1tdXG4gIHRhcmdldF9kaXJlY3Rvcnk6IHN0cmluZ1xuICB3b3Jrc3BhY2Vfcm9vdDogc3RyaW5nXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aDogc3RyaW5nKSB7XG4gIGlmICghZnMuZXhpc3RzU3luYyhtYW5pZmVzdFBhdGgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBjcmF0ZSBmb3VuZCBpbiBtYW5pZmVzdDogJHttYW5pZmVzdFBhdGh9YClcbiAgfVxuXG4gIGNvbnN0IGNoaWxkUHJvY2VzcyA9IHNwYXduKFxuICAgICdjYXJnbycsXG4gICAgWydtZXRhZGF0YScsICctLW1hbmlmZXN0LXBhdGgnLCBtYW5pZmVzdFBhdGgsICctLWZvcm1hdC12ZXJzaW9uJywgJzEnXSxcbiAgICB7IHN0ZGlvOiAncGlwZScgfSxcbiAgKVxuXG4gIGxldCBzdGRvdXQgPSAnJ1xuICBsZXQgc3RkZXJyID0gJydcbiAgbGV0IHN0YXR1cyA9IDBcbiAgbGV0IGVycm9yID0gbnVsbFxuXG4gIGNoaWxkUHJvY2Vzcy5zdGRvdXQub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgIHN0ZG91dCArPSBkYXRhXG4gIH0pXG5cbiAgY2hpbGRQcm9jZXNzLnN0ZGVyci5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgc3RkZXJyICs9IGRhdGFcbiAgfSlcblxuICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIGNoaWxkUHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xuICAgICAgc3RhdHVzID0gY29kZSA/PyAwXG4gICAgICByZXNvbHZlKClcbiAgICB9KVxuICB9KVxuXG4gIGlmIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FyZ28gbWV0YWRhdGEgZmFpbGVkIHRvIHJ1bicsIHsgY2F1c2U6IGVycm9yIH0pXG4gIH1cbiAgaWYgKHN0YXR1cyAhPT0gMCkge1xuICAgIGNvbnN0IHNpbXBsZU1lc3NhZ2UgPSBgY2FyZ28gbWV0YWRhdGEgZXhpdGVkIHdpdGggY29kZSAke3N0YXR1c31gXG4gICAgdGhyb3cgbmV3IEVycm9yKGAke3NpbXBsZU1lc3NhZ2V9IGFuZCBlcnJvciBtZXNzYWdlOlxcblxcbiR7c3RkZXJyfWAsIHtcbiAgICAgIGNhdXNlOiBuZXcgRXJyb3Ioc2ltcGxlTWVzc2FnZSksXG4gICAgfSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3Rkb3V0KSBhcyBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBjYXJnbyBtZXRhZGF0YSBKU09OJywgeyBjYXVzZTogZSB9KVxuICB9XG59XG4iLCJpbXBvcnQgeyB1bmRlcmxpbmUsIHllbGxvdyB9IGZyb20gJ2NvbG9yZXR0ZSdcbmltcG9ydCB7IG1lcmdlLCBvbWl0IH0gZnJvbSAnZXMtdG9vbGtpdCdcblxuaW1wb3J0IHsgZmlsZUV4aXN0cywgcmVhZEZpbGVBc3luYyB9IGZyb20gJy4vbWlzYy5qcydcbmltcG9ydCB7IERFRkFVTFRfVEFSR0VUUywgcGFyc2VUcmlwbGUsIHR5cGUgVGFyZ2V0IH0gZnJvbSAnLi90YXJnZXQuanMnXG5cbmV4cG9ydCB0eXBlIFZhbHVlT2ZDb25zdEFycmF5PFQ+ID0gVFtFeGNsdWRlPGtleW9mIFQsIGtleW9mIEFycmF5PGFueT4+XVxuXG5leHBvcnQgY29uc3QgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzID0gWyd5YXJuJywgJ3BucG0nXSBhcyBjb25zdFxuZXhwb3J0IGNvbnN0IFN1cHBvcnRlZFRlc3RGcmFtZXdvcmtzID0gWydhdmEnXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlciA9IFZhbHVlT2ZDb25zdEFycmF5PFxuICB0eXBlb2YgU3VwcG9ydGVkUGFja2FnZU1hbmFnZXJzXG4+XG5leHBvcnQgdHlwZSBTdXBwb3J0ZWRUZXN0RnJhbWV3b3JrID0gVmFsdWVPZkNvbnN0QXJyYXk8XG4gIHR5cGVvZiBTdXBwb3J0ZWRUZXN0RnJhbWV3b3Jrc1xuPlxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJOYXBpQ29uZmlnIHtcbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGJpbmFyeSB0byBiZSBnZW5lcmF0ZWQsIGRlZmF1bHQgdG8gYGluZGV4YFxuICAgKi9cbiAgYmluYXJ5TmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogTmFtZSBvZiB0aGUgbnBtIHBhY2thZ2UsIGRlZmF1bHQgdG8gdGhlIG5hbWUgb2Ygcm9vdCBwYWNrYWdlLmpzb24gbmFtZVxuICAgKlxuICAgKiBBbHdheXMgZ2l2ZW4gYEBzY29wZS9wa2dgIGFuZCBhcmNoIHN1ZmZpeCB3aWxsIGJlIGFwcGVuZGVkIGxpa2UgYEBzY29wZS9wa2ctbGludXgtZ251LXg2NGBcbiAgICovXG4gIHBhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBBbGwgdGFyZ2V0cyB0aGUgY3JhdGUgd2lsbCBiZSBjb21waWxlZCBmb3JcbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuXG4gIC8qKlxuICAgKiBUaGUgbnBtIGNsaWVudCBwcm9qZWN0IHVzZXMuXG4gICAqL1xuICBucG1DbGllbnQ/OiBzdHJpbmdcblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBjb25zdCBlbnVtIGZvciB0eXBlc2NyaXB0IGJpbmRpbmdzXG4gICAqL1xuICBjb25zdEVudW0/OiBib29sZWFuXG5cbiAgLyoqXG4gICAqIGR0cyBoZWFkZXIgcHJlcGVuZCB0byB0aGUgZ2VuZXJhdGVkIGR0cyBmaWxlXG4gICAqL1xuICBkdHNIZWFkZXI/OiBzdHJpbmdcblxuICAvKipcbiAgICogZHRzIGhlYWRlciBmaWxlIHBhdGggdG8gYmUgcHJlcGVuZGVkIHRvIHRoZSBnZW5lcmF0ZWQgZHRzIGZpbGVcbiAgICogaWYgYm90aCBkdHNIZWFkZXIgYW5kIGR0c0hlYWRlckZpbGUgYXJlIHByb3ZpZGVkLCBkdHNIZWFkZXJGaWxlIHdpbGwgYmUgdXNlZFxuICAgKi9cbiAgZHRzSGVhZGVyRmlsZT86IHN0cmluZ1xuXG4gIC8qKlxuICAgKiB3YXNtIGNvbXBpbGF0aW9uIG9wdGlvbnNcbiAgICovXG4gIHdhc20/OiB7XG4gICAgLyoqXG4gICAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWJBc3NlbWJseS9KYXZhU2NyaXB0X2ludGVyZmFjZS9NZW1vcnlcbiAgICAgKiBAZGVmYXVsdCA0MDAwIHBhZ2VzICgyNTZNaUIpXG4gICAgICovXG4gICAgaW5pdGlhbE1lbW9yeT86IG51bWJlclxuICAgIC8qKlxuICAgICAqIEBkZWZhdWx0IDY1NTM2IHBhZ2VzICg0R2lCKVxuICAgICAqL1xuICAgIG1heGltdW1NZW1vcnk/OiBudW1iZXJcblxuICAgIC8qKlxuICAgICAqIEJyb3dzZXIgd2FzbSBiaW5kaW5nIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBicm93c2VyOiB7XG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gdXNlIGZzIG1vZHVsZSBpbiBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIGZzPzogYm9vbGVhblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRvIGluaXRpYWxpemUgd2FzbSBhc3luY2hyb25vdXNseVxuICAgICAgICovXG4gICAgICBhc3luY0luaXQ/OiBib29sZWFuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdG8gaW5qZWN0IGBidWZmZXJgIHRvIGVtbmFwaSBjb250ZXh0XG4gICAgICAgKi9cbiAgICAgIGJ1ZmZlcj86IGJvb2xlYW5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgYmluYXJ5TmFtZSBpbnN0ZWFkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgcGFja2FnZU5hbWUgaW5zdGVhZFxuICAgKi9cbiAgcGFja2FnZT86IHtcbiAgICBuYW1lPzogc3RyaW5nXG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB0YXJnZXRzIGluc3RlYWRcbiAgICovXG4gIHRyaXBsZXM/OiB7XG4gICAgLyoqXG4gICAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAgICovXG4gICAgZGVmYXVsdHM6IGJvb2xlYW5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIHRhcmdldHMgdG8gYmUgY29tcGlsZWQgZm9yXG4gICAgICovXG4gICAgYWRkaXRpb25hbD86IHN0cmluZ1tdXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21tb25QYWNrYWdlSnNvbkZpZWxkcyB7XG4gIG5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmdcbiAga2V5d29yZHM/OiBzdHJpbmdbXVxuICBhdXRob3I/OiBzdHJpbmdcbiAgYXV0aG9ycz86IHN0cmluZ1tdXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgY3B1Pzogc3RyaW5nW11cbiAgb3M/OiBzdHJpbmdbXVxuICBsaWJjPzogc3RyaW5nW11cbiAgZmlsZXM/OiBzdHJpbmdbXVxuICByZXBvc2l0b3J5PzogYW55XG4gIGhvbWVwYWdlPzogYW55XG4gIGVuZ2luZXM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gIHB1Ymxpc2hDb25maWc/OiBhbnlcbiAgYnVncz86IGFueVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgbmFwaT86IFVzZXJOYXBpQ29uZmlnXG4gIHR5cGU/OiAnbW9kdWxlJyB8ICdjb21tb25qcydcbiAgc2NyaXB0cz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cblxuICAvLyBtb2R1bGVzXG4gIG1haW4/OiBzdHJpbmdcbiAgbW9kdWxlPzogc3RyaW5nXG4gIHR5cGVzPzogc3RyaW5nXG4gIGJyb3dzZXI/OiBzdHJpbmdcbiAgZXhwb3J0cz86IGFueVxuXG4gIGRlcGVuZGVuY2llcz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgZGV2RGVwZW5kZW5jaWVzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuXG4gIGF2YT86IHtcbiAgICB0aW1lb3V0Pzogc3RyaW5nXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgTmFwaUNvbmZpZyA9IFJlcXVpcmVkPFxuICBQaWNrPFVzZXJOYXBpQ29uZmlnLCAnYmluYXJ5TmFtZScgfCAncGFja2FnZU5hbWUnIHwgJ25wbUNsaWVudCc+XG4+ICZcbiAgUGljazxVc2VyTmFwaUNvbmZpZywgJ3dhc20nIHwgJ2R0c0hlYWRlcicgfCAnZHRzSGVhZGVyRmlsZScgfCAnY29uc3RFbnVtJz4gJiB7XG4gICAgdGFyZ2V0czogVGFyZ2V0W11cbiAgICBwYWNrYWdlSnNvbjogQ29tbW9uUGFja2FnZUpzb25GaWVsZHNcbiAgfVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZE5hcGlDb25maWcoXG4gIHBhdGg6IHN0cmluZyxcbiAgY29uZmlnUGF0aD86IHN0cmluZyxcbik6IFByb21pc2U8TmFwaUNvbmZpZz4ge1xuICBpZiAoY29uZmlnUGF0aCAmJiAhKGF3YWl0IGZpbGVFeGlzdHMoY29uZmlnUGF0aCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBOQVBJLVJTIGNvbmZpZyBub3QgZm91bmQgYXQgJHtjb25maWdQYXRofWApXG4gIH1cbiAgaWYgKCEoYXdhaXQgZmlsZUV4aXN0cyhwYXRoKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhY2thZ2UuanNvbiBub3QgZm91bmQgYXQgJHtwYXRofWApXG4gIH1cbiAgLy8gTWF5IHN1cHBvcnQgbXVsdGlwbGUgY29uZmlnIHNvdXJjZXMgbGF0ZXIgb24uXG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKHBhdGgsICd1dGY4JylcbiAgbGV0IHBrZ0pzb25cbiAgdHJ5IHtcbiAgICBwa2dKc29uID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBDb21tb25QYWNrYWdlSnNvbkZpZWxkc1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgcGFja2FnZS5qc29uIGF0ICR7cGF0aH1gLCB7XG4gICAgICBjYXVzZTogZSxcbiAgICB9KVxuICB9XG5cbiAgbGV0IHNlcGFyYXRlZENvbmZpZzogVXNlck5hcGlDb25maWcgfCB1bmRlZmluZWRcbiAgaWYgKGNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjb25maWdQYXRoLCAndXRmOCcpXG4gICAgdHJ5IHtcbiAgICAgIHNlcGFyYXRlZENvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudCkgYXMgVXNlck5hcGlDb25maWdcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBOQVBJLVJTIGNvbmZpZyBhdCAke2NvbmZpZ1BhdGh9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgY29uc3QgdXNlck5hcGlDb25maWcgPSBwa2dKc29uLm5hcGkgPz8ge31cbiAgaWYgKHBrZ0pzb24ubmFwaSAmJiBzZXBhcmF0ZWRDb25maWcpIHtcbiAgICBjb25zdCBwa2dKc29uUGF0aCA9IHVuZGVybGluZShwYXRoKVxuICAgIGNvbnN0IGNvbmZpZ1BhdGhVbmRlcmxpbmUgPSB1bmRlcmxpbmUoY29uZmlnUGF0aCEpXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgeWVsbG93KFxuICAgICAgICBgQm90aCBuYXBpIGZpZWxkIGluICR7cGtnSnNvblBhdGh9IGFuZCBbTkFQSS1SUyBjb25maWddKCR7Y29uZmlnUGF0aFVuZGVybGluZX0pIGZpbGUgYXJlIGZvdW5kLCB0aGUgTkFQSS1SUyBjb25maWcgZmlsZSB3aWxsIGJlIHVzZWQuYCxcbiAgICAgICksXG4gICAgKVxuICAgIE9iamVjdC5hc3NpZ24odXNlck5hcGlDb25maWcsIHNlcGFyYXRlZENvbmZpZylcbiAgfVxuICBjb25zdCBuYXBpQ29uZmlnOiBOYXBpQ29uZmlnID0gbWVyZ2UoXG4gICAge1xuICAgICAgYmluYXJ5TmFtZTogJ2luZGV4JyxcbiAgICAgIHBhY2thZ2VOYW1lOiBwa2dKc29uLm5hbWUsXG4gICAgICB0YXJnZXRzOiBbXSxcbiAgICAgIHBhY2thZ2VKc29uOiBwa2dKc29uLFxuICAgICAgbnBtQ2xpZW50OiAnbnBtJyxcbiAgICB9LFxuICAgIG9taXQodXNlck5hcGlDb25maWcsIFsndGFyZ2V0cyddKSxcbiAgKVxuXG4gIGxldCB0YXJnZXRzOiBzdHJpbmdbXSA9IHVzZXJOYXBpQ29uZmlnLnRhcmdldHMgPz8gW11cblxuICAvLyBjb21wYXRpYmxlIHdpdGggb2xkIGNvbmZpZ1xuICBpZiAodXNlck5hcGlDb25maWc/Lm5hbWUpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICB5ZWxsb3coXG4gICAgICAgIGBbREVQUkVDQVRFRF0gbmFwaS5uYW1lIGlzIGRlcHJlY2F0ZWQsIHVzZSBuYXBpLmJpbmFyeU5hbWUgaW5zdGVhZC5gLFxuICAgICAgKSxcbiAgICApXG4gICAgbmFwaUNvbmZpZy5iaW5hcnlOYW1lID0gdXNlck5hcGlDb25maWcubmFtZVxuICB9XG5cbiAgaWYgKCF0YXJnZXRzLmxlbmd0aCkge1xuICAgIGxldCBkZXByZWNhdGVkV2FybmVkID0gZmFsc2VcbiAgICBjb25zdCB3YXJuaW5nID0geWVsbG93KFxuICAgICAgYFtERVBSRUNBVEVEXSBuYXBpLnRyaXBsZXMgaXMgZGVwcmVjYXRlZCwgdXNlIG5hcGkudGFyZ2V0cyBpbnN0ZWFkLmAsXG4gICAgKVxuICAgIGlmICh1c2VyTmFwaUNvbmZpZy50cmlwbGVzPy5kZWZhdWx0cykge1xuICAgICAgZGVwcmVjYXRlZFdhcm5lZCA9IHRydWVcbiAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKVxuICAgICAgdGFyZ2V0cyA9IHRhcmdldHMuY29uY2F0KERFRkFVTFRfVEFSR0VUUylcbiAgICB9XG5cbiAgICBpZiAodXNlck5hcGlDb25maWcudHJpcGxlcz8uYWRkaXRpb25hbD8ubGVuZ3RoKSB7XG4gICAgICB0YXJnZXRzID0gdGFyZ2V0cy5jb25jYXQodXNlck5hcGlDb25maWcudHJpcGxlcy5hZGRpdGlvbmFsKVxuICAgICAgaWYgKCFkZXByZWNhdGVkV2FybmVkKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgZHVwbGljYXRlIHRhcmdldHNcbiAgY29uc3QgdW5pcXVlVGFyZ2V0cyA9IG5ldyBTZXQodGFyZ2V0cylcbiAgaWYgKHVuaXF1ZVRhcmdldHMuc2l6ZSAhPT0gdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICBjb25zdCBkdXBsaWNhdGVUYXJnZXQgPSB0YXJnZXRzLmZpbmQoXG4gICAgICAodGFyZ2V0LCBpbmRleCkgPT4gdGFyZ2V0cy5pbmRleE9mKHRhcmdldCkgIT09IGluZGV4LFxuICAgIClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSB0YXJnZXRzIGFyZSBub3QgYWxsb3dlZDogJHtkdXBsaWNhdGVUYXJnZXR9YClcbiAgfVxuXG4gIG5hcGlDb25maWcudGFyZ2V0cyA9IHRhcmdldHMubWFwKHBhcnNlVHJpcGxlKVxuXG4gIHJldHVybiBuYXBpQ29uZmlnXG59XG4iLCJpbXBvcnQgeyBleGVjU3luYyB9IGZyb20gJ25vZGU6Y2hpbGRfcHJvY2VzcydcblxuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuL2xvZy5qcydcblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUluc3RhbGxDYXJnb0JpbmFyeShuYW1lOiBzdHJpbmcsIGJpbjogc3RyaW5nKSB7XG4gIGlmIChkZXRlY3RDYXJnb0JpbmFyeShiaW4pKSB7XG4gICAgZGVidWcoJ0NhcmdvIGJpbmFyeSBhbHJlYWR5IGluc3RhbGxlZDogJXMnLCBuYW1lKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygnSW5zdGFsbGluZyBjYXJnbyBiaW5hcnk6ICVzJywgbmFtZSlcbiAgICBleGVjU3luYyhgY2FyZ28gaW5zdGFsbCAke25hbWV9YCwge1xuICAgICAgc3RkaW86ICdpbmhlcml0JyxcbiAgICB9KVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5zdGFsbCBjYXJnbyBiaW5hcnk6ICR7bmFtZX1gLCB7XG4gICAgICBjYXVzZTogZSxcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGVjdENhcmdvQmluYXJ5KGJpbjogc3RyaW5nKSB7XG4gIGRlYnVnKCdEZXRlY3RpbmcgY2FyZ28gYmluYXJ5OiAlcycsIGJpbilcbiAgdHJ5IHtcbiAgICBleGVjU3luYyhgY2FyZ28gaGVscCAke2Jpbn1gLCB7XG4gICAgICBzdGRpbzogJ2lnbm9yZScsXG4gICAgfSlcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IGRldGVjdGVkOiAlcycsIGJpbilcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICBkZWJ1ZygnQ2FyZ28gYmluYXJ5IG5vdCBkZXRlY3RlZDogJXMnLCBiaW4pXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsImltcG9ydCB7IHNvcnRCeSB9IGZyb20gJ2VzLXRvb2xraXQnXG5cbmltcG9ydCB7IHJlYWRGaWxlQXN5bmMgfSBmcm9tICcuL21pc2MuanMnXG5cbmNvbnN0IFRPUF9MRVZFTF9OQU1FU1BBQ0UgPSAnX19UT1BfTEVWRUxfTU9EVUxFX18nXG5leHBvcnQgY29uc3QgREVGQVVMVF9UWVBFX0RFRl9IRUFERVIgPSBgLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbmBcblxuZW51bSBUeXBlRGVmS2luZCB7XG4gIENvbnN0ID0gJ2NvbnN0JyxcbiAgRW51bSA9ICdlbnVtJyxcbiAgU3RyaW5nRW51bSA9ICdzdHJpbmdfZW51bScsXG4gIEludGVyZmFjZSA9ICdpbnRlcmZhY2UnLFxuICBUeXBlID0gJ3R5cGUnLFxuICBGbiA9ICdmbicsXG4gIFN0cnVjdCA9ICdzdHJ1Y3QnLFxuICBFeHRlbmRzID0gJ2V4dGVuZHMnLFxuICBJbXBsID0gJ2ltcGwnLFxufVxuXG5pbnRlcmZhY2UgVHlwZURlZkxpbmUge1xuICBraW5kOiBUeXBlRGVmS2luZFxuICBuYW1lOiBzdHJpbmdcbiAgb3JpZ2luYWxfbmFtZT86IHN0cmluZ1xuICBkZWY6IHN0cmluZ1xuICBleHRlbmRzPzogc3RyaW5nXG4gIGpzX2RvYz86IHN0cmluZ1xuICBqc19tb2Q/OiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gcHJldHR5UHJpbnQoXG4gIGxpbmU6IFR5cGVEZWZMaW5lLFxuICBjb25zdEVudW06IGJvb2xlYW4sXG4gIGlkZW50OiBudW1iZXIsXG4gIGFtYmllbnQgPSBmYWxzZSxcbik6IHN0cmluZyB7XG4gIGxldCBzID0gbGluZS5qc19kb2MgPz8gJydcbiAgc3dpdGNoIChsaW5lLmtpbmQpIHtcbiAgICBjYXNlIFR5cGVEZWZLaW5kLkludGVyZmFjZTpcbiAgICAgIHMgKz0gYGV4cG9ydCBpbnRlcmZhY2UgJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5UeXBlOlxuICAgICAgcyArPSBgZXhwb3J0IHR5cGUgJHtsaW5lLm5hbWV9ID0gXFxuJHtsaW5lLmRlZn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5FbnVtOlxuICAgICAgY29uc3QgZW51bU5hbWUgPSBjb25zdEVudW0gPyAnY29uc3QgZW51bScgOiAnZW51bSdcbiAgICAgIHMgKz0gYCR7ZXhwb3J0RGVjbGFyZShhbWJpZW50KX0gJHtlbnVtTmFtZX0gJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBicmVha1xuXG4gICAgY2FzZSBUeXBlRGVmS2luZC5TdHJpbmdFbnVtOlxuICAgICAgaWYgKGNvbnN0RW51bSkge1xuICAgICAgICBzICs9IGAke2V4cG9ydERlY2xhcmUoYW1iaWVudCl9IGNvbnN0IGVudW0gJHtsaW5lLm5hbWV9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzICs9IGBleHBvcnQgdHlwZSAke2xpbmUubmFtZX0gPSAke2xpbmUuZGVmLnJlcGxhY2VBbGwoLy4qPS9nLCAnJykucmVwbGFjZUFsbCgnLCcsICd8Jyl9O2BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLlN0cnVjdDpcbiAgICAgIGNvbnN0IGV4dGVuZHNEZWYgPSBsaW5lLmV4dGVuZHMgPyBgIGV4dGVuZHMgJHtsaW5lLmV4dGVuZHN9YCA6ICcnXG4gICAgICBpZiAobGluZS5leHRlbmRzKSB7XG4gICAgICAgIC8vIEV4dHJhY3QgZ2VuZXJpYyBwYXJhbXMgZnJvbSBleHRlbmRzIHR5cGUgbGlrZSBJdGVyYXRvcjxULCBUUmVzdWx0LCBUTmV4dD5cbiAgICAgICAgY29uc3QgZ2VuZXJpY01hdGNoID0gbGluZS5leHRlbmRzLm1hdGNoKC9JdGVyYXRvcjwoLispPiQvKVxuICAgICAgICBpZiAoZ2VuZXJpY01hdGNoKSB7XG4gICAgICAgICAgY29uc3QgW1QsIFRSZXN1bHQsIFROZXh0XSA9IGdlbmVyaWNNYXRjaFsxXVxuICAgICAgICAgICAgLnNwbGl0KCcsJylcbiAgICAgICAgICAgIC5tYXAoKHApID0+IHAudHJpbSgpKVxuICAgICAgICAgIGxpbmUuZGVmID1cbiAgICAgICAgICAgIGxpbmUuZGVmICtcbiAgICAgICAgICAgIGBcXG5uZXh0KHZhbHVlPzogJHtUTmV4dH0pOiBJdGVyYXRvclJlc3VsdDwke1R9LCAke1RSZXN1bHR9PmBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSBjbGFzcyAke2xpbmUubmFtZX0ke2V4dGVuZHNEZWZ9IHtcXG4ke2xpbmUuZGVmfVxcbn1gXG4gICAgICBpZiAobGluZS5vcmlnaW5hbF9uYW1lICYmIGxpbmUub3JpZ2luYWxfbmFtZSAhPT0gbGluZS5uYW1lKSB7XG4gICAgICAgIHMgKz0gYFxcbmV4cG9ydCB0eXBlICR7bGluZS5vcmlnaW5hbF9uYW1lfSA9ICR7bGluZS5uYW1lfWBcbiAgICAgIH1cbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFR5cGVEZWZLaW5kLkZuOlxuICAgICAgcyArPSBgJHtleHBvcnREZWNsYXJlKGFtYmllbnQpfSAke2xpbmUuZGVmfWBcbiAgICAgIGJyZWFrXG5cbiAgICBkZWZhdWx0OlxuICAgICAgcyArPSBsaW5lLmRlZlxuICB9XG5cbiAgcmV0dXJuIGNvcnJlY3RTdHJpbmdJZGVudChzLCBpZGVudClcbn1cblxuZnVuY3Rpb24gZXhwb3J0RGVjbGFyZShhbWJpZW50OiBib29sZWFuKTogc3RyaW5nIHtcbiAgaWYgKGFtYmllbnQpIHtcbiAgICByZXR1cm4gJ2V4cG9ydCdcbiAgfVxuXG4gIHJldHVybiAnZXhwb3J0IGRlY2xhcmUnXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzVHlwZURlZihcbiAgaW50ZXJtZWRpYXRlVHlwZUZpbGU6IHN0cmluZyxcbiAgY29uc3RFbnVtOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IGV4cG9ydHM6IHN0cmluZ1tdID0gW11cbiAgY29uc3QgZGVmcyA9IGF3YWl0IHJlYWRJbnRlcm1lZGlhdGVUeXBlRmlsZShpbnRlcm1lZGlhdGVUeXBlRmlsZSlcbiAgY29uc3QgZ3JvdXBlZERlZnMgPSBwcmVwcm9jZXNzVHlwZURlZihkZWZzKVxuXG4gIGNvbnN0IGR0cyA9XG4gICAgc29ydEJ5KEFycmF5LmZyb20oZ3JvdXBlZERlZnMpLCBbKFtuYW1lc3BhY2VdKSA9PiBuYW1lc3BhY2VdKVxuICAgICAgLm1hcCgoW25hbWVzcGFjZSwgZGVmc10pID0+IHtcbiAgICAgICAgaWYgKG5hbWVzcGFjZSA9PT0gVE9QX0xFVkVMX05BTUVTUEFDRSkge1xuICAgICAgICAgIHJldHVybiBkZWZzXG4gICAgICAgICAgICAubWFwKChkZWYpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChkZWYua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuQ29uc3Q6XG4gICAgICAgICAgICAgICAgY2FzZSBUeXBlRGVmS2luZC5FbnVtOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RyaW5nRW51bTpcbiAgICAgICAgICAgICAgICBjYXNlIFR5cGVEZWZLaW5kLkZuOlxuICAgICAgICAgICAgICAgIGNhc2UgVHlwZURlZktpbmQuU3RydWN0OiB7XG4gICAgICAgICAgICAgICAgICBleHBvcnRzLnB1c2goZGVmLm5hbWUpXG4gICAgICAgICAgICAgICAgICBpZiAoZGVmLm9yaWdpbmFsX25hbWUgJiYgZGVmLm9yaWdpbmFsX25hbWUgIT09IGRlZi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucHVzaChkZWYub3JpZ2luYWxfbmFtZSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignXFxuXFxuJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleHBvcnRzLnB1c2gobmFtZXNwYWNlKVxuICAgICAgICAgIGxldCBkZWNsYXJhdGlvbiA9ICcnXG4gICAgICAgICAgZGVjbGFyYXRpb24gKz0gYGV4cG9ydCBkZWNsYXJlIG5hbWVzcGFjZSAke25hbWVzcGFjZX0ge1xcbmBcbiAgICAgICAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbiArPSBwcmV0dHlQcmludChkZWYsIGNvbnN0RW51bSwgMiwgdHJ1ZSkgKyAnXFxuJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWNsYXJhdGlvbiArPSAnfSdcbiAgICAgICAgICByZXR1cm4gZGVjbGFyYXRpb25cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5qb2luKCdcXG5cXG4nKSArICdcXG4nXG5cbiAgcmV0dXJuIHtcbiAgICBkdHMsXG4gICAgZXhwb3J0cyxcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiByZWFkSW50ZXJtZWRpYXRlVHlwZUZpbGUoZmlsZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGUsICd1dGY4JylcblxuICBjb25zdCBkZWZzID0gY29udGVudFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKGxpbmUpIGFzIFR5cGVEZWZMaW5lXG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgYmFjayB0byBhY3R1YWwgbmV3bGluZXMgaW4ganNfZG9jIGZpZWxkc1xuICAgICAgaWYgKHBhcnNlZC5qc19kb2MpIHtcbiAgICAgICAgcGFyc2VkLmpzX2RvYyA9IHBhcnNlZC5qc19kb2MucmVwbGFjZSgvXFxcXG4vZywgJ1xcbicpXG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IGVzY2FwZWQgbmV3bGluZXMgdG8gYWN0dWFsIG5ld2xpbmVzIGluIGRlZiBmaWVsZHMgZm9yIHN0cnVjdC9jbGFzcy9pbnRlcmZhY2UvdHlwZSB0eXBlc1xuICAgICAgLy8gd2hlcmUgXFxuIHJlcHJlc2VudHMgbWV0aG9kL2ZpZWxkIHNlcGFyYXRvcnMgdGhhdCBzaG91bGQgYmUgYWN0dWFsIG5ld2xpbmVzXG4gICAgICBpZiAocGFyc2VkLmRlZikge1xuICAgICAgICBwYXJzZWQuZGVmID0gcGFyc2VkLmRlZi5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWRcbiAgICB9KVxuXG4gIC8vIG1vdmUgYWxsIGBzdHJ1Y3RgIGRlZiB0byB0aGUgdmVyeSB0b3BcbiAgLy8gYW5kIG9yZGVyIHRoZSByZXN0IGFscGhhYmV0aWNhbGx5LlxuICByZXR1cm4gZGVmcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEua2luZCA9PT0gVHlwZURlZktpbmQuU3RydWN0KSB7XG4gICAgICBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSlcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoYi5raW5kID09PSBUeXBlRGVmS2luZC5TdHJ1Y3QpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBwcmVwcm9jZXNzVHlwZURlZihkZWZzOiBUeXBlRGVmTGluZVtdKTogTWFwPHN0cmluZywgVHlwZURlZkxpbmVbXT4ge1xuICBjb25zdCBuYW1lc3BhY2VHcm91cGVkID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lW10+KClcbiAgY29uc3QgY2xhc3NEZWZzID0gbmV3IE1hcDxzdHJpbmcsIFR5cGVEZWZMaW5lPigpXG5cbiAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgIGNvbnN0IG5hbWVzcGFjZSA9IGRlZi5qc19tb2QgPz8gVE9QX0xFVkVMX05BTUVTUEFDRVxuICAgIGlmICghbmFtZXNwYWNlR3JvdXBlZC5oYXMobmFtZXNwYWNlKSkge1xuICAgICAgbmFtZXNwYWNlR3JvdXBlZC5zZXQobmFtZXNwYWNlLCBbXSlcbiAgICB9XG5cbiAgICBjb25zdCBncm91cCA9IG5hbWVzcGFjZUdyb3VwZWQuZ2V0KG5hbWVzcGFjZSkhXG5cbiAgICBpZiAoZGVmLmtpbmQgPT09IFR5cGVEZWZLaW5kLlN0cnVjdCkge1xuICAgICAgZ3JvdXAucHVzaChkZWYpXG4gICAgICBjbGFzc0RlZnMuc2V0KGRlZi5uYW1lLCBkZWYpXG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuRXh0ZW5kcykge1xuICAgICAgY29uc3QgY2xhc3NEZWYgPSBjbGFzc0RlZnMuZ2V0KGRlZi5uYW1lKVxuICAgICAgaWYgKGNsYXNzRGVmKSB7XG4gICAgICAgIGNsYXNzRGVmLmV4dGVuZHMgPSBkZWYuZGVmXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWYua2luZCA9PT0gVHlwZURlZktpbmQuSW1wbCkge1xuICAgICAgLy8gbWVyZ2UgYGltcGxgIGludG8gY2xhc3MgZGVmaW5pdGlvblxuICAgICAgY29uc3QgY2xhc3NEZWYgPSBjbGFzc0RlZnMuZ2V0KGRlZi5uYW1lKVxuICAgICAgaWYgKGNsYXNzRGVmKSB7XG4gICAgICAgIGlmIChjbGFzc0RlZi5kZWYpIHtcbiAgICAgICAgICBjbGFzc0RlZi5kZWYgKz0gJ1xcbidcbiAgICAgICAgfVxuXG4gICAgICAgIGNsYXNzRGVmLmRlZiArPSBkZWYuZGVmXG4gICAgICAgIC8vIENvbnZlcnQgYW55IHJlbWFpbmluZyBcXG4gc2VxdWVuY2VzIGluIHRoZSBtZXJnZWQgZGVmIHRvIGFjdHVhbCBuZXdsaW5lc1xuICAgICAgICBpZiAoY2xhc3NEZWYuZGVmKSB7XG4gICAgICAgICAgY2xhc3NEZWYuZGVmID0gY2xhc3NEZWYuZGVmLnJlcGxhY2UoL1xcXFxuL2csICdcXG4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyb3VwLnB1c2goZGVmKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lc3BhY2VHcm91cGVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3JyZWN0U3RyaW5nSWRlbnQoc3JjOiBzdHJpbmcsIGlkZW50OiBudW1iZXIpOiBzdHJpbmcge1xuICBsZXQgYnJhY2tldERlcHRoID0gMFxuICBjb25zdCByZXN1bHQgPSBzcmNcbiAgICAuc3BsaXQoJ1xcbicpXG4gICAgLm1hcCgobGluZSkgPT4ge1xuICAgICAgbGluZSA9IGxpbmUudHJpbSgpXG4gICAgICBpZiAobGluZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzSW5NdWx0aWxpbmVDb21tZW50ID0gbGluZS5zdGFydHNXaXRoKCcqJylcbiAgICAgIGNvbnN0IGlzQ2xvc2luZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd9JylcbiAgICAgIGNvbnN0IGlzT3BlbmluZ0JyYWNrZXQgPSBsaW5lLmVuZHNXaXRoKCd7JylcbiAgICAgIGNvbnN0IGlzVHlwZURlY2xhcmF0aW9uID0gbGluZS5lbmRzV2l0aCgnPScpXG4gICAgICBjb25zdCBpc1R5cGVWYXJpYW50ID0gbGluZS5zdGFydHNXaXRoKCd8JylcblxuICAgICAgbGV0IHJpZ2h0SW5kZW50ID0gaWRlbnRcbiAgICAgIGlmICgoaXNPcGVuaW5nQnJhY2tldCB8fCBpc1R5cGVEZWNsYXJhdGlvbikgJiYgIWlzSW5NdWx0aWxpbmVDb21tZW50KSB7XG4gICAgICAgIGJyYWNrZXREZXB0aCArPSAxXG4gICAgICAgIHJpZ2h0SW5kZW50ICs9IChicmFja2V0RGVwdGggLSAxKSAqIDJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0Nsb3NpbmdCcmFja2V0ICYmXG4gICAgICAgICAgYnJhY2tldERlcHRoID4gMCAmJlxuICAgICAgICAgICFpc0luTXVsdGlsaW5lQ29tbWVudCAmJlxuICAgICAgICAgICFpc1R5cGVWYXJpYW50XG4gICAgICAgICkge1xuICAgICAgICAgIGJyYWNrZXREZXB0aCAtPSAxXG4gICAgICAgIH1cbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gYnJhY2tldERlcHRoICogMlxuICAgICAgfVxuXG4gICAgICBpZiAoaXNJbk11bHRpbGluZUNvbW1lbnQpIHtcbiAgICAgICAgcmlnaHRJbmRlbnQgKz0gMVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzID0gYCR7JyAnLnJlcGVhdChyaWdodEluZGVudCl9JHtsaW5lfWBcblxuICAgICAgcmV0dXJuIHNcbiAgICB9KVxuICAgIC5qb2luKCdcXG4nKVxuXG4gIHJldHVybiByZXN1bHRcbn1cbiIsImltcG9ydCB7IHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7IHJlYWROYXBpQ29uZmlnIH0gZnJvbSAnLi9jb25maWcuanMnXG5cbmludGVyZmFjZSBNaW5pbWFsTmFwaU9wdGlvbnMge1xuICBjd2Q6IHN0cmluZ1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIHBhY2thZ2VKc29uUGF0aD86IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZENvbmZpZyhvcHRpb25zOiBNaW5pbWFsTmFwaU9wdGlvbnMpIHtcbiAgY29uc3QgcmVzb2x2ZVBhdGggPSAoLi4ucGF0aHM6IHN0cmluZ1tdKSA9PiByZXNvbHZlKG9wdGlvbnMuY3dkLCAuLi5wYXRocylcbiAgY29uc3QgY29uZmlnID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcmVzb2x2ZVBhdGgob3B0aW9ucy5wYWNrYWdlSnNvblBhdGggPz8gJ3BhY2thZ2UuanNvbicpLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmVQYXRoKG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcbiAgcmV0dXJuIGNvbmZpZ1xufVxuIiwiaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSwgcGFyc2UgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCAqIGFzIGNvbG9ycyBmcm9tICdjb2xvcmV0dGUnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdEFydGlmYWN0c09wdGlvbnMsXG4gIHR5cGUgQXJ0aWZhY3RzT3B0aW9ucyxcbn0gZnJvbSAnLi4vZGVmL2FydGlmYWN0cy5qcydcbmltcG9ydCB7XG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHJlYWRGaWxlQXN5bmMsXG4gIHdyaXRlRmlsZUFzeW5jLFxuICBVbmlBcmNoc0J5UGxhdGZvcm0sXG4gIHJlYWRkaXJBc3luYyxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCdhcnRpZmFjdHMnKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdEFydGlmYWN0cyh1c2VyT3B0aW9uczogQXJ0aWZhY3RzT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0QXJ0aWZhY3RzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlUGF0aChvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcbiAgY29uc3QgeyB0YXJnZXRzLCBiaW5hcnlOYW1lLCBwYWNrYWdlTmFtZSB9ID0gYXdhaXQgcmVhZE5hcGlDb25maWcoXG4gICAgcGFja2FnZUpzb25QYXRoLFxuICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmVQYXRoKG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gIClcblxuICBjb25zdCBkaXN0RGlycyA9IHRhcmdldHMubWFwKChwbGF0Zm9ybSkgPT5cbiAgICBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpciwgcGxhdGZvcm0ucGxhdGZvcm1BcmNoQUJJKSxcbiAgKVxuXG4gIGNvbnN0IHVuaXZlcnNhbFNvdXJjZUJpbnMgPSBuZXcgU2V0KFxuICAgIHRhcmdldHNcbiAgICAgIC5maWx0ZXIoKHBsYXRmb3JtKSA9PiBwbGF0Zm9ybS5hcmNoID09PSAndW5pdmVyc2FsJylcbiAgICAgIC5mbGF0TWFwKChwKSA9PlxuICAgICAgICBVbmlBcmNoc0J5UGxhdGZvcm1bcC5wbGF0Zm9ybV0/Lm1hcCgoYSkgPT4gYCR7cC5wbGF0Zm9ybX0tJHthfWApLFxuICAgICAgKVxuICAgICAgLmZpbHRlcihCb29sZWFuKSBhcyBzdHJpbmdbXSxcbiAgKVxuXG4gIGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5vdXRwdXREaXIpKS50aGVuKFxuICAgIChvdXRwdXQpID0+XG4gICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgb3V0cHV0Lm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICAgICAgICBkZWJ1Zy5pbmZvKGBSZWFkIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoZmlsZVBhdGgpfV1gKVxuICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGZpbGVQYXRoKVxuICAgICAgICAgIGNvbnN0IHBhcnNlZE5hbWUgPSBwYXJzZShmaWxlUGF0aClcbiAgICAgICAgICBjb25zdCB0ZXJtcyA9IHBhcnNlZE5hbWUubmFtZS5zcGxpdCgnLicpXG4gICAgICAgICAgY29uc3QgcGxhdGZvcm1BcmNoQUJJID0gdGVybXMucG9wKCkhXG4gICAgICAgICAgY29uc3QgX2JpbmFyeU5hbWUgPSB0ZXJtcy5qb2luKCcuJylcblxuICAgICAgICAgIGlmIChfYmluYXJ5TmFtZSAhPT0gYmluYXJ5TmFtZSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske19iaW5hcnlOYW1lfV0gaXMgbm90IG1hdGNoZWQgd2l0aCBbJHtiaW5hcnlOYW1lfV0sIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRpciA9IGRpc3REaXJzLmZpbmQoKGRpcikgPT4gZGlyLmluY2x1ZGVzKHBsYXRmb3JtQXJjaEFCSSkpXG4gICAgICAgICAgaWYgKCFkaXIgJiYgdW5pdmVyc2FsU291cmNlQmlucy5oYXMocGxhdGZvcm1BcmNoQUJJKSkge1xuICAgICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICAgYFske3BsYXRmb3JtQXJjaEFCSX1dIGhhcyBubyBkaXN0IGRpciBidXQgaXQgaXMgc291cmNlIGJpbiBmb3IgdW5pdmVyc2FsIGFyY2gsIHNraXBgLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZGlyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRpc3QgZGlyIGZvdW5kIGZvciAke2ZpbGVQYXRofWApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZGlzdEZpbGVQYXRoID0gam9pbihkaXIsIHBhcnNlZE5hbWUuYmFzZSlcbiAgICAgICAgICBkZWJ1Zy5pbmZvKFxuICAgICAgICAgICAgYFdyaXRlIGZpbGUgY29udGVudCB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KGRpc3RGaWxlUGF0aCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aCwgc291cmNlQ29udGVudClcbiAgICAgICAgICBjb25zdCBkaXN0RmlsZVBhdGhMb2NhbCA9IGpvaW4oXG4gICAgICAgICAgICBwYXJzZShwYWNrYWdlSnNvblBhdGgpLmRpcixcbiAgICAgICAgICAgIHBhcnNlZE5hbWUuYmFzZSxcbiAgICAgICAgICApXG4gICAgICAgICAgZGVidWcuaW5mbyhcbiAgICAgICAgICAgIGBXcml0ZSBmaWxlIGNvbnRlbnQgdG8gWyR7Y29sb3JzLnllbGxvd0JyaWdodChkaXN0RmlsZVBhdGhMb2NhbCl9XWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRpc3RGaWxlUGF0aExvY2FsLCBzb3VyY2VDb250ZW50KVxuICAgICAgICB9KSxcbiAgICAgICksXG4gIClcblxuICBjb25zdCB3YXNpVGFyZ2V0ID0gdGFyZ2V0cy5maW5kKCh0KSA9PiB0LnBsYXRmb3JtID09PSAnd2FzaScpXG4gIGlmICh3YXNpVGFyZ2V0KSB7XG4gICAgY29uc3Qgd2FzaURpciA9IGpvaW4oXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgd2FzaVRhcmdldC5wbGF0Zm9ybUFyY2hBQkksXG4gICAgKVxuICAgIGNvbnN0IGNqc0ZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYCxcbiAgICApXG4gICAgY29uc3Qgd29ya2VyRmlsZSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYHdhc2ktd29ya2VyLm1qc2AsXG4gICAgKVxuICAgIGNvbnN0IGJyb3dzZXJFbnRyeSA9IGpvaW4oXG4gICAgICBvcHRpb25zLmJ1aWxkT3V0cHV0RGlyID8/IG9wdGlvbnMuY3dkLFxuICAgICAgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgY29uc3QgYnJvd3NlcldvcmtlckZpbGUgPSBqb2luKFxuICAgICAgb3B0aW9ucy5idWlsZE91dHB1dERpciA/PyBvcHRpb25zLmN3ZCxcbiAgICAgIGB3YXNpLXdvcmtlci1icm93c2VyLm1qc2AsXG4gICAgKVxuICAgIGRlYnVnLmluZm8oXG4gICAgICBgTW92ZSB3YXNpIGJpbmRpbmcgZmlsZSBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KFxuICAgICAgICBjanNGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgJHtiaW5hcnlOYW1lfS53YXNpLmNqc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyhjanNGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgd29ya2VyIGZpbGUgWyR7Y29sb3JzLnllbGxvd0JyaWdodChcbiAgICAgICAgd29ya2VyRmlsZSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYHdhc2ktd29ya2VyLm1qc2ApLFxuICAgICAgYXdhaXQgcmVhZEZpbGVBc3luYyh3b3JrZXJGaWxlKSxcbiAgICApXG4gICAgZGVidWcuaW5mbyhcbiAgICAgIGBNb3ZlIHdhc2kgYnJvd3NlciBlbnRyeSBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJFbnRyeSxcbiAgICAgICl9XSB0byBbJHtjb2xvcnMueWVsbG93QnJpZ2h0KHdhc2lEaXIpfV1gLFxuICAgIClcbiAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgIGpvaW4od2FzaURpciwgYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCksXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUvaXNzdWVzLzg0MjdcbiAgICAgIChhd2FpdCByZWFkRmlsZUFzeW5jKGJyb3dzZXJFbnRyeSwgJ3V0ZjgnKSkucmVwbGFjZShcbiAgICAgICAgYG5ldyBVUkwoJy4vd2FzaS13b3JrZXItYnJvd3Nlci5tanMnLCBpbXBvcnQubWV0YS51cmwpYCxcbiAgICAgICAgYG5ldyBVUkwoJyR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKWAsXG4gICAgICApLFxuICAgIClcbiAgICBkZWJ1Zy5pbmZvKFxuICAgICAgYE1vdmUgd2FzaSBicm93c2VyIHdvcmtlciBmaWxlIFske2NvbG9ycy55ZWxsb3dCcmlnaHQoXG4gICAgICAgIGJyb3dzZXJXb3JrZXJGaWxlLFxuICAgICAgKX1dIHRvIFske2NvbG9ycy55ZWxsb3dCcmlnaHQod2FzaURpcil9XWAsXG4gICAgKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgam9pbih3YXNpRGlyLCBgd2FzaS13b3JrZXItYnJvd3Nlci5tanNgKSxcbiAgICAgIGF3YWl0IHJlYWRGaWxlQXN5bmMoYnJvd3NlcldvcmtlckZpbGUpLFxuICAgIClcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb2xsZWN0Tm9kZUJpbmFyaWVzKHJvb3Q6IHN0cmluZykge1xuICBjb25zdCBmaWxlcyA9IGF3YWl0IHJlYWRkaXJBc3luYyhyb290LCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgY29uc3Qgbm9kZUJpbmFyaWVzID0gZmlsZXNcbiAgICAuZmlsdGVyKFxuICAgICAgKGZpbGUpID0+XG4gICAgICAgIGZpbGUuaXNGaWxlKCkgJiZcbiAgICAgICAgKGZpbGUubmFtZS5lbmRzV2l0aCgnLm5vZGUnKSB8fCBmaWxlLm5hbWUuZW5kc1dpdGgoJy53YXNtJykpLFxuICAgIClcbiAgICAubWFwKChmaWxlKSA9PiBqb2luKHJvb3QsIGZpbGUubmFtZSkpXG5cbiAgY29uc3QgZGlycyA9IGZpbGVzLmZpbHRlcigoZmlsZSkgPT4gZmlsZS5pc0RpcmVjdG9yeSgpKVxuICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgaWYgKGRpci5uYW1lICE9PSAnbm9kZV9tb2R1bGVzJykge1xuICAgICAgbm9kZUJpbmFyaWVzLnB1c2goLi4uKGF3YWl0IGNvbGxlY3ROb2RlQmluYXJpZXMoam9pbihyb290LCBkaXIubmFtZSkpKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVCaW5hcmllc1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNqc0JpbmRpbmcoXG4gIGxvY2FsTmFtZTogc3RyaW5nLFxuICBwa2dOYW1lOiBzdHJpbmcsXG4gIGlkZW50czogc3RyaW5nW10sXG4gIHBhY2thZ2VWZXJzaW9uPzogc3RyaW5nLFxuKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke2JpbmRpbmdIZWFkZXJ9XG4ke2NyZWF0ZUNvbW1vbkJpbmRpbmcobG9jYWxOYW1lLCBwa2dOYW1lLCBwYWNrYWdlVmVyc2lvbil9XG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUJpbmRpbmdcbiR7aWRlbnRzXG4gIC5tYXAoKGlkZW50KSA9PiBgbW9kdWxlLmV4cG9ydHMuJHtpZGVudH0gPSBuYXRpdmVCaW5kaW5nLiR7aWRlbnR9YClcbiAgLmpvaW4oJ1xcbicpfVxuYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXNtQmluZGluZyhcbiAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gIHBrZ05hbWU6IHN0cmluZyxcbiAgaWRlbnRzOiBzdHJpbmdbXSxcbiAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICByZXR1cm4gYCR7YmluZGluZ0hlYWRlcn1cbmltcG9ydCB7IGNyZWF0ZVJlcXVpcmUgfSBmcm9tICdub2RlOm1vZHVsZSdcbmNvbnN0IHJlcXVpcmUgPSBjcmVhdGVSZXF1aXJlKGltcG9ydC5tZXRhLnVybClcbmNvbnN0IF9fZGlybmFtZSA9IG5ldyBVUkwoJy4nLCBpbXBvcnQubWV0YS51cmwpLnBhdGhuYW1lXG5cbiR7Y3JlYXRlQ29tbW9uQmluZGluZyhsb2NhbE5hbWUsIHBrZ05hbWUsIHBhY2thZ2VWZXJzaW9uKX1cbmNvbnN0IHsgJHtpZGVudHMuam9pbignLCAnKX0gfSA9IG5hdGl2ZUJpbmRpbmdcbiR7aWRlbnRzLm1hcCgoaWRlbnQpID0+IGBleHBvcnQgeyAke2lkZW50fSB9YCkuam9pbignXFxuJyl9XG5gXG59XG5cbmNvbnN0IGJpbmRpbmdIZWFkZXIgPSBgLy8gcHJldHRpZXItaWdub3JlXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gQHRzLW5vY2hlY2tcbi8qIGF1dG8tZ2VuZXJhdGVkIGJ5IE5BUEktUlMgKi9cbmBcblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uQmluZGluZyhcbiAgbG9jYWxOYW1lOiBzdHJpbmcsXG4gIHBrZ05hbWU6IHN0cmluZyxcbiAgcGFja2FnZVZlcnNpb24/OiBzdHJpbmcsXG4pOiBzdHJpbmcge1xuICBmdW5jdGlvbiByZXF1aXJlVHVwbGUodHVwbGU6IHN0cmluZywgaWRlbnRTaXplID0gOCkge1xuICAgIGNvbnN0IGlkZW50TG93ID0gJyAnLnJlcGVhdChpZGVudFNpemUgLSAyKVxuICAgIGNvbnN0IGlkZW50ID0gJyAnLnJlcGVhdChpZGVudFNpemUpXG4gICAgY29uc3QgdmVyc2lvbkNoZWNrID0gcGFja2FnZVZlcnNpb25cbiAgICAgID8gYFxuJHtpZGVudExvd310cnkge1xuJHtpZGVudH1jb25zdCBiaW5kaW5nID0gcmVxdWlyZSgnJHtwa2dOYW1lfS0ke3R1cGxlfScpXG4ke2lkZW50fWNvbnN0IGJpbmRpbmdQYWNrYWdlVmVyc2lvbiA9IHJlcXVpcmUoJyR7cGtnTmFtZX0tJHt0dXBsZX0vcGFja2FnZS5qc29uJykudmVyc2lvblxuJHtpZGVudH1pZiAoYmluZGluZ1BhY2thZ2VWZXJzaW9uICE9PSAnJHtwYWNrYWdlVmVyc2lvbn0nICYmIHByb2Nlc3MuZW52Lk5BUElfUlNfRU5GT1JDRV9WRVJTSU9OX0NIRUNLICYmIHByb2Nlc3MuZW52Lk5BUElfUlNfRU5GT1JDRV9WRVJTSU9OX0NIRUNLICE9PSAnMCcpIHtcbiR7aWRlbnR9ICB0aHJvdyBuZXcgRXJyb3IoXFxgTmF0aXZlIGJpbmRpbmcgcGFja2FnZSB2ZXJzaW9uIG1pc21hdGNoLCBleHBlY3RlZCAke3BhY2thZ2VWZXJzaW9ufSBidXQgZ290IFxcJHtiaW5kaW5nUGFja2FnZVZlcnNpb259LiBZb3UgY2FuIHJlaW5zdGFsbCBkZXBlbmRlbmNpZXMgdG8gZml4IHRoaXMgaXNzdWUuXFxgKVxuJHtpZGVudH19XG4ke2lkZW50fXJldHVybiBiaW5kaW5nXG4ke2lkZW50TG93fX0gY2F0Y2ggKGUpIHtcbiR7aWRlbnR9bG9hZEVycm9ycy5wdXNoKGUpXG4ke2lkZW50TG93fX1gXG4gICAgICA6IGBcbiR7aWRlbnRMb3d9dHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJyR7cGtnTmFtZX0tJHt0dXBsZX0nKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319YFxuICAgIHJldHVybiBgdHJ5IHtcbiR7aWRlbnR9cmV0dXJuIHJlcXVpcmUoJy4vJHtsb2NhbE5hbWV9LiR7dHVwbGV9Lm5vZGUnKVxuJHtpZGVudExvd319IGNhdGNoIChlKSB7XG4ke2lkZW50fWxvYWRFcnJvcnMucHVzaChlKVxuJHtpZGVudExvd319JHt2ZXJzaW9uQ2hlY2t9YFxuICB9XG5cbiAgcmV0dXJuIGBjb25zdCB7IHJlYWRGaWxlU3luYyB9ID0gcmVxdWlyZSgnbm9kZTpmcycpXG5sZXQgbmF0aXZlQmluZGluZyA9IG51bGxcbmNvbnN0IGxvYWRFcnJvcnMgPSBbXVxuXG5jb25zdCBpc011c2wgPSAoKSA9PiB7XG4gIGxldCBtdXNsID0gZmFsc2VcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBtdXNsID0gaXNNdXNsRnJvbUZpbGVzeXN0ZW0oKVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbVJlcG9ydCgpXG4gICAgfVxuICAgIGlmIChtdXNsID09PSBudWxsKSB7XG4gICAgICBtdXNsID0gaXNNdXNsRnJvbUNoaWxkUHJvY2VzcygpXG4gICAgfVxuICB9XG4gIHJldHVybiBtdXNsXG59XG5cbmNvbnN0IGlzRmlsZU11c2wgPSAoZikgPT4gZi5pbmNsdWRlcygnbGliYy5tdXNsLScpIHx8IGYuaW5jbHVkZXMoJ2xkLW11c2wtJylcblxuY29uc3QgaXNNdXNsRnJvbUZpbGVzeXN0ZW0gPSAoKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlYWRGaWxlU3luYygnL3Vzci9iaW4vbGRkJywgJ3V0Zi04JykuaW5jbHVkZXMoJ211c2wnKVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbmNvbnN0IGlzTXVzbEZyb21SZXBvcnQgPSAoKSA9PiB7XG4gIGxldCByZXBvcnQgPSBudWxsXG4gIGlmICh0eXBlb2YgcHJvY2Vzcy5yZXBvcnQ/LmdldFJlcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2Nlc3MucmVwb3J0LmV4Y2x1ZGVOZXR3b3JrID0gdHJ1ZVxuICAgIHJlcG9ydCA9IHByb2Nlc3MucmVwb3J0LmdldFJlcG9ydCgpXG4gIH1cbiAgaWYgKCFyZXBvcnQpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChyZXBvcnQuaGVhZGVyICYmIHJlcG9ydC5oZWFkZXIuZ2xpYmNWZXJzaW9uUnVudGltZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHJlcG9ydC5zaGFyZWRPYmplY3RzKSkge1xuICAgIGlmIChyZXBvcnQuc2hhcmVkT2JqZWN0cy5zb21lKGlzRmlsZU11c2wpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuY29uc3QgaXNNdXNsRnJvbUNoaWxkUHJvY2VzcyA9ICgpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWNTeW5jKCdsZGQgLS12ZXJzaW9uJywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pLmluY2x1ZGVzKCdtdXNsJylcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIHdlIHJlYWNoIHRoaXMgY2FzZSwgd2UgZG9uJ3Qga25vdyBpZiB0aGUgc3lzdGVtIGlzIG11c2wgb3Igbm90LCBzbyBpcyBiZXR0ZXIgdG8ganVzdCBmYWxsYmFjayB0byBmYWxzZVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVOYXRpdmUoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OQVBJX1JTX05BVElWRV9MSUJSQVJZX1BBVEgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHJlcXVpcmUocHJvY2Vzcy5lbnYuTkFQSV9SU19OQVRJVkVfTElCUkFSWV9QQVRIKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvYWRFcnJvcnMucHVzaChlcnIpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdhbmRyb2lkJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdhbmRyb2lkLWFybTY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm0nKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnYW5kcm9pZC1hcm0tZWFiaScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBBbmRyb2lkIFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICd4NjQnKSB7XG4gICAgICBpZiAocHJvY2Vzcy5jb25maWc/LnZhcmlhYmxlcz8uc2hsaWJfc3VmZml4ID09PSAnZGxsLmEnIHx8IHByb2Nlc3MuY29uZmlnPy52YXJpYWJsZXM/Lm5vZGVfdGFyZ2V0X3R5cGUgPT09ICdzaGFyZWRfbGlicmFyeScpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLXg2NC1nbnUnKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi14NjQtbXN2YycpfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnaWEzMicpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCd3aW4zMi1pYTMyLW1zdmMnKX1cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ2FybTY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ3dpbjMyLWFybTY0LW1zdmMnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gV2luZG93czogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJykge1xuICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4tdW5pdmVyc2FsJywgNil9XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4teDY0Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdkYXJ3aW4tYXJtNjQnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gbWFjT1M6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnKSB7XG4gICAgaWYgKHByb2Nlc3MuYXJjaCA9PT0gJ3g2NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdmcmVlYnNkLXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnZnJlZWJzZC1hcm02NCcpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBGcmVlQlNEOiBcXCR7cHJvY2Vzcy5hcmNofVxcYCkpXG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtbXVzbCcsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC14NjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtNjQnKSB7XG4gICAgICBpZiAoaXNNdXNsKCkpIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWFybTY0LW11c2wnLCAxMCl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtYXJtNjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgaWYgKGlzTXVzbCgpKSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm0tbXVzbGVhYmloZicsIDEwKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1hcm0tZ251ZWFiaWhmJywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnbG9vbmc2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtbG9vbmc2NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LWxvb25nNjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAncmlzY3Y2NCcpIHtcbiAgICAgIGlmIChpc011c2woKSkge1xuICAgICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcmlzY3Y2NC1tdXNsJywgMTApfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJHtyZXF1aXJlVHVwbGUoJ2xpbnV4LXJpc2N2NjQtZ251JywgMTApfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAncHBjNjQnKSB7XG4gICAgICAke3JlcXVpcmVUdXBsZSgnbGludXgtcHBjNjQtZ251Jyl9XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmFyY2ggPT09ICdzMzkweCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdsaW51eC1zMzkweC1nbnUnKX1cbiAgICB9IGVsc2Uge1xuICAgICAgbG9hZEVycm9ycy5wdXNoKG5ldyBFcnJvcihcXGBVbnN1cHBvcnRlZCBhcmNoaXRlY3R1cmUgb24gTGludXg6IFxcJHtwcm9jZXNzLmFyY2h9XFxgKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ29wZW5oYXJtb255Jykge1xuICAgIGlmIChwcm9jZXNzLmFyY2ggPT09ICdhcm02NCcpIHtcbiAgICAgICR7cmVxdWlyZVR1cGxlKCdvcGVuaGFybW9ueS1hcm02NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAneDY0Jykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ29wZW5oYXJtb255LXg2NCcpfVxuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5hcmNoID09PSAnYXJtJykge1xuICAgICAgJHtyZXF1aXJlVHVwbGUoJ29wZW5oYXJtb255LWFybScpfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIGFyY2hpdGVjdHVyZSBvbiBPcGVuSGFybW9ueTogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsb2FkRXJyb3JzLnB1c2gobmV3IEVycm9yKFxcYFVuc3VwcG9ydGVkIE9TOiBcXCR7cHJvY2Vzcy5wbGF0Zm9ybX0sIGFyY2hpdGVjdHVyZTogXFwke3Byb2Nlc3MuYXJjaH1cXGApKVxuICB9XG59XG5cbm5hdGl2ZUJpbmRpbmcgPSByZXF1aXJlTmF0aXZlKClcblxuaWYgKCFuYXRpdmVCaW5kaW5nIHx8IHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSkge1xuICBsZXQgd2FzaUJpbmRpbmcgPSBudWxsXG4gIGxldCB3YXNpQmluZGluZ0Vycm9yID0gbnVsbFxuICB0cnkge1xuICAgIHdhc2lCaW5kaW5nID0gcmVxdWlyZSgnLi8ke2xvY2FsTmFtZX0ud2FzaS5janMnKVxuICAgIG5hdGl2ZUJpbmRpbmcgPSB3YXNpQmluZGluZ1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gICAgICB3YXNpQmluZGluZ0Vycm9yID0gZXJyXG4gICAgfVxuICB9XG4gIGlmICghbmF0aXZlQmluZGluZykge1xuICAgIHRyeSB7XG4gICAgICB3YXNpQmluZGluZyA9IHJlcXVpcmUoJyR7cGtnTmFtZX0td2FzbTMyLXdhc2knKVxuICAgICAgbmF0aXZlQmluZGluZyA9IHdhc2lCaW5kaW5nXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTkFQSV9SU19GT1JDRV9XQVNJKSB7XG4gICAgICAgIHdhc2lCaW5kaW5nRXJyb3IuY2F1c2UgPSBlcnJcbiAgICAgICAgbG9hZEVycm9ycy5wdXNoKGVycilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5BUElfUlNfRk9SQ0VfV0FTSSA9PT0gJ2Vycm9yJyAmJiAhd2FzaUJpbmRpbmcpIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignV0FTSSBiaW5kaW5nIG5vdCBmb3VuZCBhbmQgTkFQSV9SU19GT1JDRV9XQVNJIGlzIHNldCB0byBlcnJvcicpXG4gICAgZXJyb3IuY2F1c2UgPSB3YXNpQmluZGluZ0Vycm9yXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG5pZiAoIW5hdGl2ZUJpbmRpbmcpIHtcbiAgaWYgKGxvYWRFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFxcYENhbm5vdCBmaW5kIG5hdGl2ZSBiaW5kaW5nLiBcXGAgK1xuICAgICAgICBcXGBucG0gaGFzIGEgYnVnIHJlbGF0ZWQgdG8gb3B0aW9uYWwgZGVwZW5kZW5jaWVzIChodHRwczovL2dpdGh1Yi5jb20vbnBtL2NsaS9pc3N1ZXMvNDgyOCkuIFxcYCArXG4gICAgICAgICdQbGVhc2UgdHJ5IFxcYG5wbSBpXFxgIGFnYWluIGFmdGVyIHJlbW92aW5nIGJvdGggcGFja2FnZS1sb2NrLmpzb24gYW5kIG5vZGVfbW9kdWxlcyBkaXJlY3RvcnkuJyxcbiAgICAgIHtcbiAgICAgICAgY2F1c2U6IGxvYWRFcnJvcnMucmVkdWNlKChlcnIsIGN1cikgPT4ge1xuICAgICAgICAgIGN1ci5jYXVzZSA9IGVyclxuICAgICAgICAgIHJldHVybiBjdXJcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgIClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXFxgRmFpbGVkIHRvIGxvYWQgbmF0aXZlIGJpbmRpbmdcXGApXG59XG5gXG59XG4iLCJleHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJCaW5kaW5nID0gKFxuICB3YXNpRmlsZW5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbiAgZnMgPSBmYWxzZSxcbiAgYXN5bmNJbml0ID0gZmFsc2UsXG4gIGJ1ZmZlciA9IGZhbHNlLFxuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGJ1ZmZlclxuICAgICAgPyBgaW1wb3J0IHsgbWVtZnMsIEJ1ZmZlciB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgICA6IGBpbXBvcnQgeyBtZW1mcyB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZS9mcydgXG4gICAgOiAnJ1xuICBjb25zdCBidWZmZXJJbXBvcnQgPSBidWZmZXIgJiYgIWZzID8gYGltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcidgIDogJydcbiAgY29uc3Qgd2FzaUNyZWF0aW9uID0gZnNcbiAgICA/IGBcbmV4cG9ydCBjb25zdCB7IGZzOiBfX2ZzLCB2b2w6IF9fdm9sdW1lIH0gPSBtZW1mcygpXG5cbmNvbnN0IF9fd2FzaSA9IG5ldyBfX1dBU0koe1xuICB2ZXJzaW9uOiAncHJldmlldzEnLFxuICBmczogX19mcyxcbiAgcHJlb3BlbnM6IHtcbiAgICAnLyc6ICcvJyxcbiAgfSxcbn0pYFxuICAgIDogYFxuY29uc3QgX193YXNpID0gbmV3IF9fV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG59KWBcblxuICBjb25zdCB3b3JrZXJGc0hhbmRsZXIgPSBmc1xuICAgID8gYCAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHkoX19mcykpXFxuYFxuICAgIDogJydcblxuICBjb25zdCBlbW5hcGlJbmplY3RCdWZmZXIgPSBidWZmZXJcbiAgICA/ICdfX2VtbmFwaUNvbnRleHQuZmVhdHVyZS5CdWZmZXIgPSBCdWZmZXInXG4gICAgOiAnJ1xuICBjb25zdCBlbW5hcGlJbnN0YW50aWF0ZUltcG9ydCA9IGFzeW5jSW5pdFxuICAgID8gYGluc3RhbnRpYXRlTmFwaU1vZHVsZSBhcyBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZWBcbiAgICA6IGBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jIGFzIF9fZW1uYXBpSW5zdGFudGlhdGVOYXBpTW9kdWxlU3luY2BcbiAgY29uc3QgZW1uYXBpSW5zdGFudGlhdGVDYWxsID0gYXN5bmNJbml0XG4gICAgPyBgYXdhaXQgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVgXG4gICAgOiBgX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jYFxuXG4gIHJldHVybiBgaW1wb3J0IHtcbiAgY3JlYXRlT25NZXNzYWdlIGFzIF9fd2FzbUNyZWF0ZU9uTWVzc2FnZUZvckZzUHJveHksXG4gIGdldERlZmF1bHRDb250ZXh0IGFzIF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQsXG4gICR7ZW1uYXBpSW5zdGFudGlhdGVJbXBvcnR9LFxuICBXQVNJIGFzIF9fV0FTSSxcbn0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lJ1xuJHtmc0ltcG9ydH1cbiR7YnVmZmVySW1wb3J0fVxuJHt3YXNpQ3JlYXRpb259XG5cbmNvbnN0IF9fd2FzbVVybCA9IG5ldyBVUkwoJy4vJHt3YXNpRmlsZW5hbWV9Lndhc20nLCBpbXBvcnQubWV0YS51cmwpLmhyZWZcbmNvbnN0IF9fZW1uYXBpQ29udGV4dCA9IF9fZW1uYXBpR2V0RGVmYXVsdENvbnRleHQoKVxuJHtlbW5hcGlJbmplY3RCdWZmZXJ9XG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmNvbnN0IF9fd2FzbUZpbGUgPSBhd2FpdCBmZXRjaChfX3dhc21VcmwpLnRoZW4oKHJlcykgPT4gcmVzLmFycmF5QnVmZmVyKCkpXG5cbmNvbnN0IHtcbiAgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLFxuICBtb2R1bGU6IF9fd2FzaU1vZHVsZSxcbiAgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlLFxufSA9ICR7ZW1uYXBpSW5zdGFudGlhdGVDYWxsfShfX3dhc21GaWxlLCB7XG4gIGNvbnRleHQ6IF9fZW1uYXBpQ29udGV4dCxcbiAgYXN5bmNXb3JrUG9vbFNpemU6IDQsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dhc2ktd29ya2VyLWJyb3dzZXIubWpzJywgaW1wb3J0Lm1ldGEudXJsKSwge1xuICAgICAgdHlwZTogJ21vZHVsZScsXG4gICAgfSlcbiR7d29ya2VyRnNIYW5kbGVyfVxuICAgIHJldHVybiB3b3JrZXJcbiAgfSxcbiAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICBpbXBvcnRPYmplY3QuZW52ID0ge1xuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgLi4uaW1wb3J0T2JqZWN0LmVtbmFwaSxcbiAgICAgIG1lbW9yeTogX19zaGFyZWRNZW1vcnksXG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRPYmplY3RcbiAgfSxcbiAgYmVmb3JlSW5pdCh7IGluc3RhbmNlIH0pIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoaW5zdGFuY2UuZXhwb3J0cykpIHtcbiAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ19fbmFwaV9yZWdpc3Rlcl9fJykpIHtcbiAgICAgICAgaW5zdGFuY2UuZXhwb3J0c1tuYW1lXSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxufSlcbmBcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVdhc2lCaW5kaW5nID0gKFxuICB3YXNtRmlsZU5hbWU6IHN0cmluZyxcbiAgcGFja2FnZU5hbWU6IHN0cmluZyxcbiAgaW5pdGlhbE1lbW9yeSA9IDQwMDAsXG4gIG1heGltdW1NZW1vcnkgPSA2NTUzNixcbikgPT4gYC8qIGVzbGludC1kaXNhYmxlICovXG4vKiBwcmV0dGllci1pZ25vcmUgKi9cblxuLyogYXV0by1nZW5lcmF0ZWQgYnkgTkFQSS1SUyAqL1xuXG5jb25zdCBfX25vZGVGcyA9IHJlcXVpcmUoJ25vZGU6ZnMnKVxuY29uc3QgX19ub2RlUGF0aCA9IHJlcXVpcmUoJ25vZGU6cGF0aCcpXG5jb25zdCB7IFdBU0k6IF9fbm9kZVdBU0kgfSA9IHJlcXVpcmUoJ25vZGU6d2FzaScpXG5jb25zdCB7IFdvcmtlciB9ID0gcmVxdWlyZSgnbm9kZTp3b3JrZXJfdGhyZWFkcycpXG5cbmNvbnN0IHtcbiAgY3JlYXRlT25NZXNzYWdlOiBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5LFxuICBnZXREZWZhdWx0Q29udGV4dDogX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCxcbiAgaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYzogX19lbW5hcGlJbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLFxufSA9IHJlcXVpcmUoJ0BuYXBpLXJzL3dhc20tcnVudGltZScpXG5cbmNvbnN0IF9fcm9vdERpciA9IF9fbm9kZVBhdGgucGFyc2UocHJvY2Vzcy5jd2QoKSkucm9vdFxuXG5jb25zdCBfX3dhc2kgPSBuZXcgX19ub2RlV0FTSSh7XG4gIHZlcnNpb246ICdwcmV2aWV3MScsXG4gIGVudjogcHJvY2Vzcy5lbnYsXG4gIHByZW9wZW5zOiB7XG4gICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgfVxufSlcblxuY29uc3QgX19lbW5hcGlDb250ZXh0ID0gX19lbW5hcGlHZXREZWZhdWx0Q29udGV4dCgpXG5cbmNvbnN0IF9fc2hhcmVkTWVtb3J5ID0gbmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7XG4gIGluaXRpYWw6ICR7aW5pdGlhbE1lbW9yeX0sXG4gIG1heGltdW06ICR7bWF4aW11bU1lbW9yeX0sXG4gIHNoYXJlZDogdHJ1ZSxcbn0pXG5cbmxldCBfX3dhc21GaWxlUGF0aCA9IF9fbm9kZVBhdGguam9pbihfX2Rpcm5hbWUsICcke3dhc21GaWxlTmFtZX0ud2FzbScpXG5jb25zdCBfX3dhc21EZWJ1Z0ZpbGVQYXRoID0gX19ub2RlUGF0aC5qb2luKF9fZGlybmFtZSwgJyR7d2FzbUZpbGVOYW1lfS5kZWJ1Zy53YXNtJylcblxuaWYgKF9fbm9kZUZzLmV4aXN0c1N5bmMoX193YXNtRGVidWdGaWxlUGF0aCkpIHtcbiAgX193YXNtRmlsZVBhdGggPSBfX3dhc21EZWJ1Z0ZpbGVQYXRoXG59IGVsc2UgaWYgKCFfX25vZGVGcy5leGlzdHNTeW5jKF9fd2FzbUZpbGVQYXRoKSkge1xuICB0cnkge1xuICAgIF9fd2FzbUZpbGVQYXRoID0gX19ub2RlUGF0aC5yZXNvbHZlKCcke3BhY2thZ2VOYW1lfS13YXNtMzItd2FzaScpXG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgJHt3YXNtRmlsZU5hbWV9Lndhc20gZmlsZSwgYW5kICR7cGFja2FnZU5hbWV9LXdhc20zMi13YXNpIHBhY2thZ2UgaXMgbm90IGluc3RhbGxlZC4nKVxuICB9XG59XG5cbmNvbnN0IHsgaW5zdGFuY2U6IF9fbmFwaUluc3RhbmNlLCBtb2R1bGU6IF9fd2FzaU1vZHVsZSwgbmFwaU1vZHVsZTogX19uYXBpTW9kdWxlIH0gPSBfX2VtbmFwaUluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMoX19ub2RlRnMucmVhZEZpbGVTeW5jKF9fd2FzbUZpbGVQYXRoKSwge1xuICBjb250ZXh0OiBfX2VtbmFwaUNvbnRleHQsXG4gIGFzeW5jV29ya1Bvb2xTaXplOiAoZnVuY3Rpb24oKSB7XG4gICAgY29uc3QgdGhyZWFkc1NpemVGcm9tRW52ID0gTnVtYmVyKHByb2Nlc3MuZW52Lk5BUElfUlNfQVNZTkNfV09SS19QT09MX1NJWkUgPz8gcHJvY2Vzcy5lbnYuVVZfVEhSRUFEUE9PTF9TSVpFKVxuICAgIC8vIE5hTiA+IDAgaXMgZmFsc2VcbiAgICBpZiAodGhyZWFkc1NpemVGcm9tRW52ID4gMCkge1xuICAgICAgcmV0dXJuIHRocmVhZHNTaXplRnJvbUVudlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNFxuICAgIH1cbiAgfSkoKSxcbiAgcmV1c2VXb3JrZXI6IHRydWUsXG4gIHdhc2k6IF9fd2FzaSxcbiAgb25DcmVhdGVXb3JrZXIoKSB7XG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihfX25vZGVQYXRoLmpvaW4oX19kaXJuYW1lLCAnd2FzaS13b3JrZXIubWpzJyksIHtcbiAgICAgIGVudjogcHJvY2Vzcy5lbnYsXG4gICAgfSlcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICBfX3dhc21DcmVhdGVPbk1lc3NhZ2VGb3JGc1Byb3h5KF9fbm9kZUZzKShkYXRhKVxuICAgIH1cblxuICAgIC8vIFRoZSBtYWluIHRocmVhZCBvZiBOb2RlLmpzIHdhaXRzIGZvciBhbGwgdGhlIGFjdGl2ZSBoYW5kbGVzIGJlZm9yZSBleGl0aW5nLlxuICAgIC8vIEJ1dCBSdXN0IHRocmVhZHMgYXJlIG5ldmVyIHdhaXRlZCB3aXRob3V0IFxcYHRocmVhZDo6am9pblxcYC5cbiAgICAvLyBTbyBoZXJlIHdlIGhhY2sgdGhlIGNvZGUgb2YgTm9kZS5qcyB0byBwcmV2ZW50IHRoZSB3b3JrZXJzIGZyb20gYmVpbmcgcmVmZXJlbmNlZCAoYWN0aXZlKS5cbiAgICAvLyBBY2NvcmRpbmcgdG8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvMTllMGQ0NzI3MjhjNzlkNDE4Yjc0YmRkZmY1ODhiZWE3MGE0MDNkMC9saWIvaW50ZXJuYWwvd29ya2VyLmpzI0w0MTUsXG4gICAgLy8gYSB3b3JrZXIgaXMgY29uc2lzdCBvZiB0d28gaGFuZGxlczoga1B1YmxpY1BvcnQgYW5kIGtIYW5kbGUuXG4gICAge1xuICAgICAgY29uc3Qga1B1YmxpY1BvcnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtQdWJsaWNQb3J0XCIpXG4gICAgICApO1xuICAgICAgaWYgKGtQdWJsaWNQb3J0KSB7XG4gICAgICAgIHdvcmtlcltrUHVibGljUG9ydF0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGtIYW5kbGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHdvcmtlcikuZmluZChzID0+XG4gICAgICAgIHMudG9TdHJpbmcoKS5pbmNsdWRlcyhcImtIYW5kbGVcIilcbiAgICAgICk7XG4gICAgICBpZiAoa0hhbmRsZSkge1xuICAgICAgICB3b3JrZXJba0hhbmRsZV0ucmVmID0gKCkgPT4ge307XG4gICAgICB9XG5cbiAgICAgIHdvcmtlci51bnJlZigpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya2VyXG4gIH0sXG4gIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbnYsXG4gICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICBtZW1vcnk6IF9fc2hhcmVkTWVtb3J5LFxuICAgIH1cbiAgICByZXR1cm4gaW1wb3J0T2JqZWN0XG4gIH0sXG4gIGJlZm9yZUluaXQoeyBpbnN0YW5jZSB9KSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGluc3RhbmNlLmV4cG9ydHMpKSB7XG4gICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdfX25hcGlfcmVnaXN0ZXJfXycpKSB7XG4gICAgICAgIGluc3RhbmNlLmV4cG9ydHNbbmFtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn0pXG5gXG4iLCJleHBvcnQgY29uc3QgV0FTSV9XT1JLRVJfVEVNUExBVEUgPSBgaW1wb3J0IGZzIGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IFdBU0kgfSBmcm9tIFwibm9kZTp3YXNpXCI7XG5pbXBvcnQgeyBwYXJlbnRQb3J0LCBXb3JrZXIgfSBmcm9tIFwibm9kZTp3b3JrZXJfdGhyZWFkc1wiO1xuXG5jb25zdCByZXF1aXJlID0gY3JlYXRlUmVxdWlyZShpbXBvcnQubWV0YS51cmwpO1xuXG5jb25zdCB7IGluc3RhbnRpYXRlTmFwaU1vZHVsZVN5bmMsIE1lc3NhZ2VIYW5kbGVyLCBnZXREZWZhdWx0Q29udGV4dCB9ID0gcmVxdWlyZShcIkBuYXBpLXJzL3dhc20tcnVudGltZVwiKTtcblxuaWYgKHBhcmVudFBvcnQpIHtcbiAgcGFyZW50UG9ydC5vbihcIm1lc3NhZ2VcIiwgKGRhdGEpID0+IHtcbiAgICBnbG9iYWxUaGlzLm9ubWVzc2FnZSh7IGRhdGEgfSk7XG4gIH0pO1xufVxuXG5PYmplY3QuYXNzaWduKGdsb2JhbFRoaXMsIHtcbiAgc2VsZjogZ2xvYmFsVGhpcyxcbiAgcmVxdWlyZSxcbiAgV29ya2VyLFxuICBpbXBvcnRTY3JpcHRzOiBmdW5jdGlvbiAoZikge1xuICAgIDsoMCwgZXZhbCkoZnMucmVhZEZpbGVTeW5jKGYsIFwidXRmOFwiKSArIFwiLy8jIHNvdXJjZVVSTD1cIiArIGYpO1xuICB9LFxuICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gKG1zZykge1xuICAgIGlmIChwYXJlbnRQb3J0KSB7XG4gICAgICBwYXJlbnRQb3J0LnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9LFxufSk7XG5cbmNvbnN0IGVtbmFwaUNvbnRleHQgPSBnZXREZWZhdWx0Q29udGV4dCgpO1xuXG5jb25zdCBfX3Jvb3REaXIgPSBwYXJzZShwcm9jZXNzLmN3ZCgpKS5yb290O1xuXG5jb25zdCBoYW5kbGVyID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHtcbiAgb25Mb2FkKHsgd2FzbU1vZHVsZSwgd2FzbU1lbW9yeSB9KSB7XG4gICAgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIHZlcnNpb246ICdwcmV2aWV3MScsXG4gICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgW19fcm9vdERpcl06IF9fcm9vdERpcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gaW5zdGFudGlhdGVOYXBpTW9kdWxlU3luYyh3YXNtTW9kdWxlLCB7XG4gICAgICBjaGlsZFRocmVhZDogdHJ1ZSxcbiAgICAgIHdhc2ksXG4gICAgICBjb250ZXh0OiBlbW5hcGlDb250ZXh0LFxuICAgICAgb3ZlcndyaXRlSW1wb3J0cyhpbXBvcnRPYmplY3QpIHtcbiAgICAgICAgaW1wb3J0T2JqZWN0LmVudiA9IHtcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW52LFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5uYXBpLFxuICAgICAgICAgIC4uLmltcG9ydE9iamVjdC5lbW5hcGksXG4gICAgICAgICAgbWVtb3J5OiB3YXNtTWVtb3J5XG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH0pO1xuICB9LFxufSk7XG5cbmdsb2JhbFRoaXMub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgaGFuZGxlci5oYW5kbGUoZSk7XG59O1xuYFxuXG5leHBvcnQgY29uc3QgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nID0gKGZzOiBib29sZWFuKSA9PiB7XG4gIGNvbnN0IGZzSW1wb3J0ID0gZnNcbiAgICA/IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSwgY3JlYXRlRnNQcm94eSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdcbmltcG9ydCB7IG1lbWZzRXhwb3J0ZWQgYXMgX19tZW1mc0V4cG9ydGVkIH0gZnJvbSAnQG5hcGktcnMvd2FzbS1ydW50aW1lL2ZzJ1xuXG5jb25zdCBmcyA9IGNyZWF0ZUZzUHJveHkoX19tZW1mc0V4cG9ydGVkKWBcbiAgICA6IGBpbXBvcnQgeyBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jLCBNZXNzYWdlSGFuZGxlciwgV0FTSSB9IGZyb20gJ0BuYXBpLXJzL3dhc20tcnVudGltZSdgXG4gIGNvbnN0IHdhc2lDcmVhdGlvbiA9IGZzXG4gICAgPyBgY29uc3Qgd2FzaSA9IG5ldyBXQVNJKHtcbiAgICAgIGZzLFxuICAgICAgcHJlb3BlbnM6IHtcbiAgICAgICAgJy8nOiAnLycsXG4gICAgICB9LFxuICAgICAgcHJpbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgfSxcbiAgICAgIHByaW50RXJyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgIH0pYFxuICAgIDogYGNvbnN0IHdhc2kgPSBuZXcgV0FTSSh7XG4gICAgICBwcmludDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICB9LFxuICAgICAgcHJpbnRFcnI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbiAgICAgIH0sXG4gICAgfSlgXG4gIHJldHVybiBgJHtmc0ltcG9ydH1cblxuY29uc3QgaGFuZGxlciA9IG5ldyBNZXNzYWdlSGFuZGxlcih7XG4gIG9uTG9hZCh7IHdhc21Nb2R1bGUsIHdhc21NZW1vcnkgfSkge1xuICAgICR7d2FzaUNyZWF0aW9ufVxuICAgIHJldHVybiBpbnN0YW50aWF0ZU5hcGlNb2R1bGVTeW5jKHdhc21Nb2R1bGUsIHtcbiAgICAgIGNoaWxkVGhyZWFkOiB0cnVlLFxuICAgICAgd2FzaSxcbiAgICAgIG92ZXJ3cml0ZUltcG9ydHMoaW1wb3J0T2JqZWN0KSB7XG4gICAgICAgIGltcG9ydE9iamVjdC5lbnYgPSB7XG4gICAgICAgICAgLi4uaW1wb3J0T2JqZWN0LmVudixcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QubmFwaSxcbiAgICAgICAgICAuLi5pbXBvcnRPYmplY3QuZW1uYXBpLFxuICAgICAgICAgIG1lbW9yeTogd2FzbU1lbW9yeSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9KVxuICB9LFxufSlcblxuZ2xvYmFsVGhpcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICBoYW5kbGVyLmhhbmRsZShlKVxufVxuYFxufVxuIiwiaW1wb3J0IHsgc3Bhd24gfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSAnbm9kZTpjcnlwdG8nXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJtU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSAnbm9kZTptb2R1bGUnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCB7IHBhcnNlLCBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgKiBhcyBjb2xvcnMgZnJvbSAnY29sb3JldHRlJ1xuXG5pbXBvcnQgdHlwZSB7IEJ1aWxkT3B0aW9ucyBhcyBSYXdCdWlsZE9wdGlvbnMgfSBmcm9tICcuLi9kZWYvYnVpbGQuanMnXG5pbXBvcnQge1xuICBDTElfVkVSU0lPTixcbiAgY29weUZpbGVBc3luYyxcbiAgdHlwZSBDcmF0ZSxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RZUEVfREVGX0hFQURFUixcbiAgZmlsZUV4aXN0cyxcbiAgZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCxcbiAgZ2V0VGFyZ2V0TGlua2VyLFxuICBta2RpckFzeW5jLFxuICB0eXBlIE5hcGlDb25maWcsXG4gIHBhcnNlTWV0YWRhdGEsXG4gIHBhcnNlVHJpcGxlLFxuICBwcm9jZXNzVHlwZURlZixcbiAgcmVhZEZpbGVBc3luYyxcbiAgcmVhZE5hcGlDb25maWcsXG4gIHR5cGUgVGFyZ2V0LFxuICB0YXJnZXRUb0VudlZhcixcbiAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5LFxuICB1bmxpbmtBc3luYyxcbiAgd3JpdGVGaWxlQXN5bmMsXG4gIGRpckV4aXN0c0FzeW5jLFxuICByZWFkZGlyQXN5bmMsXG4gIHR5cGUgQ2FyZ29Xb3Jrc3BhY2VNZXRhZGF0YSxcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5cbmltcG9ydCB7IGNyZWF0ZUNqc0JpbmRpbmcsIGNyZWF0ZUVzbUJpbmRpbmcgfSBmcm9tICcuL3RlbXBsYXRlcy9pbmRleC5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCaW5kaW5nLFxuICBjcmVhdGVXYXNpQnJvd3NlckJpbmRpbmcsXG59IGZyb20gJy4vdGVtcGxhdGVzL2xvYWQtd2FzaS10ZW1wbGF0ZS5qcydcbmltcG9ydCB7XG4gIGNyZWF0ZVdhc2lCcm93c2VyV29ya2VyQmluZGluZyxcbiAgV0FTSV9XT1JLRVJfVEVNUExBVEUsXG59IGZyb20gJy4vdGVtcGxhdGVzL3dhc2ktd29ya2VyLXRlbXBsYXRlLmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYnVpbGQnKVxuY29uc3QgcmVxdWlyZSA9IGNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKVxuXG50eXBlIE91dHB1dEtpbmQgPSAnanMnIHwgJ2R0cycgfCAnbm9kZScgfCAnZXhlJyB8ICd3YXNtJ1xudHlwZSBPdXRwdXQgPSB7IGtpbmQ6IE91dHB1dEtpbmQ7IHBhdGg6IHN0cmluZyB9XG5cbnR5cGUgQnVpbGRPcHRpb25zID0gUmF3QnVpbGRPcHRpb25zICYgeyBjYXJnb09wdGlvbnM/OiBzdHJpbmdbXSB9XG50eXBlIFBhcnNlZEJ1aWxkT3B0aW9ucyA9IE9taXQ8QnVpbGRPcHRpb25zLCAnY3dkJz4gJiB7IGN3ZDogc3RyaW5nIH1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUHJvamVjdChyYXdPcHRpb25zOiBCdWlsZE9wdGlvbnMpIHtcbiAgZGVidWcoJ25hcGkgYnVpbGQgY29tbWFuZCByZWNlaXZlIG9wdGlvbnM6ICVPJywgcmF3T3B0aW9ucylcblxuICBjb25zdCBvcHRpb25zOiBQYXJzZWRCdWlsZE9wdGlvbnMgPSB7XG4gICAgZHRzQ2FjaGU6IHRydWUsXG4gICAgLi4ucmF3T3B0aW9ucyxcbiAgICBjd2Q6IHJhd09wdGlvbnMuY3dkID8/IHByb2Nlc3MuY3dkKCksXG4gIH1cblxuICBjb25zdCByZXNvbHZlUGF0aCA9ICguLi5wYXRoczogc3RyaW5nW10pID0+IHJlc29sdmUob3B0aW9ucy5jd2QsIC4uLnBhdGhzKVxuXG4gIGNvbnN0IG1hbmlmZXN0UGF0aCA9IHJlc29sdmVQYXRoKG9wdGlvbnMubWFuaWZlc3RQYXRoID8/ICdDYXJnby50b21sJylcbiAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBwYXJzZU1ldGFkYXRhKG1hbmlmZXN0UGF0aClcblxuICBjb25zdCBjcmF0ZSA9IG1ldGFkYXRhLnBhY2thZ2VzLmZpbmQoKHApID0+IHtcbiAgICAvLyBwYWNrYWdlIHdpdGggZ2l2ZW4gbmFtZVxuICAgIGlmIChvcHRpb25zLnBhY2thZ2UpIHtcbiAgICAgIHJldHVybiBwLm5hbWUgPT09IG9wdGlvbnMucGFja2FnZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcC5tYW5pZmVzdF9wYXRoID09PSBtYW5pZmVzdFBhdGhcbiAgICB9XG4gIH0pXG5cbiAgaWYgKCFjcmF0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdVbmFibGUgdG8gZmluZCBjcmF0ZSB0byBidWlsZC4gSXQgc2VlbXMgeW91IGFyZSB0cnlpbmcgdG8gYnVpbGQgYSBjcmF0ZSBpbiBhIHdvcmtzcGFjZSwgdHJ5IHVzaW5nIGAtLXBhY2thZ2VgIG9wdGlvbiB0byBzcGVjaWZ5IHRoZSBwYWNrYWdlIHRvIGJ1aWxkLicsXG4gICAgKVxuICB9XG4gIGNvbnN0IGNvbmZpZyA9IGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgIHJlc29sdmVQYXRoKG9wdGlvbnMucGFja2FnZUpzb25QYXRoID8/ICdwYWNrYWdlLmpzb24nKSxcbiAgICBvcHRpb25zLmNvbmZpZ1BhdGggPyByZXNvbHZlUGF0aChvcHRpb25zLmNvbmZpZ1BhdGgpIDogdW5kZWZpbmVkLFxuICApXG5cbiAgY29uc3QgYnVpbGRlciA9IG5ldyBCdWlsZGVyKG1ldGFkYXRhLCBjcmF0ZSwgY29uZmlnLCBvcHRpb25zKVxuXG4gIHJldHVybiBidWlsZGVyLmJ1aWxkKClcbn1cblxuY2xhc3MgQnVpbGRlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXJnczogc3RyaW5nW10gPSBbXVxuICBwcml2YXRlIHJlYWRvbmx5IGVudnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dHM6IE91dHB1dFtdID0gW11cblxuICBwcml2YXRlIHJlYWRvbmx5IHRhcmdldDogVGFyZ2V0XG4gIHByaXZhdGUgcmVhZG9ubHkgY3JhdGVEaXI6IHN0cmluZ1xuICBwcml2YXRlIHJlYWRvbmx5IG91dHB1dERpcjogc3RyaW5nXG4gIHByaXZhdGUgcmVhZG9ubHkgdGFyZ2V0RGlyOiBzdHJpbmdcbiAgcHJpdmF0ZSByZWFkb25seSBlbmFibGVUeXBlRGVmOiBib29sZWFuID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IG1ldGFkYXRhOiBDYXJnb1dvcmtzcGFjZU1ldGFkYXRhLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY3JhdGU6IENyYXRlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29uZmlnOiBOYXBpQ29uZmlnLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3B0aW9uczogUGFyc2VkQnVpbGRPcHRpb25zLFxuICApIHtcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0XG4gICAgICA/IHBhcnNlVHJpcGxlKG9wdGlvbnMudGFyZ2V0KVxuICAgICAgOiBwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVRcbiAgICAgICAgPyBwYXJzZVRyaXBsZShwcm9jZXNzLmVudi5DQVJHT19CVUlMRF9UQVJHRVQpXG4gICAgICAgIDogZ2V0U3lzdGVtRGVmYXVsdFRhcmdldCgpXG4gICAgdGhpcy5jcmF0ZURpciA9IHBhcnNlKGNyYXRlLm1hbmlmZXN0X3BhdGgpLmRpclxuICAgIHRoaXMub3V0cHV0RGlyID0gcmVzb2x2ZShcbiAgICAgIHRoaXMub3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpciA/PyB0aGlzLmNyYXRlRGlyLFxuICAgIClcbiAgICB0aGlzLnRhcmdldERpciA9XG4gICAgICBvcHRpb25zLnRhcmdldERpciA/P1xuICAgICAgcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfVEFSR0VUX0RJUiA/P1xuICAgICAgbWV0YWRhdGEudGFyZ2V0X2RpcmVjdG9yeVxuICAgIHRoaXMuZW5hYmxlVHlwZURlZiA9IHRoaXMuY3JhdGUuZGVwZW5kZW5jaWVzLnNvbWUoXG4gICAgICAoZGVwKSA9PlxuICAgICAgICBkZXAubmFtZSA9PT0gJ25hcGktZGVyaXZlJyAmJlxuICAgICAgICAoZGVwLnVzZXNfZGVmYXVsdF9mZWF0dXJlcyB8fCBkZXAuZmVhdHVyZXMuaW5jbHVkZXMoJ3R5cGUtZGVmJykpLFxuICAgIClcblxuICAgIGlmICghdGhpcy5lbmFibGVUeXBlRGVmKSB7XG4gICAgICBjb25zdCByZXF1aXJlbWVudFdhcm5pbmcgPVxuICAgICAgICAnYG5hcGktZGVyaXZlYCBjcmF0ZSBpcyBub3QgdXNlZCBvciBgdHlwZS1kZWZgIGZlYXR1cmUgaXMgbm90IGVuYWJsZWQgZm9yIGBuYXBpLWRlcml2ZWAgY3JhdGUnXG4gICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBXaWxsIHNraXAgYmluZGluZyBnZW5lcmF0aW9uIGZvciBcXGAubm9kZVxcYCwgXFxgLndhc2lcXGAgYW5kIFxcYC5kLnRzXFxgIGZpbGVzLmAsXG4gICAgICApXG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5vcHRpb25zLmR0cyB8fFxuICAgICAgICB0aGlzLm9wdGlvbnMuZHRzSGVhZGVyIHx8XG4gICAgICAgIHRoaXMuY29uZmlnLmR0c0hlYWRlciB8fFxuICAgICAgICB0aGlzLmNvbmZpZy5kdHNIZWFkZXJGaWxlXG4gICAgICApIHtcbiAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICBgJHtyZXF1aXJlbWVudFdhcm5pbmd9LiBcXGBkdHNcXGAgcmVsYXRlZCBvcHRpb25zIGFyZSBlbmFibGVkIGJ1dCB3aWxsIGJlIGlnbm9yZWQuYCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBjZHlMaWJOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnY2R5bGliJykpXG4gICAgICA/Lm5hbWVcbiAgfVxuXG4gIGdldCBiaW5OYW1lKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLm9wdGlvbnMuYmluID8/XG4gICAgICAvLyBvbmx5IGF2YWlsYWJsZSBpZiBub3QgY2R5bGliIG9yIGJpbiBuYW1lIHNwZWNpZmllZFxuICAgICAgKHRoaXMuY2R5TGliTmFtZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiB0aGlzLmNyYXRlLnRhcmdldHMuZmluZCgodCkgPT4gdC5jcmF0ZV90eXBlcy5pbmNsdWRlcygnYmluJykpPy5uYW1lKVxuICAgIClcbiAgfVxuXG4gIGJ1aWxkKCkge1xuICAgIGlmICghdGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCB3YXJuaW5nID1cbiAgICAgICAgJ01pc3NpbmcgYGNyYXRlLXR5cGUgPSBbXCJjZHlsaWJcIl1gIGluIFtsaWJdIGNvbmZpZy4gVGhlIGJ1aWxkIHJlc3VsdCB3aWxsIG5vdCBiZSBhdmFpbGFibGUgYXMgbm9kZSBhZGRvbi4nXG5cbiAgICAgIGlmICh0aGlzLmJpbk5hbWUpIHtcbiAgICAgICAgZGVidWcud2Fybih3YXJuaW5nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHdhcm5pbmcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGlja0JpbmFyeSgpXG4gICAgICAuc2V0UGFja2FnZSgpXG4gICAgICAuc2V0RmVhdHVyZXMoKVxuICAgICAgLnNldFRhcmdldCgpXG4gICAgICAucGlja0Nyb3NzVG9vbGNoYWluKClcbiAgICAgIC5zZXRFbnZzKClcbiAgICAgIC5zZXRCeXBhc3NBcmdzKClcbiAgICAgIC5leGVjKClcbiAgfVxuXG4gIHByaXZhdGUgcGlja0Nyb3NzVG9vbGNoYWluKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU5hcGlDcm9zcykge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIHVzZSBib3RoIGAtLWNyb3NzYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLXVzZS1jcm9zc2Agd2lsbCBiZSBpZ25vcmVkLicsXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jcm9zc0NvbXBpbGUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICdZb3UgYXJlIHRyeWluZyB0byB1c2UgYm90aCBgLS1jcm9zcy1jb21waWxlYCBhbmQgYC0tdXNlLW5hcGktY3Jvc3NgIG9wdGlvbnMsIGAtLWNyb3NzLWNvbXBpbGVgIHdpbGwgYmUgaWdub3JlZC4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHZlcnNpb24sIGRvd25sb2FkIH0gPSByZXF1aXJlKCdAbmFwaS1ycy9jcm9zcy10b29sY2hhaW4nKVxuXG4gICAgICBjb25zdCBhbGlhczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JzogJ3MzOTB4LWlibS1saW51eC1nbnUnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0b29sY2hhaW5QYXRoID0gam9pbihcbiAgICAgICAgaG9tZWRpcigpLFxuICAgICAgICAnLm5hcGktcnMnLFxuICAgICAgICAnY3Jvc3MtdG9vbGNoYWluJyxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgdGhpcy50YXJnZXQudHJpcGxlLFxuICAgICAgKVxuICAgICAgbWtkaXJTeW5jKHRvb2xjaGFpblBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pXG4gICAgICBpZiAoZXhpc3RzU3luYyhqb2luKHRvb2xjaGFpblBhdGgsICdwYWNrYWdlLmpzb24nKSkpIHtcbiAgICAgICAgZGVidWcoYFRvb2xjaGFpbiAke3Rvb2xjaGFpblBhdGh9IGV4aXN0cywgc2tpcCBleHRyYWN0aW5nYClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhckFyY2hpdmUgPSBkb3dubG9hZChwcm9jZXNzLmFyY2gsIHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgICAgdGFyQXJjaGl2ZS51bnBhY2sodG9vbGNoYWluUGF0aClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwcGVyQ2FzZVRhcmdldCA9IHRhcmdldFRvRW52VmFyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAgIGNvbnN0IGNyb3NzVGFyZ2V0TmFtZSA9IGFsaWFzW3RoaXMudGFyZ2V0LnRyaXBsZV0gPz8gdGhpcy50YXJnZXQudHJpcGxlXG4gICAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dXBwZXJDYXNlVGFyZ2V0fV9MSU5LRVJgXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICBsaW5rZXJFbnYsXG4gICAgICAgIGpvaW4odG9vbGNoYWluUGF0aCwgJ2JpbicsIGAke2Nyb3NzVGFyZ2V0TmFtZX0tZ2NjYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1NZU1JPT1QnLFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsIGNyb3NzVGFyZ2V0TmFtZSwgJ3N5c3Jvb3QnKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQVInLFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsICdiaW4nLCBgJHtjcm9zc1RhcmdldE5hbWV9LWFyYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1JBTkxJQicsXG4gICAgICAgIGpvaW4odG9vbGNoYWluUGF0aCwgJ2JpbicsIGAke2Nyb3NzVGFyZ2V0TmFtZX0tcmFubGliYCksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1JFQURFTEYnLFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsICdiaW4nLCBgJHtjcm9zc1RhcmdldE5hbWV9LXJlYWRlbGZgKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ19JTkNMVURFX1BBVEgnLFxuICAgICAgICBqb2luKHRvb2xjaGFpblBhdGgsIGNyb3NzVGFyZ2V0TmFtZSwgJ3N5c3Jvb3QnLCAndXNyJywgJ2luY2x1ZGUvJyksXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NDJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCAnYmluJywgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nY2NgKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ1hYJyxcbiAgICAgICAgam9pbih0b29sY2hhaW5QYXRoLCAnYmluJywgYCR7Y3Jvc3NUYXJnZXROYW1lfS1nKytgKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdCSU5ER0VOX0VYVFJBX0NMQU5HX0FSR1MnLFxuICAgICAgICBgLS1zeXNyb290PSR7dGhpcy5lbnZzLlRBUkdFVF9TWVNST09UfX1gLFxuICAgICAgKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHByb2Nlc3MuZW52LlRBUkdFVF9DQz8uc3RhcnRzV2l0aCgnY2xhbmcnKSB8fFxuICAgICAgICAocHJvY2Vzcy5lbnYuQ0M/LnN0YXJ0c1dpdGgoJ2NsYW5nJykgJiYgIXByb2Nlc3MuZW52LlRBUkdFVF9DQylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBUQVJHRVRfQ0ZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NGTEFHUyA/PyAnJ1xuICAgICAgICB0aGlzLmVudnMuVEFSR0VUX0NGTEFHUyA9IGAtLXN5c3Jvb3Q9JHt0aGlzLmVudnMuVEFSR0VUX1NZU1JPT1R9IC0tZ2NjLXRvb2xjaGFpbj0ke3Rvb2xjaGFpblBhdGh9ICR7VEFSR0VUX0NGTEFHU31gXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIChwcm9jZXNzLmVudi5DWFg/LnN0YXJ0c1dpdGgoJ2NsYW5nKysnKSAmJiAhcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWCkgfHxcbiAgICAgICAgcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWD8uc3RhcnRzV2l0aCgnY2xhbmcrKycpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgVEFSR0VUX0NYWEZMQUdTID0gcHJvY2Vzcy5lbnYuVEFSR0VUX0NYWEZMQUdTID8/ICcnXG4gICAgICAgIHRoaXMuZW52cy5UQVJHRVRfQ1hYRkxBR1MgPSBgLS1zeXNyb290PSR7dGhpcy5lbnZzLlRBUkdFVF9TWVNST09UfSAtLWdjYy10b29sY2hhaW49JHt0b29sY2hhaW5QYXRofSAke1RBUkdFVF9DWFhGTEFHU31gXG4gICAgICB9XG4gICAgICB0aGlzLmVudnMuUEFUSCA9IHRoaXMuZW52cy5QQVRIXG4gICAgICAgID8gYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7dGhpcy5lbnZzLlBBVEh9OiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgICAgIDogYCR7dG9vbGNoYWluUGF0aH0vYmluOiR7cHJvY2Vzcy5lbnYuUEFUSH1gXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcud2FybignUGljayBjcm9zcyB0b29sY2hhaW4gZmFpbGVkJywgZSBhcyBFcnJvcilcbiAgICAgIC8vIGlnbm9yZSwgZG8gbm90aGluZ1xuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBleGVjKCkge1xuICAgIGRlYnVnKGBTdGFydCBidWlsZGluZyBjcmF0ZTogJHt0aGlzLmNyYXRlLm5hbWV9YClcbiAgICBkZWJ1ZygnICAlaScsIGBjYXJnbyAke3RoaXMuYXJncy5qb2luKCcgJyl9YClcblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcblxuICAgIGNvbnN0IHdhdGNoID0gdGhpcy5vcHRpb25zLndhdGNoXG4gICAgY29uc3QgYnVpbGRUYXNrID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VDcm9zcyAmJiB0aGlzLm9wdGlvbnMuY3Jvc3NDb21waWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnYC0tdXNlLWNyb3NzYCBhbmQgYC0tY3Jvc3MtY29tcGlsZWAgY2FuIG5vdCBiZSB1c2VkIHRvZ2V0aGVyJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgY29uc3QgY29tbWFuZCA9XG4gICAgICAgIHByb2Nlc3MuZW52LkNBUkdPID8/ICh0aGlzLm9wdGlvbnMudXNlQ3Jvc3MgPyAnY3Jvc3MnIDogJ2NhcmdvJylcbiAgICAgIGNvbnN0IGJ1aWxkUHJvY2VzcyA9IHNwYXduKGNvbW1hbmQsIHRoaXMuYXJncywge1xuICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLnRoaXMuZW52cyB9LFxuICAgICAgICBzdGRpbzogd2F0Y2ggPyBbJ2luaGVyaXQnLCAnaW5oZXJpdCcsICdwaXBlJ10gOiAnaW5oZXJpdCcsXG4gICAgICAgIGN3ZDogdGhpcy5vcHRpb25zLmN3ZCxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICBkZWJ1ZygnJWknLCBgQnVpbGQgY3JhdGUgJHt0aGlzLmNyYXRlLm5hbWV9IHN1Y2Nlc3NmdWxseSFgKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGV4aXQgY29kZSAke2NvZGV9YCkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGJ1aWxkUHJvY2Vzcy5vbmNlKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEJ1aWxkIGZhaWxlZCB3aXRoIGVycm9yOiAke2UubWVzc2FnZX1gLCB7IGNhdXNlOiBlIH0pKVxuICAgICAgfSlcblxuICAgICAgLy8gd2F0Y2ggbW9kZSBvbmx5LCB0aGV5IGFyZSBwaXBlZCB0aHJvdWdoIHN0ZGVyclxuICAgICAgYnVpbGRQcm9jZXNzLnN0ZGVycj8ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBkYXRhLnRvU3RyaW5nKClcbiAgICAgICAgY29uc29sZS5lcnJvcihvdXRwdXQpXG4gICAgICAgIGlmICgvRmluaXNoZWRcXHMoYGRldmB8YHJlbGVhc2VgKS8udGVzdChvdXRwdXQpKSB7XG4gICAgICAgICAgdGhpcy5wb3N0QnVpbGQoKS5jYXRjaCgoKSA9PiB7fSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRhc2s6IGJ1aWxkVGFzay50aGVuKCgpID0+IHRoaXMucG9zdEJ1aWxkKCkpLFxuICAgICAgYWJvcnQ6ICgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSxcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHBpY2tCaW5hcnkoKSB7XG4gICAgbGV0IHNldCA9IGZhbHNlXG4gICAgaWYgKHRoaXMub3B0aW9ucy53YXRjaCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52LkNJKSB7XG4gICAgICAgIGRlYnVnLndhcm4oJ1dhdGNoIG1vZGUgaXMgbm90IHN1cHBvcnRlZCBpbiBDSSBlbnZpcm9ubWVudCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXdhdGNoJylcbiAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby13YXRjaCcsICd3YXRjaCcpXG4gICAgICAgIC8vIHlhcm4gbmFwaSB3YXRjaCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnUgWy0tY3Jvc3MtY29tcGlsZV1cbiAgICAgICAgLy8gPT09PlxuICAgICAgICAvLyBjYXJnbyB3YXRjaCBbLi4uXSAtLSBidWlsZCAtLXRhcmdldCB4ODZfNjQtdW5rbm93bi1saW51eC1nbnVcbiAgICAgICAgLy8gY2FyZ28gd2F0Y2ggWy4uLl0gLS0gemlnYnVpbGQgLS10YXJnZXQgeDg2XzY0LXVua25vd24tbGludXgtZ251XG4gICAgICAgIHRoaXMuYXJncy5wdXNoKFxuICAgICAgICAgICd3YXRjaCcsXG4gICAgICAgICAgJy0td2h5JyxcbiAgICAgICAgICAnLWknLFxuICAgICAgICAgICcqLntqcyx0cyxub2RlfScsXG4gICAgICAgICAgJy13JyxcbiAgICAgICAgICB0aGlzLmNyYXRlRGlyLFxuICAgICAgICAgICctLScsXG4gICAgICAgICAgJ2NhcmdvJyxcbiAgICAgICAgICAnYnVpbGQnLFxuICAgICAgICApXG4gICAgICAgIHNldCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZSkge1xuICAgICAgaWYgKHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIHdpbjMyIHBsYXRmb3JtIG9uIHdpbjMyIHBsYXRmb3JtIHdoaWNoIGlzIHVubmVjZXNzYXJ5LicsXG4gICAgICAgICAgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVzZSBjYXJnby14d2luIHRvIGNyb3NzIGNvbXBpbGUgdG8gd2luMzIgcGxhdGZvcm1cbiAgICAgICAgICBkZWJ1ZygnVXNlICVpJywgJ2NhcmdvLXh3aW4nKVxuICAgICAgICAgIHRyeUluc3RhbGxDYXJnb0JpbmFyeSgnY2FyZ28teHdpbicsICd4d2luJylcbiAgICAgICAgICB0aGlzLmFyZ3MucHVzaCgneHdpbicsICdidWlsZCcpXG4gICAgICAgICAgaWYgKHRoaXMudGFyZ2V0LmFyY2ggPT09ICdpYTMyJykge1xuICAgICAgICAgICAgdGhpcy5lbnZzLlhXSU5fQVJDSCA9ICd4ODYnXG4gICAgICAgICAgfVxuICAgICAgICAgIHNldCA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnbGludXgnICYmXG4gICAgICAgICAgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJlxuICAgICAgICAgIHRoaXMudGFyZ2V0LmFyY2ggPT09IHByb2Nlc3MuYXJjaCAmJlxuICAgICAgICAgIChmdW5jdGlvbiAoYWJpOiBzdHJpbmcgfCBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBnbGliY1ZlcnNpb25SdW50aW1lID1cbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICBwcm9jZXNzLnJlcG9ydD8uZ2V0UmVwb3J0KCk/LmhlYWRlcj8uZ2xpYmNWZXJzaW9uUnVudGltZVxuICAgICAgICAgICAgY29uc3QgbGliYyA9IGdsaWJjVmVyc2lvblJ1bnRpbWUgPyAnZ251JyA6ICdtdXNsJ1xuICAgICAgICAgICAgcmV0dXJuIGFiaSA9PT0gbGliY1xuICAgICAgICAgIH0pKHRoaXMudGFyZ2V0LmFiaSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVidWcud2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHRyeWluZyB0byBjcm9zcyBjb21waWxlIHRvIGxpbnV4IHRhcmdldCBvbiBsaW51eCBwbGF0Zm9ybSB3aGljaCBpcyB1bm5lY2Vzc2FyeS4nLFxuICAgICAgICAgIClcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgJiZcbiAgICAgICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICApIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgJ1lvdSBhcmUgdHJ5aW5nIHRvIGNyb3NzIGNvbXBpbGUgdG8gZGFyd2luIHRhcmdldCBvbiBkYXJ3aW4gcGxhdGZvcm0gd2hpY2ggaXMgdW5uZWNlc3NhcnkuJyxcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXNlIGNhcmdvLXppZ2J1aWxkIHRvIGNyb3NzIGNvbXBpbGUgdG8gb3RoZXIgcGxhdGZvcm1zXG4gICAgICAgICAgZGVidWcoJ1VzZSAlaScsICdjYXJnby16aWdidWlsZCcpXG4gICAgICAgICAgdHJ5SW5zdGFsbENhcmdvQmluYXJ5KCdjYXJnby16aWdidWlsZCcsICd6aWdidWlsZCcpXG4gICAgICAgICAgdGhpcy5hcmdzLnB1c2goJ3ppZ2J1aWxkJylcbiAgICAgICAgICBzZXQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXNldCkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJ2J1aWxkJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0UGFja2FnZSgpIHtcbiAgICBjb25zdCBhcmdzID0gW11cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2FnZSkge1xuICAgICAgYXJncy5wdXNoKCctLXBhY2thZ2UnLCB0aGlzLm9wdGlvbnMucGFja2FnZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5iaW5OYW1lKSB7XG4gICAgICBhcmdzLnB1c2goJy0tYmluJywgdGhpcy5iaW5OYW1lKVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgZGVidWcoJ1NldCBwYWNrYWdlIGZsYWdzOiAnKVxuICAgICAgZGVidWcoJyAgJU8nLCBhcmdzKVxuICAgICAgdGhpcy5hcmdzLnB1c2goLi4uYXJncylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRUYXJnZXQoKSB7XG4gICAgZGVidWcoJ1NldCBjb21waWxpbmcgdGFyZ2V0IHRvOiAnKVxuICAgIGRlYnVnKCcgICVpJywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgdGhpcy5hcmdzLnB1c2goJy0tdGFyZ2V0JywgdGhpcy50YXJnZXQudHJpcGxlKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0RW52cygpIHtcbiAgICAvLyBUWVBFIERFRlxuICAgIGlmICh0aGlzLmVuYWJsZVR5cGVEZWYpIHtcbiAgICAgIHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIgPVxuICAgICAgICB0aGlzLmdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpXG4gICAgICB0aGlzLnNldEZvcmNlQnVpbGRFbnZzKHRoaXMuZW52cy5OQVBJX1RZUEVfREVGX1RNUF9GT0xERVIpXG4gICAgfVxuXG4gICAgLy8gUlVTVEZMQUdTXG4gICAgbGV0IHJ1c3RmbGFncyA9XG4gICAgICBwcm9jZXNzLmVudi5SVVNURkxBR1MgPz8gcHJvY2Vzcy5lbnYuQ0FSR09fQlVJTERfUlVTVEZMQUdTID8/ICcnXG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRhcmdldC5hYmk/LmluY2x1ZGVzKCdtdXNsJykgJiZcbiAgICAgICFydXN0ZmxhZ3MuaW5jbHVkZXMoJ3RhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJylcbiAgICApIHtcbiAgICAgIHJ1c3RmbGFncyArPSAnIC1DIHRhcmdldC1mZWF0dXJlPS1jcnQtc3RhdGljJ1xuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMuc3RyaXAgJiYgIXJ1c3RmbGFncy5pbmNsdWRlcygnbGluay1hcmc9LXMnKSkge1xuICAgICAgcnVzdGZsYWdzICs9ICcgLUMgbGluay1hcmc9LXMnXG4gICAgfVxuXG4gICAgaWYgKHJ1c3RmbGFncy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZW52cy5SVVNURkxBR1MgPSBydXN0ZmxhZ3NcbiAgICB9XG4gICAgLy8gRU5EIFJVU1RGTEFHU1xuXG4gICAgLy8gTElOS0VSXG4gICAgY29uc3QgbGlua2VyID0gdGhpcy5vcHRpb25zLmNyb3NzQ29tcGlsZVxuICAgICAgPyB2b2lkIDBcbiAgICAgIDogZ2V0VGFyZ2V0TGlua2VyKHRoaXMudGFyZ2V0LnRyaXBsZSlcbiAgICAvLyBUT0RPOlxuICAgIC8vICAgZGlyZWN0bHkgc2V0IENBUkdPX1RBUkdFVF88dGFyZ2V0Pl9MSU5LRVIgd2lsbCBjb3ZlciAuY2FyZ28vY29uZmlnLnRvbWxcbiAgICAvLyAgIHdpbGwgZGV0ZWN0IGJ5IGNhcmdvIGNvbmZpZyB3aGVuIGl0IGJlY29tZXMgc3RhYmxlXG4gICAgLy8gICBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ydXN0LWxhbmcvY2FyZ28vaXNzdWVzLzkzMDFcbiAgICBjb25zdCBsaW5rZXJFbnYgPSBgQ0FSR09fVEFSR0VUXyR7dGFyZ2V0VG9FbnZWYXIoXG4gICAgICB0aGlzLnRhcmdldC50cmlwbGUsXG4gICAgKX1fTElOS0VSYFxuICAgIGlmIChsaW5rZXIgJiYgIXByb2Nlc3MuZW52W2xpbmtlckVudl0gJiYgIXRoaXMuZW52c1tsaW5rZXJFbnZdKSB7XG4gICAgICB0aGlzLmVudnNbbGlua2VyRW52XSA9IGxpbmtlclxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSB7XG4gICAgICB0aGlzLnNldEFuZHJvaWRFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ3dhc2knKSB7XG4gICAgICB0aGlzLnNldFdhc2lFbnYoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRhcmdldC5wbGF0Zm9ybSA9PT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgdGhpcy5zZXRPcGVuSGFybW9ueUVudigpXG4gICAgfVxuXG4gICAgZGVidWcoJ1NldCBlbnZzOiAnKVxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW52cykuZm9yRWFjaCgoW2ssIHZdKSA9PiB7XG4gICAgICBkZWJ1ZygnICAlaScsIGAke2t9PSR7dn1gKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRGb3JjZUJ1aWxkRW52cyh0eXBlRGVmVG1wRm9sZGVyOiBzdHJpbmcpIHtcbiAgICAvLyBkeW5hbWljYWxseSBjaGVjayBhbGwgbmFwaS1ycyBkZXBzIGFuZCBzZXQgYE5BUElfRk9SQ0VfQlVJTERfe3VwcGVyY2FzZShzbmFrZV9jYXNlKG5hbWUpKX0gPSB0aW1lc3RhbXBgXG4gICAgdGhpcy5tZXRhZGF0YS5wYWNrYWdlcy5mb3JFYWNoKChjcmF0ZSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBjcmF0ZS5kZXBlbmRlbmNpZXMuc29tZSgoZCkgPT4gZC5uYW1lID09PSAnbmFwaS1kZXJpdmUnKSAmJlxuICAgICAgICAhZXhpc3RzU3luYyhqb2luKHR5cGVEZWZUbXBGb2xkZXIsIGNyYXRlLm5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuZW52c1tcbiAgICAgICAgICBgTkFQSV9GT1JDRV9CVUlMRF8ke2NyYXRlLm5hbWUucmVwbGFjZSgvLS9nLCAnXycpLnRvVXBwZXJDYXNlKCl9YFxuICAgICAgICBdID0gRGF0ZS5ub3coKS50b1N0cmluZygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgc2V0QW5kcm9pZEVudigpIHtcbiAgICBjb25zdCB7IEFORFJPSURfTkRLX0xBVEVTVF9IT01FIH0gPSBwcm9jZXNzLmVudlxuICAgIGlmICghQU5EUk9JRF9OREtfTEFURVNUX0hPTUUpIHtcbiAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgIGAke2NvbG9ycy5yZWQoXG4gICAgICAgICAgJ0FORFJPSURfTkRLX0xBVEVTVF9IT01FJyxcbiAgICAgICAgKX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZ2AsXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gc2tpcCBjcm9zcyBjb21waWxlIHNldHVwIGlmIGhvc3QgaXMgYW5kcm9pZFxuICAgIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnYW5kcm9pZCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldEFyY2ggPSB0aGlzLnRhcmdldC5hcmNoID09PSAnYXJtJyA/ICdhcm12N2EnIDogJ2FhcmNoNjQnXG4gICAgY29uc3QgdGFyZ2V0UGxhdGZvcm0gPVxuICAgICAgdGhpcy50YXJnZXQuYXJjaCA9PT0gJ2FybScgPyAnYW5kcm9pZGVhYmkyNCcgOiAnYW5kcm9pZDI0J1xuICAgIGNvbnN0IGhvc3RQbGF0Zm9ybSA9XG4gICAgICBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJ1xuICAgICAgICA/ICdkYXJ3aW4nXG4gICAgICAgIDogcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICAgICAgICAgID8gJ3dpbmRvd3MnXG4gICAgICAgICAgOiAnbGludXgnXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLmVudnMsIHtcbiAgICAgIENBUkdPX1RBUkdFVF9BQVJDSDY0X0xJTlVYX0FORFJPSURfTElOS0VSOiBgJHtBTkRST0lEX05ES19MQVRFU1RfSE9NRX0vdG9vbGNoYWlucy9sbHZtL3ByZWJ1aWx0LyR7aG9zdFBsYXRmb3JtfS14ODZfNjQvYmluLyR7dGFyZ2V0QXJjaH0tbGludXgtYW5kcm9pZDI0LWNsYW5nYCxcbiAgICAgIENBUkdPX1RBUkdFVF9BUk1WN19MSU5VWF9BTkRST0lERUFCSV9MSU5LRVI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC1hbmRyb2lkZWFiaTI0LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DQzogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi8ke3RhcmdldEFyY2h9LWxpbnV4LSR7dGFyZ2V0UGxhdGZvcm19LWNsYW5nYCxcbiAgICAgIFRBUkdFVF9DWFg6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vJHt0YXJnZXRBcmNofS1saW51eC0ke3RhcmdldFBsYXRmb3JtfS1jbGFuZysrYCxcbiAgICAgIFRBUkdFVF9BUjogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2Jpbi9sbHZtLWFyYCxcbiAgICAgIFRBUkdFVF9SQU5MSUI6IGAke0FORFJPSURfTkRLX0xBVEVTVF9IT01FfS90b29sY2hhaW5zL2xsdm0vcHJlYnVpbHQvJHtob3N0UGxhdGZvcm19LXg4Nl82NC9iaW4vbGx2bS1yYW5saWJgLFxuICAgICAgQU5EUk9JRF9OREs6IEFORFJPSURfTkRLX0xBVEVTVF9IT01FLFxuICAgICAgUEFUSDogYCR7QU5EUk9JRF9OREtfTEFURVNUX0hPTUV9L3Rvb2xjaGFpbnMvbGx2bS9wcmVidWlsdC8ke2hvc3RQbGF0Zm9ybX0teDg2XzY0L2JpbiR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YCxcbiAgICB9KVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRXYXNpRW52KCkge1xuICAgIGNvbnN0IGVtbmFwaSA9IGpvaW4oXG4gICAgICByZXF1aXJlLnJlc29sdmUoJ2VtbmFwaScpLFxuICAgICAgJy4uJyxcbiAgICAgICdsaWInLFxuICAgICAgJ3dhc20zMi13YXNpLXRocmVhZHMnLFxuICAgIClcbiAgICB0aGlzLmVudnMuRU1OQVBJX0xJTktfRElSID0gZW1uYXBpXG4gICAgY29uc3QgeyBXQVNJX1NES19QQVRIIH0gPSBwcm9jZXNzLmVudlxuXG4gICAgaWYgKFdBU0lfU0RLX1BBVEggJiYgZXhpc3RzU3luYyhXQVNJX1NES19QQVRIKSkge1xuICAgICAgdGhpcy5lbnZzLkNBUkdPX1RBUkdFVF9XQVNNMzJfV0FTSV9QUkVWSUVXMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDFfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuZW52cy5DQVJHT19UQVJHRVRfV0FTTTMyX1dBU0lQMV9USFJFQURTX0xJTktFUiA9IGpvaW4oXG4gICAgICAgIFdBU0lfU0RLX1BBVEgsXG4gICAgICAgICdiaW4nLFxuICAgICAgICAnd2FzbS1sZCcsXG4gICAgICApXG4gICAgICB0aGlzLmVudnMuQ0FSR09fVEFSR0VUX1dBU00zMl9XQVNJUDJfTElOS0VSID0gam9pbihcbiAgICAgICAgV0FTSV9TREtfUEFUSCxcbiAgICAgICAgJ2JpbicsXG4gICAgICAgICd3YXNtLWxkJyxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9DQycsIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdjbGFuZycpKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cyhcbiAgICAgICAgJ1RBUkdFVF9DWFgnLFxuICAgICAgICBqb2luKFdBU0lfU0RLX1BBVEgsICdiaW4nLCAnY2xhbmcrKycpLFxuICAgICAgKVxuICAgICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgam9pbihXQVNJX1NES19QQVRILCAnYmluJywgJ2FyJykpXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX1JBTkxJQicsXG4gICAgICAgIGpvaW4oV0FTSV9TREtfUEFUSCwgJ2JpbicsICdyYW5saWInKSxcbiAgICAgIClcbiAgICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoXG4gICAgICAgICdUQVJHRVRfQ0ZMQUdTJyxcbiAgICAgICAgYC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHMgLS1zeXNyb290PSR7V0FTSV9TREtfUEFUSH0vc2hhcmUvd2FzaS1zeXNyb290IC1wdGhyZWFkIC1tbGx2bSAtd2FzbS1lbmFibGUtc2psamAsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICAnVEFSR0VUX0NYWEZMQUdTJyxcbiAgICAgICAgYC0tdGFyZ2V0PXdhc20zMi13YXNpLXRocmVhZHMgLS1zeXNyb290PSR7V0FTSV9TREtfUEFUSH0vc2hhcmUvd2FzaS1zeXNyb290IC1wdGhyZWFkIC1tbGx2bSAtd2FzbS1lbmFibGUtc2psamAsXG4gICAgICApXG4gICAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKFxuICAgICAgICBgVEFSR0VUX0xERkxBR1NgLFxuICAgICAgICBgLWZ1c2UtbGQ9JHtXQVNJX1NES19QQVRIfS9iaW4vd2FzbS1sZCAtLXRhcmdldD13YXNtMzItd2FzaS10aHJlYWRzYCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldE9wZW5IYXJtb255RW52KCkge1xuICAgIGNvbnN0IHsgT0hPU19TREtfUEFUSCwgT0hPU19TREtfTkFUSVZFIH0gPSBwcm9jZXNzLmVudlxuICAgIGNvbnN0IG5ka1BhdGggPSBPSE9TX1NES19QQVRIID8gYCR7T0hPU19TREtfUEFUSH0vbmF0aXZlYCA6IE9IT1NfU0RLX05BVElWRVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoIW5ka1BhdGggJiYgcHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ29wZW5oYXJtb255Jykge1xuICAgICAgZGVidWcud2FybihcbiAgICAgICAgYCR7Y29sb3JzLnJlZCgnT0hPU19TREtfUEFUSCcpfSBvciAke2NvbG9ycy5yZWQoJ09IT1NfU0RLX05BVElWRScpfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBtaXNzaW5nYCxcbiAgICAgIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCBsaW5rZXJOYW1lID0gYENBUkdPX1RBUkdFVF8ke3RoaXMudGFyZ2V0LnRyaXBsZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKX1fTElOS0VSYFxuICAgIGNvbnN0IHJhblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLXJhbmxpYmBcbiAgICBjb25zdCBhclBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLWFyYFxuICAgIGNvbnN0IGNjUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluLyR7dGhpcy50YXJnZXQudHJpcGxlfS1jbGFuZ2BcbiAgICBjb25zdCBjeHhQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vJHt0aGlzLnRhcmdldC50cmlwbGV9LWNsYW5nKytgXG4gICAgY29uc3QgYXNQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1hc2BcbiAgICBjb25zdCBsZFBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sZC5sbGRgXG4gICAgY29uc3Qgc3RyaXBQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9iaW4vbGx2bS1zdHJpcGBcbiAgICBjb25zdCBvYmpEdW1wUGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqZHVtcGBcbiAgICBjb25zdCBvYmpDb3B5UGF0aCA9IGAke25ka1BhdGh9L2xsdm0vYmluL2xsdm0tb2JqY29weWBcbiAgICBjb25zdCBubVBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2Jpbi9sbHZtLW5tYFxuICAgIGNvbnN0IGJpblBhdGggPSBgJHtuZGtQYXRofS9sbHZtL2JpbmBcbiAgICBjb25zdCBsaWJQYXRoID0gYCR7bmRrUGF0aH0vbGx2bS9saWJgXG5cbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdMSUJDTEFOR19QQVRIJywgbGliUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdERVBfQVRPTUlDJywgJ2NsYW5nX3J0LmJ1aWx0aW5zJylcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKGxpbmtlck5hbWUsIGNjUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfQ0MnLCBjY1BhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0NYWCcsIGN4eFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX0FSJywgYXJQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9SQU5MSUInLCByYW5QYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9BUycsIGFzUGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTEQnLCBsZFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX1NUUklQJywgc3RyaXBQYXRoKVxuICAgIHRoaXMuc2V0RW52SWZOb3RFeGlzdHMoJ1RBUkdFVF9PQkpEVU1QJywgb2JqRHVtcFBhdGgpXG4gICAgdGhpcy5zZXRFbnZJZk5vdEV4aXN0cygnVEFSR0VUX09CSkNPUFknLCBvYmpDb3B5UGF0aClcbiAgICB0aGlzLnNldEVudklmTm90RXhpc3RzKCdUQVJHRVRfTk0nLCBubVBhdGgpXG4gICAgdGhpcy5lbnZzLlBBVEggPSBgJHtiaW5QYXRofSR7cHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyA/ICc7JyA6ICc6J30ke3Byb2Nlc3MuZW52LlBBVEh9YFxuICB9XG5cbiAgcHJpdmF0ZSBzZXRGZWF0dXJlcygpIHtcbiAgICBjb25zdCBhcmdzID0gW11cbiAgICBpZiAodGhpcy5vcHRpb25zLmFsbEZlYXR1cmVzICYmIHRoaXMub3B0aW9ucy5ub0RlZmF1bHRGZWF0dXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHNwZWNpZnkgLS1hbGwtZmVhdHVyZXMgYW5kIC0tbm8tZGVmYXVsdC1mZWF0dXJlcyB0b2dldGhlcicsXG4gICAgICApXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsRmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1hbGwtZmVhdHVyZXMnKVxuICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLm5vRGVmYXVsdEZlYXR1cmVzKSB7XG4gICAgICBhcmdzLnB1c2goJy0tbm8tZGVmYXVsdC1mZWF0dXJlcycpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wdGlvbnMuZmVhdHVyZXMpIHtcbiAgICAgIGFyZ3MucHVzaCgnLS1mZWF0dXJlcycsIC4uLnRoaXMub3B0aW9ucy5mZWF0dXJlcylcbiAgICB9XG5cbiAgICBkZWJ1ZygnU2V0IGZlYXR1cmVzIGZsYWdzOiAnKVxuICAgIGRlYnVnKCcgICVPJywgYXJncylcbiAgICB0aGlzLmFyZ3MucHVzaCguLi5hcmdzKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgc2V0QnlwYXNzQXJncygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbGVhc2UpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXJlbGVhc2UnKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tdmVyYm9zZScpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy50YXJnZXREaXIpIHtcbiAgICAgIHRoaXMuYXJncy5wdXNoKCctLXRhcmdldC1kaXInLCB0aGlzLm9wdGlvbnMudGFyZ2V0RGlyKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMucHJvZmlsZSkge1xuICAgICAgdGhpcy5hcmdzLnB1c2goJy0tcHJvZmlsZScsIHRoaXMub3B0aW9ucy5wcm9maWxlKVxuICAgIH1cblxuICAgIGlmICh0aGlzLm9wdGlvbnMubWFuaWZlc3RQYXRoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCgnLS1tYW5pZmVzdC1wYXRoJywgdGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmNhcmdvT3B0aW9ucz8ubGVuZ3RoKSB7XG4gICAgICB0aGlzLmFyZ3MucHVzaCguLi50aGlzLm9wdGlvbnMuY2FyZ29PcHRpb25zKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlSW50ZXJtZWRpYXRlVHlwZURlZkZvbGRlcigpIHtcbiAgICBsZXQgZm9sZGVyID0gam9pbihcbiAgICAgIHRoaXMudGFyZ2V0RGlyLFxuICAgICAgJ25hcGktcnMnLFxuICAgICAgYCR7dGhpcy5jcmF0ZS5uYW1lfS0ke2NyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAgIC51cGRhdGUodGhpcy5jcmF0ZS5tYW5pZmVzdF9wYXRoKVxuICAgICAgICAudXBkYXRlKENMSV9WRVJTSU9OKVxuICAgICAgICAuZGlnZXN0KCdoZXgnKVxuICAgICAgICAuc3Vic3RyaW5nKDAsIDgpfWAsXG4gICAgKVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZHRzQ2FjaGUpIHtcbiAgICAgIHJtU3luYyhmb2xkZXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KVxuICAgICAgZm9sZGVyICs9IGBfJHtEYXRlLm5vdygpfWBcbiAgICB9XG5cbiAgICBta2RpckFzeW5jKGZvbGRlciwgeyByZWN1cnNpdmU6IHRydWUgfSlcblxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcG9zdEJ1aWxkKCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5OmApXG4gICAgICBkZWJ1ZygnICAlaScsIHRoaXMub3V0cHV0RGlyKVxuICAgICAgYXdhaXQgbWtkaXJBc3luYyh0aGlzLm91dHB1dERpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIGRlYnVnKGBPdXRwdXQgZGlyZWN0b3J5IGNyZWF0ZWRgKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBvdXRwdXQgZGlyZWN0b3J5ICR7dGhpcy5vdXRwdXREaXJ9YCwge1xuICAgICAgICBjYXVzZTogZSxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgd2FzbUJpbmFyeU5hbWUgPSBhd2FpdCB0aGlzLmNvcHlBcnRpZmFjdCgpXG5cbiAgICAvLyBvbmx5IGZvciBjZHlsaWJcbiAgICBpZiAodGhpcy5jZHlMaWJOYW1lKSB7XG4gICAgICBjb25zdCBpZGVudHMgPSBhd2FpdCB0aGlzLmdlbmVyYXRlVHlwZURlZigpXG4gICAgICBjb25zdCBqc091dHB1dCA9IGF3YWl0IHRoaXMud3JpdGVKc0JpbmRpbmcoaWRlbnRzKVxuICAgICAgY29uc3Qgd2FzbUJpbmRpbmdzT3V0cHV0ID0gYXdhaXQgdGhpcy53cml0ZVdhc2lCaW5kaW5nKFxuICAgICAgICB3YXNtQmluYXJ5TmFtZSxcbiAgICAgICAgaWRlbnRzLFxuICAgICAgKVxuICAgICAgaWYgKGpzT3V0cHV0KSB7XG4gICAgICAgIHRoaXMub3V0cHV0cy5wdXNoKGpzT3V0cHV0KVxuICAgICAgfVxuICAgICAgaWYgKHdhc21CaW5kaW5nc091dHB1dCkge1xuICAgICAgICB0aGlzLm91dHB1dHMucHVzaCguLi53YXNtQmluZGluZ3NPdXRwdXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMub3V0cHV0c1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjb3B5QXJ0aWZhY3QoKSB7XG4gICAgY29uc3QgW3NyY05hbWUsIGRlc3ROYW1lLCB3YXNtQmluYXJ5TmFtZV0gPSB0aGlzLmdldEFydGlmYWN0TmFtZXMoKVxuICAgIGlmICghc3JjTmFtZSB8fCAhZGVzdE5hbWUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByb2ZpbGUgPVxuICAgICAgdGhpcy5vcHRpb25zLnByb2ZpbGUgPz8gKHRoaXMub3B0aW9ucy5yZWxlYXNlID8gJ3JlbGVhc2UnIDogJ2RlYnVnJylcbiAgICBjb25zdCBzcmMgPSBqb2luKHRoaXMudGFyZ2V0RGlyLCB0aGlzLnRhcmdldC50cmlwbGUsIHByb2ZpbGUsIHNyY05hbWUpXG4gICAgZGVidWcoYENvcHkgYXJ0aWZhY3QgZnJvbTogWyR7c3JjfV1gKVxuICAgIGNvbnN0IGRlc3QgPSBqb2luKHRoaXMub3V0cHV0RGlyLCBkZXN0TmFtZSlcbiAgICBjb25zdCBpc1dhc20gPSBkZXN0LmVuZHNXaXRoKCcud2FzbScpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoZGVzdCkpIHtcbiAgICAgICAgZGVidWcoJ09sZCBhcnRpZmFjdCBmb3VuZCwgcmVtb3ZlIGl0IGZpcnN0JylcbiAgICAgICAgYXdhaXQgdW5saW5rQXN5bmMoZGVzdClcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdDb3B5IGFydGlmYWN0IHRvOicpXG4gICAgICBkZWJ1ZygnICAlaScsIGRlc3QpXG4gICAgICBpZiAoaXNXYXNtKSB7XG4gICAgICAgIGNvbnN0IHsgTW9kdWxlQ29uZmlnIH0gPSBhd2FpdCBpbXBvcnQoJ0BuYXBpLXJzL3dhc20tdG9vbHMnKVxuICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgZGVidWcgd2FzbSBtb2R1bGUnKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbU1vZHVsZSA9IG5ldyBNb2R1bGVDb25maWcoKVxuICAgICAgICAgICAgLmdlbmVyYXRlRHdhcmYodHJ1ZSlcbiAgICAgICAgICAgIC5nZW5lcmF0ZU5hbWVTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKHRydWUpXG4gICAgICAgICAgICAucHJlc2VydmVDb2RlVHJhbnNmb3JtKHRydWUpXG4gICAgICAgICAgICAuc3RyaWN0VmFsaWRhdGUoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoYXdhaXQgcmVhZEZpbGVBc3luYyhzcmMpKVxuICAgICAgICAgIGNvbnN0IGRlYnVnV2FzbUJpbmFyeSA9IGRlYnVnV2FzbU1vZHVsZS5lbWl0V2FzbSh0cnVlKVxuICAgICAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICAgICAgZGVzdC5yZXBsYWNlKC9cXC53YXNtJC8sICcuZGVidWcud2FzbScpLFxuICAgICAgICAgICAgZGVidWdXYXNtQmluYXJ5LFxuICAgICAgICAgIClcbiAgICAgICAgICBkZWJ1ZygnR2VuZXJhdGUgcmVsZWFzZSB3YXNtIG1vZHVsZScpXG4gICAgICAgICAgY29uc3QgcmVsZWFzZVdhc21Nb2R1bGUgPSBuZXcgTW9kdWxlQ29uZmlnKClcbiAgICAgICAgICAgIC5nZW5lcmF0ZUR3YXJmKGZhbHNlKVxuICAgICAgICAgICAgLmdlbmVyYXRlTmFtZVNlY3Rpb24oZmFsc2UpXG4gICAgICAgICAgICAuZ2VuZXJhdGVQcm9kdWNlcnNTZWN0aW9uKGZhbHNlKVxuICAgICAgICAgICAgLnByZXNlcnZlQ29kZVRyYW5zZm9ybShmYWxzZSlcbiAgICAgICAgICAgIC5zdHJpY3RWYWxpZGF0ZShmYWxzZSlcbiAgICAgICAgICAgIC5vbmx5U3RhYmxlRmVhdHVyZXMoZmFsc2UpXG4gICAgICAgICAgICAucGFyc2UoZGVidWdXYXNtQmluYXJ5KVxuICAgICAgICAgIGNvbnN0IHJlbGVhc2VXYXNtQmluYXJ5ID0gcmVsZWFzZVdhc21Nb2R1bGUuZW1pdFdhc20oZmFsc2UpXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoZGVzdCwgcmVsZWFzZVdhc21CaW5hcnkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1Zy53YXJuKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZW5lcmF0ZSBkZWJ1ZyB3YXNtIG1vZHVsZTogJHsoZSBhcyBhbnkpLm1lc3NhZ2UgPz8gZX1gLFxuICAgICAgICAgIClcbiAgICAgICAgICBhd2FpdCBjb3B5RmlsZUFzeW5jKHNyYywgZGVzdClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgY29weUZpbGVBc3luYyhzcmMsIGRlc3QpXG4gICAgICB9XG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7XG4gICAgICAgIGtpbmQ6IGRlc3QuZW5kc1dpdGgoJy5ub2RlJykgPyAnbm9kZScgOiBpc1dhc20gPyAnd2FzbScgOiAnZXhlJyxcbiAgICAgICAgcGF0aDogZGVzdCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gd2FzbUJpbmFyeU5hbWUgPyBqb2luKHRoaXMub3V0cHV0RGlyLCB3YXNtQmluYXJ5TmFtZSkgOiBudWxsXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29weSBhcnRpZmFjdCcsIHsgY2F1c2U6IGUgfSlcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGdldEFydGlmYWN0TmFtZXMoKSB7XG4gICAgaWYgKHRoaXMuY2R5TGliTmFtZSkge1xuICAgICAgY29uc3QgY2R5TGliID0gdGhpcy5jZHlMaWJOYW1lLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgY29uc3Qgd2FzaVRhcmdldCA9IHRoaXMuY29uZmlnLnRhcmdldHMuZmluZCgodCkgPT4gdC5wbGF0Zm9ybSA9PT0gJ3dhc2knKVxuXG4gICAgICBjb25zdCBzcmNOYW1lID1cbiAgICAgICAgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICdkYXJ3aW4nXG4gICAgICAgICAgPyBgbGliJHtjZHlMaWJ9LmR5bGliYFxuICAgICAgICAgIDogdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3aW4zMidcbiAgICAgICAgICAgID8gYCR7Y2R5TGlifS5kbGxgXG4gICAgICAgICAgICA6IHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGhpcy50YXJnZXQucGxhdGZvcm0gPT09ICd3YXNtJ1xuICAgICAgICAgICAgICA/IGAke2NkeUxpYn0ud2FzbWBcbiAgICAgICAgICAgICAgOiBgbGliJHtjZHlMaWJ9LnNvYFxuXG4gICAgICBsZXQgZGVzdE5hbWUgPSB0aGlzLmNvbmZpZy5iaW5hcnlOYW1lXG4gICAgICAvLyBhZGQgcGxhdGZvcm0gc3VmZml4IHRvIGJpbmFyeSBuYW1lXG4gICAgICAvLyBpbmRleFsubGludXgteDY0LWdudV0ubm9kZVxuICAgICAgLy8gICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGxhdGZvcm0pIHtcbiAgICAgICAgZGVzdE5hbWUgKz0gYC4ke3RoaXMudGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gXG4gICAgICB9XG4gICAgICBpZiAoc3JjTmFtZS5lbmRzV2l0aCgnLndhc20nKSkge1xuICAgICAgICBkZXN0TmFtZSArPSAnLndhc20nXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0TmFtZSArPSAnLm5vZGUnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHNyY05hbWUsXG4gICAgICAgIGRlc3ROYW1lLFxuICAgICAgICB3YXNpVGFyZ2V0XG4gICAgICAgICAgPyBgJHt0aGlzLmNvbmZpZy5iaW5hcnlOYW1lfS4ke3dhc2lUYXJnZXQucGxhdGZvcm1BcmNoQUJJfS53YXNtYFxuICAgICAgICAgIDogbnVsbCxcbiAgICAgIF1cbiAgICB9IGVsc2UgaWYgKHRoaXMuYmluTmFtZSkge1xuICAgICAgY29uc3Qgc3JjTmFtZSA9XG4gICAgICAgIHRoaXMudGFyZ2V0LnBsYXRmb3JtID09PSAnd2luMzInID8gYCR7dGhpcy5iaW5OYW1lfS5leGVgIDogdGhpcy5iaW5OYW1lXG5cbiAgICAgIHJldHVybiBbc3JjTmFtZSwgc3JjTmFtZV1cbiAgICB9XG5cbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVUeXBlRGVmKCkge1xuICAgIGNvbnN0IHR5cGVEZWZEaXIgPSB0aGlzLmVudnMuTkFQSV9UWVBFX0RFRl9UTVBfRk9MREVSXG4gICAgaWYgKCF0aGlzLmVuYWJsZVR5cGVEZWYpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cblxuICAgIGNvbnN0IHsgZXhwb3J0cywgZHRzIH0gPSBhd2FpdCBnZW5lcmF0ZVR5cGVEZWYoe1xuICAgICAgdHlwZURlZkRpcixcbiAgICAgIG5vRHRzSGVhZGVyOiB0aGlzLm9wdGlvbnMubm9EdHNIZWFkZXIsXG4gICAgICBkdHNIZWFkZXI6IHRoaXMub3B0aW9ucy5kdHNIZWFkZXIsXG4gICAgICBjb25maWdEdHNIZWFkZXI6IHRoaXMuY29uZmlnLmR0c0hlYWRlcixcbiAgICAgIGNvbmZpZ0R0c0hlYWRlckZpbGU6IHRoaXMuY29uZmlnLmR0c0hlYWRlckZpbGUsXG4gICAgICBjb25zdEVudW06IHRoaXMub3B0aW9ucy5jb25zdEVudW0gPz8gdGhpcy5jb25maWcuY29uc3RFbnVtLFxuICAgICAgY3dkOiB0aGlzLm9wdGlvbnMuY3dkLFxuICAgIH0pXG5cbiAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgdGhpcy5vcHRpb25zLmR0cyA/PyAnaW5kZXguZC50cycpXG5cbiAgICB0cnkge1xuICAgICAgZGVidWcoJ1dyaXRpbmcgdHlwZSBkZWYgdG86JylcbiAgICAgIGRlYnVnKCcgICVpJywgZGVzdClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIGR0cywgJ3V0Zi04JylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1Zy5lcnJvcignRmFpbGVkIHRvIHdyaXRlIHR5cGUgZGVmIGZpbGUnKVxuICAgICAgZGVidWcuZXJyb3IoZSBhcyBFcnJvcilcbiAgICB9XG5cbiAgICBpZiAoZXhwb3J0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBkZXN0ID0gam9pbih0aGlzLm91dHB1dERpciwgdGhpcy5vcHRpb25zLmR0cyA/PyAnaW5kZXguZC50cycpXG4gICAgICB0aGlzLm91dHB1dHMucHVzaCh7IGtpbmQ6ICdkdHMnLCBwYXRoOiBkZXN0IH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVKc0JpbmRpbmcoaWRlbnRzOiBzdHJpbmdbXSkge1xuICAgIHJldHVybiB3cml0ZUpzQmluZGluZyh7XG4gICAgICBwbGF0Zm9ybTogdGhpcy5vcHRpb25zLnBsYXRmb3JtLFxuICAgICAgbm9Kc0JpbmRpbmc6IHRoaXMub3B0aW9ucy5ub0pzQmluZGluZyxcbiAgICAgIGlkZW50cyxcbiAgICAgIGpzQmluZGluZzogdGhpcy5vcHRpb25zLmpzQmluZGluZyxcbiAgICAgIGVzbTogdGhpcy5vcHRpb25zLmVzbSxcbiAgICAgIGJpbmFyeU5hbWU6IHRoaXMuY29uZmlnLmJpbmFyeU5hbWUsXG4gICAgICBwYWNrYWdlTmFtZTogdGhpcy5vcHRpb25zLmpzUGFja2FnZU5hbWUgPz8gdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICB2ZXJzaW9uOiBwcm9jZXNzLmVudi5ucG1fbmV3X3ZlcnNpb24gPz8gdGhpcy5jb25maWcucGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIG91dHB1dERpcjogdGhpcy5vdXRwdXREaXIsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgd3JpdGVXYXNpQmluZGluZyhcbiAgICBkaXN0RmlsZU5hbWU6IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgaWRlbnRzOiBzdHJpbmdbXSxcbiAgKSB7XG4gICAgaWYgKGRpc3RGaWxlTmFtZSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBkaXIgfSA9IHBhcnNlKGRpc3RGaWxlTmFtZSlcbiAgICAgIGNvbnN0IGJpbmRpbmdQYXRoID0gam9pbihkaXIsIGAke3RoaXMuY29uZmlnLmJpbmFyeU5hbWV9Lndhc2kuY2pzYClcbiAgICAgIGNvbnN0IGJyb3dzZXJCaW5kaW5nUGF0aCA9IGpvaW4oXG4gICAgICAgIGRpcixcbiAgICAgICAgYCR7dGhpcy5jb25maWcuYmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICAgIClcbiAgICAgIGNvbnN0IHdvcmtlclBhdGggPSBqb2luKGRpciwgJ3dhc2ktd29ya2VyLm1qcycpXG4gICAgICBjb25zdCBicm93c2VyV29ya2VyUGF0aCA9IGpvaW4oZGlyLCAnd2FzaS13b3JrZXItYnJvd3Nlci5tanMnKVxuICAgICAgY29uc3QgYnJvd3NlckVudHJ5UGF0aCA9IGpvaW4oZGlyLCAnYnJvd3Nlci5qcycpXG4gICAgICBjb25zdCBleHBvcnRzQ29kZSA9XG4gICAgICAgIGBtb2R1bGUuZXhwb3J0cyA9IF9fbmFwaU1vZHVsZS5leHBvcnRzXFxuYCArXG4gICAgICAgIGlkZW50c1xuICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAoaWRlbnQpID0+XG4gICAgICAgICAgICAgIGBtb2R1bGUuZXhwb3J0cy4ke2lkZW50fSA9IF9fbmFwaU1vZHVsZS5leHBvcnRzLiR7aWRlbnR9YCxcbiAgICAgICAgICApXG4gICAgICAgICAgLmpvaW4oJ1xcbicpXG4gICAgICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICAgICAgYmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCaW5kaW5nKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcucGFja2FnZU5hbWUsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uaW5pdGlhbE1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5tYXhpbXVtTWVtb3J5LFxuICAgICAgICApICtcbiAgICAgICAgICBleHBvcnRzQ29kZSArXG4gICAgICAgICAgJ1xcbicsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyQmluZGluZ1BhdGgsXG4gICAgICAgIGNyZWF0ZVdhc2lCcm93c2VyQmluZGluZyhcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRoaXMuY29uZmlnLndhc20/LmluaXRpYWxNZW1vcnksXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8ubWF4aW11bU1lbW9yeSxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5mcyxcbiAgICAgICAgICB0aGlzLmNvbmZpZy53YXNtPy5icm93c2VyPy5hc3luY0luaXQsXG4gICAgICAgICAgdGhpcy5jb25maWcud2FzbT8uYnJvd3Nlcj8uYnVmZmVyLFxuICAgICAgICApICtcbiAgICAgICAgICBgZXhwb3J0IGRlZmF1bHQgX19uYXBpTW9kdWxlLmV4cG9ydHNcXG5gICtcbiAgICAgICAgICBpZGVudHNcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgIChpZGVudCkgPT5cbiAgICAgICAgICAgICAgICBgZXhwb3J0IGNvbnN0ICR7aWRlbnR9ID0gX19uYXBpTW9kdWxlLmV4cG9ydHMuJHtpZGVudH1gLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpICtcbiAgICAgICAgICAnXFxuJyxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMod29ya2VyUGF0aCwgV0FTSV9XT1JLRVJfVEVNUExBVEUsICd1dGY4JylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgICBicm93c2VyV29ya2VyUGF0aCxcbiAgICAgICAgY3JlYXRlV2FzaUJyb3dzZXJXb3JrZXJCaW5kaW5nKHRoaXMuY29uZmlnLndhc20/LmJyb3dzZXI/LmZzID8/IGZhbHNlKSxcbiAgICAgICAgJ3V0ZjgnLFxuICAgICAgKVxuICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgIGJyb3dzZXJFbnRyeVBhdGgsXG4gICAgICAgIGBleHBvcnQgKiBmcm9tICcke3RoaXMuY29uZmlnLnBhY2thZ2VOYW1lfS13YXNtMzItd2FzaSdcXG5gLFxuICAgICAgKVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBiaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJCaW5kaW5nUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IHdvcmtlclBhdGggfSxcbiAgICAgICAgeyBraW5kOiAnanMnLCBwYXRoOiBicm93c2VyV29ya2VyUGF0aCB9LFxuICAgICAgICB7IGtpbmQ6ICdqcycsIHBhdGg6IGJyb3dzZXJFbnRyeVBhdGggfSxcbiAgICAgIF0gc2F0aXNmaWVzIE91dHB1dFtdXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRFbnZJZk5vdEV4aXN0cyhlbnY6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICAgIGlmICghcHJvY2Vzcy5lbnZbZW52XSkge1xuICAgICAgdGhpcy5lbnZzW2Vudl0gPSB2YWx1ZVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdyaXRlSnNCaW5kaW5nT3B0aW9ucyB7XG4gIHBsYXRmb3JtPzogYm9vbGVhblxuICBub0pzQmluZGluZz86IGJvb2xlYW5cbiAgaWRlbnRzOiBzdHJpbmdbXVxuICBqc0JpbmRpbmc/OiBzdHJpbmdcbiAgZXNtPzogYm9vbGVhblxuICBiaW5hcnlOYW1lOiBzdHJpbmdcbiAgcGFja2FnZU5hbWU6IHN0cmluZ1xuICB2ZXJzaW9uOiBzdHJpbmdcbiAgb3V0cHV0RGlyOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdyaXRlSnNCaW5kaW5nKFxuICBvcHRpb25zOiBXcml0ZUpzQmluZGluZ09wdGlvbnMsXG4pOiBQcm9taXNlPE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICBpZiAoXG4gICAgIW9wdGlvbnMucGxhdGZvcm0gfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICBvcHRpb25zLm5vSnNCaW5kaW5nIHx8XG4gICAgb3B0aW9ucy5pZGVudHMubGVuZ3RoID09PSAwXG4gICkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgbmFtZSA9IG9wdGlvbnMuanNCaW5kaW5nID8/ICdpbmRleC5qcydcblxuICBjb25zdCBjcmVhdGVCaW5kaW5nID0gb3B0aW9ucy5lc20gPyBjcmVhdGVFc21CaW5kaW5nIDogY3JlYXRlQ2pzQmluZGluZ1xuICBjb25zdCBiaW5kaW5nID0gY3JlYXRlQmluZGluZyhcbiAgICBvcHRpb25zLmJpbmFyeU5hbWUsXG4gICAgb3B0aW9ucy5wYWNrYWdlTmFtZSxcbiAgICBvcHRpb25zLmlkZW50cyxcbiAgICAvLyBpbiBucG0gcHJldmVyc2lvbiBob29rXG4gICAgb3B0aW9ucy52ZXJzaW9uLFxuICApXG5cbiAgdHJ5IHtcbiAgICBjb25zdCBkZXN0ID0gam9pbihvcHRpb25zLm91dHB1dERpciwgbmFtZSlcbiAgICBkZWJ1ZygnV3JpdGluZyBqcyBiaW5kaW5nIHRvOicpXG4gICAgZGVidWcoJyAgJWknLCBkZXN0KVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGRlc3QsIGJpbmRpbmcsICd1dGYtOCcpXG4gICAgcmV0dXJuIHsga2luZDogJ2pzJywgcGF0aDogZGVzdCB9IHNhdGlzZmllcyBPdXRwdXRcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHdyaXRlIGpzIGJpbmRpbmcgZmlsZScsIHsgY2F1c2U6IGUgfSlcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlVHlwZURlZk9wdGlvbnMge1xuICB0eXBlRGVmRGlyOiBzdHJpbmdcbiAgbm9EdHNIZWFkZXI/OiBib29sZWFuXG4gIGR0c0hlYWRlcj86IHN0cmluZ1xuICBkdHNIZWFkZXJGaWxlPzogc3RyaW5nXG4gIGNvbmZpZ0R0c0hlYWRlcj86IHN0cmluZ1xuICBjb25maWdEdHNIZWFkZXJGaWxlPzogc3RyaW5nXG4gIGNvbnN0RW51bT86IGJvb2xlYW5cbiAgY3dkOiBzdHJpbmdcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVHlwZURlZihcbiAgb3B0aW9uczogR2VuZXJhdGVUeXBlRGVmT3B0aW9ucyxcbik6IFByb21pc2U8eyBleHBvcnRzOiBzdHJpbmdbXTsgZHRzOiBzdHJpbmcgfT4ge1xuICBpZiAoIShhd2FpdCBkaXJFeGlzdHNBc3luYyhvcHRpb25zLnR5cGVEZWZEaXIpKSkge1xuICAgIHJldHVybiB7IGV4cG9ydHM6IFtdLCBkdHM6ICcnIH1cbiAgfVxuXG4gIGxldCBoZWFkZXIgPSAnJ1xuICBsZXQgZHRzID0gJydcbiAgbGV0IGV4cG9ydHM6IHN0cmluZ1tdID0gW11cblxuICBpZiAoIW9wdGlvbnMubm9EdHNIZWFkZXIpIHtcbiAgICBjb25zdCBkdHNIZWFkZXIgPSBvcHRpb25zLmR0c0hlYWRlciA/PyBvcHRpb25zLmNvbmZpZ0R0c0hlYWRlclxuICAgIC8vIGBkdHNIZWFkZXJGaWxlYCBpbiBjb25maWcgPiBgZHRzSGVhZGVyYCBpbiBjbGkgZmxhZyA+IGBkdHNIZWFkZXJgIGluIGNvbmZpZ1xuICAgIGlmIChvcHRpb25zLmNvbmZpZ0R0c0hlYWRlckZpbGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhlYWRlciA9IGF3YWl0IHJlYWRGaWxlQXN5bmMoXG4gICAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdEdHNIZWFkZXJGaWxlKSxcbiAgICAgICAgICAndXRmLTgnLFxuICAgICAgICApXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnLndhcm4oXG4gICAgICAgICAgYEZhaWxlZCB0byByZWFkIGR0cyBoZWFkZXIgZmlsZSAke29wdGlvbnMuY29uZmlnRHRzSGVhZGVyRmlsZX1gLFxuICAgICAgICAgIGUsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGR0c0hlYWRlcikge1xuICAgICAgaGVhZGVyID0gZHRzSGVhZGVyXG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWRlciA9IERFRkFVTFRfVFlQRV9ERUZfSEVBREVSXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMob3B0aW9ucy50eXBlRGVmRGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICBpZiAoIWZpbGVzLmxlbmd0aCkge1xuICAgIGRlYnVnKCdObyB0eXBlIGRlZiBmaWxlcyBmb3VuZC4gU2tpcCBnZW5lcmF0aW5nIGR0cyBmaWxlLicpXG4gICAgcmV0dXJuIHsgZXhwb3J0czogW10sIGR0czogJycgfVxuICB9XG5cbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgaWYgKCFmaWxlLmlzRmlsZSgpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGNvbnN0IHsgZHRzOiBmaWxlRHRzLCBleHBvcnRzOiBmaWxlRXhwb3J0cyB9ID0gYXdhaXQgcHJvY2Vzc1R5cGVEZWYoXG4gICAgICBqb2luKG9wdGlvbnMudHlwZURlZkRpciwgZmlsZS5uYW1lKSxcbiAgICAgIG9wdGlvbnMuY29uc3RFbnVtID8/IHRydWUsXG4gICAgKVxuXG4gICAgZHRzICs9IGZpbGVEdHNcbiAgICBleHBvcnRzLnB1c2goLi4uZmlsZUV4cG9ydHMpXG4gIH1cblxuICBpZiAoZHRzLmluZGV4T2YoJ0V4dGVybmFsT2JqZWN0PCcpID4gLTEpIHtcbiAgICBoZWFkZXIgKz0gYFxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRXh0ZXJuYWxPYmplY3Q8VD4ge1xuICByZWFkb25seSAnJzoge1xuICAgIHJlYWRvbmx5ICcnOiB1bmlxdWUgc3ltYm9sXG4gICAgW0s6IHN5bWJvbF06IFRcbiAgfVxufVxuYFxuICB9XG5cbiAgaWYgKGR0cy5pbmRleE9mKCdUeXBlZEFycmF5JykgPiAtMSkge1xuICAgIGhlYWRlciArPSBgXG5leHBvcnQgdHlwZSBUeXBlZEFycmF5ID0gSW50OEFycmF5IHwgVWludDhBcnJheSB8IFVpbnQ4Q2xhbXBlZEFycmF5IHwgSW50MTZBcnJheSB8IFVpbnQxNkFycmF5IHwgSW50MzJBcnJheSB8IFVpbnQzMkFycmF5IHwgRmxvYXQzMkFycmF5IHwgRmxvYXQ2NEFycmF5IHwgQmlnSW50NjRBcnJheSB8IEJpZ1VpbnQ2NEFycmF5XG5gXG4gIH1cblxuICBkdHMgPSBoZWFkZXIgKyBkdHNcblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHMsXG4gICAgZHRzLFxuICB9XG59XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNyZWF0ZU5wbURpcnNDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ2NyZWF0ZS1ucG0tZGlycyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIG5wbSBwYWNrYWdlIGRpcnMgZm9yIGRpZmZlcmVudCBwbGF0Zm9ybXMnLFxuICB9KVxuXG4gIGN3ZCA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywgcHJvY2Vzcy5jd2QoKSwge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgY29uZmlnUGF0aD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY29uZmlnLXBhdGgsLWMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlJyxcbiAgfSlcblxuICBwYWNrYWdlSnNvblBhdGggPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtanNvbi1wYXRoJywgJ3BhY2thZ2UuanNvbicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIG5wbURpciA9IE9wdGlvbi5TdHJpbmcoJy0tbnBtLWRpcicsICducG0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXQnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICBkcnlSdW46IHRoaXMuZHJ5UnVuLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBucG0gcGFja2FnZSBkaXJzIGZvciBkaWZmZXJlbnQgcGxhdGZvcm1zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlTnBtRGlyc09wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyhcbiAgb3B0aW9uczogQ3JlYXRlTnBtRGlyc09wdGlvbnMsXG4pIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgcGFyc2UgfSBmcm9tICdzZW12ZXInXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdENyZWF0ZU5wbURpcnNPcHRpb25zLFxuICB0eXBlIENyZWF0ZU5wbURpcnNPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvY3JlYXRlLW5wbS1kaXJzLmpzJ1xuaW1wb3J0IHtcbiAgZGVidWdGYWN0b3J5LFxuICByZWFkTmFwaUNvbmZpZyxcbiAgbWtkaXJBc3luYyBhcyByYXdNa2RpckFzeW5jLFxuICBwaWNrLFxuICB3cml0ZUZpbGVBc3luYyBhcyByYXdXcml0ZUZpbGVBc3luYyxcbiAgdHlwZSBUYXJnZXQsXG4gIHR5cGUgQ29tbW9uUGFja2FnZUpzb25GaWVsZHMsXG59IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnY3JlYXRlLW5wbS1kaXJzJylcblxuZXhwb3J0IGludGVyZmFjZSBQYWNrYWdlTWV0YSB7XG4gICdkaXN0LXRhZ3MnOiB7IFtpbmRleDogc3RyaW5nXTogc3RyaW5nIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU5wbURpcnModXNlck9wdGlvbnM6IENyZWF0ZU5wbURpcnNPcHRpb25zKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRDcmVhdGVOcG1EaXJzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBhc3luYyBmdW5jdGlvbiBta2RpckFzeW5jKGRpcjogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1RyeSB0byBjcmVhdGUgZGlyOiAlaScsIGRpcilcbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGF3YWl0IHJhd01rZGlyQXN5bmMoZGlyLCB7XG4gICAgICByZWN1cnNpdmU6IHRydWUsXG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZUFzeW5jKGZpbGU6IHN0cmluZywgY29udGVudDogc3RyaW5nKSB7XG4gICAgZGVidWcoJ1dyaXRpbmcgZmlsZSAlaScsIGZpbGUpXG5cbiAgICBpZiAob3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIGRlYnVnKGNvbnRlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhd2FpdCByYXdXcml0ZUZpbGVBc3luYyhmaWxlLCBjb250ZW50KVxuICB9XG5cbiAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5wYWNrYWdlSnNvblBhdGgpXG4gIGNvbnN0IG5wbVBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLm5wbURpcilcblxuICBkZWJ1ZyhgUmVhZCBjb250ZW50IGZyb20gWyR7b3B0aW9ucy5jb25maWdQYXRoID8/IHBhY2thZ2VKc29uUGF0aH1dYClcblxuICBjb25zdCB7IHRhcmdldHMsIGJpbmFyeU5hbWUsIHBhY2thZ2VOYW1lLCBwYWNrYWdlSnNvbiB9ID1cbiAgICBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICAgIHBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG9wdGlvbnMuY29uZmlnUGF0aCA/IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMuY29uZmlnUGF0aCkgOiB1bmRlZmluZWQsXG4gICAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRhcmdldHMpIHtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBqb2luKG5wbVBhdGgsIGAke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YClcbiAgICBhd2FpdCBta2RpckFzeW5jKHRhcmdldERpcilcblxuICAgIGNvbnN0IGJpbmFyeUZpbGVOYW1lID1cbiAgICAgIHRhcmdldC5hcmNoID09PSAnd2FzbTMyJ1xuICAgICAgICA/IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0ud2FzbWBcbiAgICAgICAgOiBgJHtiaW5hcnlOYW1lfS4ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9Lm5vZGVgXG4gICAgY29uc3Qgc2NvcGVkUGFja2FnZUpzb246IENvbW1vblBhY2thZ2VKc29uRmllbGRzID0ge1xuICAgICAgbmFtZTogYCR7cGFja2FnZU5hbWV9LSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgICAgdmVyc2lvbjogcGFja2FnZUpzb24udmVyc2lvbixcbiAgICAgIGNwdTogdGFyZ2V0LmFyY2ggIT09ICd1bml2ZXJzYWwnID8gW3RhcmdldC5hcmNoXSA6IHVuZGVmaW5lZCxcbiAgICAgIG1haW46IGJpbmFyeUZpbGVOYW1lLFxuICAgICAgZmlsZXM6IFtiaW5hcnlGaWxlTmFtZV0sXG4gICAgICAuLi5waWNrKFxuICAgICAgICBwYWNrYWdlSnNvbixcbiAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgJ2tleXdvcmRzJyxcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdhdXRob3JzJyxcbiAgICAgICAgJ2hvbWVwYWdlJyxcbiAgICAgICAgJ2xpY2Vuc2UnLFxuICAgICAgICAnZW5naW5lcycsXG4gICAgICAgICdyZXBvc2l0b3J5JyxcbiAgICAgICAgJ2J1Z3MnLFxuICAgICAgKSxcbiAgICB9XG4gICAgaWYgKHBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLnB1Ymxpc2hDb25maWcgPSBwaWNrKFxuICAgICAgICBwYWNrYWdlSnNvbi5wdWJsaXNoQ29uZmlnLFxuICAgICAgICAncmVnaXN0cnknLFxuICAgICAgICAnYWNjZXNzJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKHRhcmdldC5hcmNoICE9PSAnd2FzbTMyJykge1xuICAgICAgc2NvcGVkUGFja2FnZUpzb24ub3MgPSBbdGFyZ2V0LnBsYXRmb3JtXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGAke2JpbmFyeU5hbWV9Lndhc2kuY2pzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24ubWFpbiA9IGVudHJ5XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyID0gYCR7YmluYXJ5TmFtZX0ud2FzaS1icm93c2VyLmpzYFxuICAgICAgc2NvcGVkUGFja2FnZUpzb24uZmlsZXM/LnB1c2goXG4gICAgICAgIGVudHJ5LFxuICAgICAgICBzY29wZWRQYWNrYWdlSnNvbi5icm93c2VyLFxuICAgICAgICBgd2FzaS13b3JrZXIubWpzYCxcbiAgICAgICAgYHdhc2ktd29ya2VyLWJyb3dzZXIubWpzYCxcbiAgICAgIClcbiAgICAgIGxldCBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IHRydWVcbiAgICAgIGlmIChzY29wZWRQYWNrYWdlSnNvbi5lbmdpbmVzPy5ub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBtYWpvciB9ID0gcGFyc2Uoc2NvcGVkUGFja2FnZUpzb24uZW5naW5lcy5ub2RlKSA/PyB7XG4gICAgICAgICAgICBtYWpvcjogMCxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1ham9yID49IDE0KSB7XG4gICAgICAgICAgICBuZWVkUmVzdHJpY3ROb2RlVmVyc2lvbiA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5lZWRSZXN0cmljdE5vZGVWZXJzaW9uKSB7XG4gICAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmVuZ2luZXMgPSB7XG4gICAgICAgICAgbm9kZTogJz49MTQuMC4wJyxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzbVJ1bnRpbWUgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL0BuYXBpLXJzL3dhc20tcnVudGltZWAsXG4gICAgICApLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSBhcyBQcm9taXNlPFBhY2thZ2VNZXRhPilcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgJ0BuYXBpLXJzL3dhc20tcnVudGltZSc6IGBeJHt3YXNtUnVudGltZVsnZGlzdC10YWdzJ10ubGF0ZXN0fWAsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldC5hYmkgPT09ICdnbnUnKSB7XG4gICAgICBzY29wZWRQYWNrYWdlSnNvbi5saWJjID0gWydnbGliYyddXG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYWJpID09PSAnbXVzbCcpIHtcbiAgICAgIHNjb3BlZFBhY2thZ2VKc29uLmxpYmMgPSBbJ211c2wnXVxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldFBhY2thZ2VKc29uID0gam9pbih0YXJnZXREaXIsICdwYWNrYWdlLmpzb24nKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKFxuICAgICAgdGFyZ2V0UGFja2FnZUpzb24sXG4gICAgICBKU09OLnN0cmluZ2lmeShzY29wZWRQYWNrYWdlSnNvbiwgbnVsbCwgMikgKyAnXFxuJyxcbiAgICApXG4gICAgY29uc3QgdGFyZ2V0UmVhZG1lID0gam9pbih0YXJnZXREaXIsICdSRUFETUUubWQnKVxuICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKHRhcmdldFJlYWRtZSwgcmVhZG1lKHBhY2thZ2VOYW1lLCB0YXJnZXQpKVxuXG4gICAgZGVidWcuaW5mbyhgJHtwYWNrYWdlTmFtZX0gLSR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0gY3JlYXRlZGApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHRhcmdldDogVGFyZ2V0KSB7XG4gIHJldHVybiBgIyBcXGAke3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9XFxgXG5cblRoaXMgaXMgdGhlICoqJHt0YXJnZXQudHJpcGxlfSoqIGJpbmFyeSBmb3IgXFxgJHtwYWNrYWdlTmFtZX1cXGBcbmBcbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5pbXBvcnQgKiBhcyB0eXBhbmlvbiBmcm9tICd0eXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VOZXdDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ25ldyddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ3JlYXRlIGEgbmV3IHByb2plY3Qgd2l0aCBwcmUtY29uZmlndXJlZCBib2lsZXJwbGF0ZScsXG4gIH0pXG5cbiAgJCRwYXRoID0gT3B0aW9uLlN0cmluZyh7IHJlcXVpcmVkOiBmYWxzZSB9KVxuXG4gICQkbmFtZT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tbmFtZSwtbicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgbmFtZSBvZiB0aGUgcHJvamVjdCwgZGVmYXVsdCB0byB0aGUgbmFtZSBvZiB0aGUgZGlyZWN0b3J5IGlmIG5vdCBwcm92aWRlZCcsXG4gIH0pXG5cbiAgbWluTm9kZUFwaVZlcnNpb24gPSBPcHRpb24uU3RyaW5nKCctLW1pbi1ub2RlLWFwaSwtdicsICc0Jywge1xuICAgIHZhbGlkYXRvcjogdHlwYW5pb24uaXNOdW1iZXIoKSxcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBtaW5pbXVtIE5vZGUtQVBJIHZlcnNpb24gdG8gc3VwcG9ydCcsXG4gIH0pXG5cbiAgcGFja2FnZU1hbmFnZXIgPSBPcHRpb24uU3RyaW5nKCctLXBhY2thZ2UtbWFuYWdlcicsICd5YXJuJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIHBhY2thZ2UgbWFuYWdlciB0byB1c2UuIE9ubHkgc3VwcG9ydCB5YXJuIDQueCBmb3Igbm93LicsXG4gIH0pXG5cbiAgbGljZW5zZSA9IE9wdGlvbi5TdHJpbmcoJy0tbGljZW5zZSwtbCcsICdNSVQnLCB7XG4gICAgZGVzY3JpcHRpb246ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gIH0pXG5cbiAgdGFyZ2V0cyA9IE9wdGlvbi5BcnJheSgnLS10YXJnZXRzLC10JywgW10sIHtcbiAgICBkZXNjcmlwdGlvbjogJ0FsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci4nLFxuICB9KVxuXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzID0gT3B0aW9uLkJvb2xlYW4oJy0tZW5hYmxlLWRlZmF1bHQtdGFyZ2V0cycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZW5hYmxlIGRlZmF1bHQgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlQWxsVGFyZ2V0cyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1hbGwtdGFyZ2V0cycsIGZhbHNlLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGVuYWJsZSBhbGwgdGFyZ2V0cycsXG4gIH0pXG5cbiAgZW5hYmxlVHlwZURlZiA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS10eXBlLWRlZicsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvbicsXG4gIH0pXG5cbiAgZW5hYmxlR2l0aHViQWN0aW9ucyA9IE9wdGlvbi5Cb29sZWFuKCctLWVuYWJsZS1naXRodWItYWN0aW9ucycsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgZ2VuZXJhdGUgcHJlY29uZmlndXJlZCBHaXRIdWIgQWN0aW9ucyB3b3JrZmxvdycsXG4gIH0pXG5cbiAgdGVzdEZyYW1ld29yayA9IE9wdGlvbi5TdHJpbmcoJy0tdGVzdC1mcmFtZXdvcmsnLCAnYXZhJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSBKYXZhU2NyaXB0IHRlc3QgZnJhbWV3b3JrIHRvIHVzZSwgb25seSBzdXBwb3J0IGBhdmFgIGZvciBub3cnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciB0byBydW4gdGhlIGNvbW1hbmQgaW4gZHJ5LXJ1biBtb2RlJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB0aGlzLiQkcGF0aCxcbiAgICAgIG5hbWU6IHRoaXMuJCRuYW1lLFxuICAgICAgbWluTm9kZUFwaVZlcnNpb246IHRoaXMubWluTm9kZUFwaVZlcnNpb24sXG4gICAgICBwYWNrYWdlTWFuYWdlcjogdGhpcy5wYWNrYWdlTWFuYWdlcixcbiAgICAgIGxpY2Vuc2U6IHRoaXMubGljZW5zZSxcbiAgICAgIHRhcmdldHM6IHRoaXMudGFyZ2V0cyxcbiAgICAgIGVuYWJsZURlZmF1bHRUYXJnZXRzOiB0aGlzLmVuYWJsZURlZmF1bHRUYXJnZXRzLFxuICAgICAgZW5hYmxlQWxsVGFyZ2V0czogdGhpcy5lbmFibGVBbGxUYXJnZXRzLFxuICAgICAgZW5hYmxlVHlwZURlZjogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogdGhpcy5lbmFibGVHaXRodWJBY3Rpb25zLFxuICAgICAgdGVzdEZyYW1ld29yazogdGhpcy50ZXN0RnJhbWV3b3JrLFxuICAgICAgZHJ5UnVuOiB0aGlzLmRyeVJ1bixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgcHJvamVjdCB3aXRoIHByZS1jb25maWd1cmVkIGJvaWxlcnBsYXRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV3T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgcGF0aCB3aGVyZSB0aGUgTkFQSS1SUyBwcm9qZWN0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICovXG4gIHBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBwcm9qZWN0LCBkZWZhdWx0IHRvIHRoZSBuYW1lIG9mIHRoZSBkaXJlY3RvcnkgaWYgbm90IHByb3ZpZGVkXG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBOb2RlLUFQSSB2ZXJzaW9uIHRvIHN1cHBvcnRcbiAgICpcbiAgICogQGRlZmF1bHQgNFxuICAgKi9cbiAgbWluTm9kZUFwaVZlcnNpb24/OiBudW1iZXJcbiAgLyoqXG4gICAqIFRoZSBwYWNrYWdlIG1hbmFnZXIgdG8gdXNlLiBPbmx5IHN1cHBvcnQgeWFybiA0LnggZm9yIG5vdy5cbiAgICpcbiAgICogQGRlZmF1bHQgJ3lhcm4nXG4gICAqL1xuICBwYWNrYWdlTWFuYWdlcj86IHN0cmluZ1xuICAvKipcbiAgICogTGljZW5zZSBmb3Igb3Blbi1zb3VyY2VkIHByb2plY3RcbiAgICpcbiAgICogQGRlZmF1bHQgJ01JVCdcbiAgICovXG4gIGxpY2Vuc2U/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFsbCB0YXJnZXRzIHRoZSBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIGZvci5cbiAgICpcbiAgICogQGRlZmF1bHQgW11cbiAgICovXG4gIHRhcmdldHM/OiBzdHJpbmdbXVxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgZGVmYXVsdCB0YXJnZXRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZURlZmF1bHRUYXJnZXRzPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBlbmFibGUgYWxsIHRhcmdldHNcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGVuYWJsZUFsbFRhcmdldHM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGVuYWJsZSB0aGUgYHR5cGUtZGVmYCBmZWF0dXJlIGZvciB0eXBlc2NyaXB0IGRlZmluaXRpb25zIGF1dG8tZ2VuZXJhdGlvblxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBlbmFibGVUeXBlRGVmPzogYm9vbGVhblxuICAvKipcbiAgICogV2hldGhlciBnZW5lcmF0ZSBwcmVjb25maWd1cmVkIEdpdEh1YiBBY3Rpb25zIHdvcmtmbG93XG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGVuYWJsZUdpdGh1YkFjdGlvbnM/OiBib29sZWFuXG4gIC8qKlxuICAgKiBUaGUgSmF2YVNjcmlwdCB0ZXN0IGZyYW1ld29yayB0byB1c2UsIG9ubHkgc3VwcG9ydCBgYXZhYCBmb3Igbm93XG4gICAqXG4gICAqIEBkZWZhdWx0ICdhdmEnXG4gICAqL1xuICB0ZXN0RnJhbWV3b3JrPzogc3RyaW5nXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHJ1biB0aGUgY29tbWFuZCBpbiBkcnktcnVuIG1vZGVcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRyeVJ1bj86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMob3B0aW9uczogTmV3T3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIG1pbk5vZGVBcGlWZXJzaW9uOiA0LFxuICAgIHBhY2thZ2VNYW5hZ2VyOiAneWFybicsXG4gICAgbGljZW5zZTogJ01JVCcsXG4gICAgdGFyZ2V0czogW10sXG4gICAgZW5hYmxlRGVmYXVsdFRhcmdldHM6IHRydWUsXG4gICAgZW5hYmxlQWxsVGFyZ2V0czogZmFsc2UsXG4gICAgZW5hYmxlVHlwZURlZjogdHJ1ZSxcbiAgICBlbmFibGVHaXRodWJBY3Rpb25zOiB0cnVlLFxuICAgIHRlc3RGcmFtZXdvcms6ICdhdmEnLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbi8vIEJhcmUga2V5cyBtYXkgb25seSBjb250YWluIEFTQ0lJIGxldHRlcnMsXG4vLyBBU0NJSSBkaWdpdHMsIHVuZGVyc2NvcmVzLCBhbmQgZGFzaGVzIChBLVphLXowLTlfLSkuXG5mdW5jdGlvbiBqb2luS2V5cyhrZXlzKSB7XG4gIC8vIERvdHRlZCBrZXlzIGFyZSBhIHNlcXVlbmNlIG9mIGJhcmUgb3IgcXVvdGVkIGtleXMgam9pbmVkIHdpdGggYSBkb3QuXG4gIC8vIFRoaXMgYWxsb3dzIGZvciBncm91cGluZyBzaW1pbGFyIHByb3BlcnRpZXMgdG9nZXRoZXI6XG4gIHJldHVybiBrZXlzLm1hcCgoc3RyKT0+e1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAwIHx8IHN0ci5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/IEpTT04uc3RyaW5naWZ5KHN0cikgOiBzdHI7XG4gIH0pLmpvaW4oXCIuXCIpO1xufVxuY2xhc3MgRHVtcGVyIHtcbiAgbWF4UGFkID0gMDtcbiAgc3JjT2JqZWN0O1xuICBvdXRwdXQgPSBbXTtcbiAgI2FycmF5VHlwZUNhY2hlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcihzcmNPYmpjKXtcbiAgICB0aGlzLnNyY09iamVjdCA9IHNyY09iamM7XG4gIH1cbiAgZHVtcChmbXRPcHRpb25zID0ge30pIHtcbiAgICAvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgIHRoaXMub3V0cHV0ID0gdGhpcy4jcHJpbnRPYmplY3QodGhpcy5zcmNPYmplY3QpO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy4jZm9ybWF0KGZtdE9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLm91dHB1dDtcbiAgfVxuICAjcHJpbnRPYmplY3Qob2JqLCBrZXlzID0gW10pIHtcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgY29uc3QgaW5saW5lUHJvcHMgPSBbXTtcbiAgICBjb25zdCBtdWx0aWxpbmVQcm9wcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcyl7XG4gICAgICBpZiAodGhpcy4jaXNTaW1wbHlTZXJpYWxpemFibGUob2JqW3Byb3BdKSkge1xuICAgICAgICBpbmxpbmVQcm9wcy5wdXNoKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXVsdGlsaW5lUHJvcHMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc29ydGVkUHJvcHMgPSBpbmxpbmVQcm9wcy5jb25jYXQobXVsdGlsaW5lUHJvcHMpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBzb3J0ZWRQcm9wcyl7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgb3V0LnB1c2godGhpcy4jZGF0ZURlY2xhcmF0aW9uKFtcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0sIHZhbHVlKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNzdHJEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZS50b1N0cmluZygpKSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBvdXQucHVzaCh0aGlzLiNudW1iZXJEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2Jvb2xEZWNsYXJhdGlvbihbXG4gICAgICAgICAgcHJvcFxuICAgICAgICBdLCB2YWx1ZSkpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGNvbnN0IGFycmF5VHlwZSA9IHRoaXMuI2dldFR5cGVPZkFycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGFycmF5VHlwZSA9PT0gXCJPTkxZX1BSSU1JVElWRVwiKSB7XG4gICAgICAgICAgb3V0LnB1c2godGhpcy4jYXJyYXlEZWNsYXJhdGlvbihbXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSwgdmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChhcnJheVR5cGUgPT09IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCIpIHtcbiAgICAgICAgICAvLyBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIG91dC5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgb3V0LnB1c2godGhpcy4jaGVhZGVyR3JvdXAoW1xuICAgICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgICBvdXQucHVzaCguLi50aGlzLiNwcmludE9iamVjdCh2YWx1ZVtpXSwgW1xuICAgICAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgICAgICBwcm9wXG4gICAgICAgICAgICBdKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHRoaXMgaXMgYSBjb21wbGV4IGFycmF5LCB1c2UgdGhlIGlubGluZSBmb3JtYXQuXG4gICAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUubWFwKCh4KT0+dGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHgpKS5qb2luKFwiLFwiKTtcbiAgICAgICAgICBvdXQucHVzaChgJHt0aGlzLiNkZWNsYXJhdGlvbihbXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSl9WyR7c3RyfV1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3V0LnB1c2goXCJcIik7XG4gICAgICAgIG91dC5wdXNoKHRoaXMuI2hlYWRlcihbXG4gICAgICAgICAgLi4ua2V5cyxcbiAgICAgICAgICBwcm9wXG4gICAgICAgIF0pKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdG9QYXJzZSA9IHZhbHVlO1xuICAgICAgICAgIG91dC5wdXNoKC4uLnRoaXMuI3ByaW50T2JqZWN0KHRvUGFyc2UsIFtcbiAgICAgICAgICAgIC4uLmtleXMsXG4gICAgICAgICAgICBwcm9wXG4gICAgICAgICAgXSkpO1xuICAgICAgICB9XG4gICAgICAvLyBvdXQucHVzaCguLi50aGlzLl9wYXJzZSh2YWx1ZSwgYCR7cGF0aH0ke3Byb3B9LmApKTtcbiAgICAgIH1cbiAgICB9XG4gICAgb3V0LnB1c2goXCJcIik7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAjaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IFtcbiAgICAgIFwic3RyaW5nXCIsXG4gICAgICBcIm51bWJlclwiLFxuICAgICAgXCJib29sZWFuXCJcbiAgICBdLmluY2x1ZGVzKHR5cGVvZiB2YWx1ZSk7XG4gIH1cbiAgI2dldFR5cGVPZkFycmF5KGFycikge1xuICAgIGlmICh0aGlzLiNhcnJheVR5cGVDYWNoZS5oYXMoYXJyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuI2FycmF5VHlwZUNhY2hlLmdldChhcnIpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy4jZG9HZXRUeXBlT2ZBcnJheShhcnIpO1xuICAgIHRoaXMuI2FycmF5VHlwZUNhY2hlLnNldChhcnIsIHR5cGUpO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gICNkb0dldFR5cGVPZkFycmF5KGFycikge1xuICAgIGlmICghYXJyLmxlbmd0aCkge1xuICAgICAgLy8gYW55IHR5cGUgc2hvdWxkIGJlIGZpbmVcbiAgICAgIHJldHVybiBcIk9OTFlfUFJJTUlUSVZFXCI7XG4gICAgfVxuICAgIGNvbnN0IG9ubHlQcmltaXRpdmUgPSB0aGlzLiNpc1ByaW1pdGl2ZShhcnJbMF0pO1xuICAgIGlmIChhcnJbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmV0dXJuIFwiTUlYRURcIjtcbiAgICB9XG4gICAgZm9yKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICBpZiAob25seVByaW1pdGl2ZSAhPT0gdGhpcy4jaXNQcmltaXRpdmUoYXJyW2ldKSB8fCBhcnJbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm4gXCJNSVhFRFwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb25seVByaW1pdGl2ZSA/IFwiT05MWV9QUklNSVRJVkVcIiA6IFwiT05MWV9PQkpFQ1RfRVhDTFVESU5HX0FSUkFZXCI7XG4gIH1cbiAgI3ByaW50QXNJbmxpbmVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBgXCIke3RoaXMuI3ByaW50RGF0ZSh2YWx1ZSl9XCJgO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUudG9TdHJpbmcoKSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgY29uc3Qgc3RyID0gdmFsdWUubWFwKCh4KT0+dGhpcy4jcHJpbnRBc0lubGluZVZhbHVlKHgpKS5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBgWyR7c3RyfV1gO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0ciA9IE9iamVjdC5rZXlzKHZhbHVlKS5tYXAoKGtleSk9PntcbiAgICAgICAgcmV0dXJuIGAke2pvaW5LZXlzKFtcbiAgICAgICAgICBrZXlcbiAgICAgICAgXSl9ID0gJHsvLyBkZW5vLWxpbnQtaWdub3JlIG5vLWV4cGxpY2l0LWFueVxuICAgICAgICB0aGlzLiNwcmludEFzSW5saW5lVmFsdWUodmFsdWVba2V5XSl9YDtcbiAgICAgIH0pLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGB7JHtzdHJ9fWA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBuZXZlciByZWFjaFwiKTtcbiAgfVxuICAjaXNTaW1wbHlTZXJpYWxpemFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiIHx8IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5ICYmIHRoaXMuI2dldFR5cGVPZkFycmF5KHZhbHVlKSAhPT0gXCJPTkxZX09CSkVDVF9FWENMVURJTkdfQVJSQVlcIjtcbiAgfVxuICAjaGVhZGVyKGtleXMpIHtcbiAgICByZXR1cm4gYFske2pvaW5LZXlzKGtleXMpfV1gO1xuICB9XG4gICNoZWFkZXJHcm91cChrZXlzKSB7XG4gICAgcmV0dXJuIGBbWyR7am9pbktleXMoa2V5cyl9XV1gO1xuICB9XG4gICNkZWNsYXJhdGlvbihrZXlzKSB7XG4gICAgY29uc3QgdGl0bGUgPSBqb2luS2V5cyhrZXlzKTtcbiAgICBpZiAodGl0bGUubGVuZ3RoID4gdGhpcy5tYXhQYWQpIHtcbiAgICAgIHRoaXMubWF4UGFkID0gdGl0bGUubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGl0bGV9ID0gYDtcbiAgfVxuICAjYXJyYXlEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICB9XG4gICNzdHJEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gO1xuICB9XG4gICNudW1iZXJEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9bmFuYDtcbiAgICB9XG4gICAgc3dpdGNoKHZhbHVlKXtcbiAgICAgIGNhc2UgSW5maW5pdHk6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX1pbmZgO1xuICAgICAgY2FzZSAtSW5maW5pdHk6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0taW5mYDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3ZhbHVlfWA7XG4gICAgfVxuICB9XG4gICNib29sRGVjbGFyYXRpb24oa2V5cywgdmFsdWUpIHtcbiAgICByZXR1cm4gYCR7dGhpcy4jZGVjbGFyYXRpb24oa2V5cyl9JHt2YWx1ZX1gO1xuICB9XG4gICNwcmludERhdGUodmFsdWUpIHtcbiAgICBmdW5jdGlvbiBkdFBhZCh2LCBsUGFkID0gMikge1xuICAgICAgcmV0dXJuIHYucGFkU3RhcnQobFBhZCwgXCIwXCIpO1xuICAgIH1cbiAgICBjb25zdCBtID0gZHRQYWQoKHZhbHVlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBkID0gZHRQYWQodmFsdWUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IGggPSBkdFBhZCh2YWx1ZS5nZXRVVENIb3VycygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IG1pbiA9IGR0UGFkKHZhbHVlLmdldFVUQ01pbnV0ZXMoKS50b1N0cmluZygpKTtcbiAgICBjb25zdCBzID0gZHRQYWQodmFsdWUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkpO1xuICAgIGNvbnN0IG1zID0gZHRQYWQodmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkudG9TdHJpbmcoKSwgMyk7XG4gICAgLy8gZm9ybWF0dGVkIGRhdGVcbiAgICBjb25zdCBmRGF0YSA9IGAke3ZhbHVlLmdldFVUQ0Z1bGxZZWFyKCl9LSR7bX0tJHtkfVQke2h9OiR7bWlufToke3N9LiR7bXN9YDtcbiAgICByZXR1cm4gZkRhdGE7XG4gIH1cbiAgI2RhdGVEZWNsYXJhdGlvbihrZXlzLCB2YWx1ZSkge1xuICAgIHJldHVybiBgJHt0aGlzLiNkZWNsYXJhdGlvbihrZXlzKX0ke3RoaXMuI3ByaW50RGF0ZSh2YWx1ZSl9YDtcbiAgfVxuICAjZm9ybWF0KG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsga2V5QWxpZ25tZW50ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgckRlY2xhcmF0aW9uID0gL14oXFxcIi4qXFxcInxbXj1dKilcXHM9LztcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXQubGVuZ3RoOyBpKyspe1xuICAgICAgY29uc3QgbCA9IHRoaXMub3V0cHV0W2ldO1xuICAgICAgLy8gd2Uga2VlcCBlbXB0eSBlbnRyeSBmb3IgYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgaWYgKGxbMF0gPT09IFwiW1wiICYmIGxbMV0gIT09IFwiW1wiKSB7XG4gICAgICAgIC8vIG5vbi1lbXB0eSBvYmplY3Qgd2l0aCBvbmx5IHN1Ym9iamVjdHMgYXMgcHJvcGVydGllc1xuICAgICAgICBpZiAodGhpcy5vdXRwdXRbaSArIDFdID09PSBcIlwiICYmIHRoaXMub3V0cHV0W2kgKyAyXT8uc2xpY2UoMCwgbC5sZW5ndGgpID09PSBsLnNsaWNlKDAsIC0xKSArIFwiLlwiKSB7XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGtleUFsaWdubWVudCkge1xuICAgICAgICAgIGNvbnN0IG0gPSByRGVjbGFyYXRpb24uZXhlYyhsKTtcbiAgICAgICAgICBpZiAobSAmJiBtWzFdKSB7XG4gICAgICAgICAgICBvdXQucHVzaChsLnJlcGxhY2UobVsxXSwgbVsxXS5wYWRFbmQodGhpcy5tYXhQYWQpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dC5wdXNoKGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXQucHVzaChsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhbmluZyBtdWx0aXBsZSBzcGFjZXNcbiAgICBjb25zdCBjbGVhbmVkT3V0cHV0ID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKyl7XG4gICAgICBjb25zdCBsID0gb3V0W2ldO1xuICAgICAgaWYgKCEobCA9PT0gXCJcIiAmJiBvdXRbaSArIDFdID09PSBcIlwiKSkge1xuICAgICAgICBjbGVhbmVkT3V0cHV0LnB1c2gobCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGVhbmVkT3V0cHV0O1xuICB9XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIG9iamVjdCB0byBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tIFwiQHN0ZC90b21sL3N0cmluZ2lmeVwiO1xuICogaW1wb3J0IHsgYXNzZXJ0RXF1YWxzIH0gZnJvbSBcIkBzdGQvYXNzZXJ0XCI7XG4gKlxuICogY29uc3Qgb2JqID0ge1xuICogICB0aXRsZTogXCJUT01MIEV4YW1wbGVcIixcbiAqICAgb3duZXI6IHtcbiAqICAgICBuYW1lOiBcIkJvYlwiLFxuICogICAgIGJpbzogXCJCb2IgaXMgYSBjb29sIGd1eVwiLFxuICogIH1cbiAqIH07XG4gKiBjb25zdCB0b21sU3RyaW5nID0gc3RyaW5naWZ5KG9iaik7XG4gKiBhc3NlcnRFcXVhbHModG9tbFN0cmluZywgYHRpdGxlID0gXCJUT01MIEV4YW1wbGVcIlxcblxcbltvd25lcl1cXG5uYW1lID0gXCJCb2JcIlxcbmJpbyA9IFwiQm9iIGlzIGEgY29vbCBndXlcIlxcbmApO1xuICogYGBgXG4gKiBAcGFyYW0gb2JqIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHN0cmluZ2lmeWluZy5cbiAqIEByZXR1cm5zIFRPTUwgc3RyaW5nXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShvYmosIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBEdW1wZXIob2JqKS5kdW1wKG9wdGlvbnMpLmpvaW4oXCJcXG5cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdpZnkuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbi8qKlxuICogRmlsdGVycyB0aGUgZ2l2ZW4gYXJyYXksIHJlbW92aW5nIGFsbCBlbGVtZW50cyB0aGF0IGRvIG5vdCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlXG4gKiAqKmluIHBsYWNlLiBUaGlzIG1lYW5zIGBhcnJheWAgd2lsbCBiZSBtb2RpZmllZCEqKi5cbiAqLyBleHBvcnQgZnVuY3Rpb24gZmlsdGVySW5QbGFjZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIGxldCBvdXRwdXRJbmRleCA9IDA7XG4gIGZvciAoY29uc3QgY3VyIG9mIGFycmF5KXtcbiAgICBpZiAoIXByZWRpY2F0ZShjdXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYXJyYXlbb3V0cHV0SW5kZXhdID0gY3VyO1xuICAgIG91dHB1dEluZGV4ICs9IDE7XG4gIH1cbiAgYXJyYXkuc3BsaWNlKG91dHB1dEluZGV4KTtcbiAgcmV0dXJuIGFycmF5O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3V0aWxzLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBmaWx0ZXJJblBsYWNlIH0gZnJvbSBcIi4vX3V0aWxzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gZGVlcE1lcmdlKHJlY29yZCwgb3RoZXIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRlZXBNZXJnZUludGVybmFsKHJlY29yZCwgb3RoZXIsIG5ldyBTZXQoKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkZWVwTWVyZ2VJbnRlcm5hbChyZWNvcmQsIG90aGVyLCBzZWVuLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBjb25zdCBrZXlzID0gbmV3IFNldChbXG4gICAgLi4uZ2V0S2V5cyhyZWNvcmQpLFxuICAgIC4uLmdldEtleXMob3RoZXIpXG4gIF0pO1xuICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBrZXkgb2Ygb3RoZXIgb2JqZWN0IGFuZCB1c2UgY29ycmVjdCBtZXJnaW5nIHN0cmF0ZWd5XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpe1xuICAgIC8vIFNraXAgdG8gcHJldmVudCBPYmplY3QucHJvdG90eXBlLl9fcHJvdG9fXyBhY2Nlc3NvciBwcm9wZXJ0eSBjYWxscyBvbiBub24tRGVubyBwbGF0Zm9ybXNcbiAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHJlY29yZFtrZXldO1xuICAgIGlmICghT2JqZWN0Lmhhc093bihvdGhlciwga2V5KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBhO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGIgPSBvdGhlcltrZXldO1xuICAgIGlmIChpc05vbk51bGxPYmplY3QoYSkgJiYgaXNOb25OdWxsT2JqZWN0KGIpICYmICFzZWVuLmhhcyhhKSAmJiAhc2Vlbi5oYXMoYikpIHtcbiAgICAgIHNlZW4uYWRkKGEpO1xuICAgICAgc2Vlbi5hZGQoYik7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhhLCBiLCBzZWVuLCBvcHRpb25zKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB2YWx1ZVxuICAgIHJlc3VsdFtrZXldID0gYjtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWVyZ2VPYmplY3RzKGxlZnQsIHJpZ2h0LCBzZWVuLCBvcHRpb25zID0ge1xuICBhcnJheXM6IFwibWVyZ2VcIixcbiAgc2V0czogXCJtZXJnZVwiLFxuICBtYXBzOiBcIm1lcmdlXCJcbn0pIHtcbiAgLy8gUmVjdXJzaXZlbHkgbWVyZ2UgbWVyZ2VhYmxlIG9iamVjdHNcbiAgaWYgKGlzTWVyZ2VhYmxlKGxlZnQpICYmIGlzTWVyZ2VhYmxlKHJpZ2h0KSkge1xuICAgIHJldHVybiBkZWVwTWVyZ2VJbnRlcm5hbChsZWZ0LCByaWdodCwgc2Vlbiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzSXRlcmFibGUobGVmdCkgJiYgaXNJdGVyYWJsZShyaWdodCkpIHtcbiAgICAvLyBIYW5kbGUgYXJyYXlzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGVmdCkgJiYgQXJyYXkuaXNBcnJheShyaWdodCkpIHtcbiAgICAgIGlmIChvcHRpb25zLmFycmF5cyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBsZWZ0LmNvbmNhdChyaWdodCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmlnaHQ7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBtYXBzXG4gICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBNYXAgJiYgcmlnaHQgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgIGlmIChvcHRpb25zLm1hcHMgPT09IFwibWVyZ2VcIikge1xuICAgICAgICByZXR1cm4gbmV3IE1hcChbXG4gICAgICAgICAgLi4ubGVmdCxcbiAgICAgICAgICAuLi5yaWdodFxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByaWdodDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHNldHNcbiAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFNldCAmJiByaWdodCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgaWYgKG9wdGlvbnMuc2V0cyA9PT0gXCJtZXJnZVwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KFtcbiAgICAgICAgICAuLi5sZWZ0LFxuICAgICAgICAgIC4uLnJpZ2h0XG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmlnaHQ7XG59XG4vKipcbiAqIFRlc3Qgd2hldGhlciBhIHZhbHVlIGlzIG1lcmdlYWJsZSBvciBub3RcbiAqIEJ1aWx0aW5zIHRoYXQgbG9vayBsaWtlIG9iamVjdHMsIG51bGwgYW5kIHVzZXIgZGVmaW5lZCBjbGFzc2VzXG4gKiBhcmUgbm90IGNvbnNpZGVyZWQgbWVyZ2VhYmxlIChpdCBtZWFucyB0aGF0IHJlZmVyZW5jZSB3aWxsIGJlIGNvcGllZClcbiAqLyBmdW5jdGlvbiBpc01lcmdlYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBpc05vbk51bGxPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGdldEtleXMocmVjb3JkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocmVjb3JkKTtcbiAgZmlsdGVySW5QbGFjZShyZXN1bHQsIChrZXkpPT5PYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocmVjb3JkLCBrZXkpKTtcbiAgcmVzdWx0LnB1c2goLi4uT2JqZWN0LmtleXMocmVjb3JkKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWVwX21lcmdlLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE4LTIwMjUgdGhlIERlbm8gYXV0aG9ycy4gTUlUIGxpY2Vuc2UuXG4vLyBUaGlzIG1vZHVsZSBpcyBicm93c2VyIGNvbXBhdGlibGUuXG5pbXBvcnQgeyBkZWVwTWVyZ2UgfSBmcm9tIFwiQGpzci9zdGRfX2NvbGxlY3Rpb25zL2RlZXAtbWVyZ2VcIjtcbi8qKlxuICogQ29weSBvZiBgaW1wb3J0IHsgaXNMZWFwIH0gZnJvbSBcIkBzdGQvZGF0ZXRpbWVcIjtgIGJlY2F1c2UgaXQgY2Fubm90IGJlIGltcG90ZWQgYXMgbG9uZyBhcyBpdCBpcyB1bnN0YWJsZS5cbiAqLyBmdW5jdGlvbiBpc0xlYXAoeWVhck51bWJlcikge1xuICByZXR1cm4geWVhck51bWJlciAlIDQgPT09IDAgJiYgeWVhck51bWJlciAlIDEwMCAhPT0gMCB8fCB5ZWFyTnVtYmVyICUgNDAwID09PSAwO1xufVxuZXhwb3J0IGNsYXNzIFNjYW5uZXIge1xuICAjd2hpdGVzcGFjZSA9IC9bIFxcdF0vO1xuICAjcG9zaXRpb24gPSAwO1xuICAjc291cmNlO1xuICBjb25zdHJ1Y3Rvcihzb3VyY2Upe1xuICAgIHRoaXMuI3NvdXJjZSA9IHNvdXJjZTtcbiAgfVxuICBnZXQgcG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uO1xuICB9XG4gIGdldCBzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZTtcbiAgfVxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgY2hhcmFjdGVyXG4gICAqIEBwYXJhbSBpbmRleCAtIHJlbGF0aXZlIGluZGV4IGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gY2hhcihpbmRleCA9IDApIHtcbiAgICByZXR1cm4gdGhpcy4jc291cmNlW3RoaXMuI3Bvc2l0aW9uICsgaW5kZXhdID8/IFwiXCI7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBzbGljZWQgc3RyaW5nXG4gICAqIEBwYXJhbSBzdGFydCAtIHN0YXJ0IHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKiBAcGFyYW0gZW5kIC0gZW5kIHBvc2l0aW9uIHJlbGF0aXZlIGZyb20gY3VycmVudCBwb3NpdGlvblxuICAgKi8gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2Uuc2xpY2UodGhpcy4jcG9zaXRpb24gKyBzdGFydCwgdGhpcy4jcG9zaXRpb24gKyBlbmQpO1xuICB9XG4gIC8qKlxuICAgKiBNb3ZlIHBvc2l0aW9uIHRvIG5leHRcbiAgICovIG5leHQoY291bnQgPSAxKSB7XG4gICAgdGhpcy4jcG9zaXRpb24gKz0gY291bnQ7XG4gIH1cbiAgc2tpcFdoaXRlc3BhY2VzKCkge1xuICAgIHdoaWxlKHRoaXMuI3doaXRlc3BhY2UudGVzdCh0aGlzLmNoYXIoKSkgJiYgIXRoaXMuZW9mKCkpe1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIC8vIEludmFsaWQgaWYgY3VycmVudCBjaGFyIGlzIG90aGVyIGtpbmRzIG9mIHdoaXRlc3BhY2VcbiAgICBpZiAoIXRoaXMuaXNDdXJyZW50Q2hhckVPTCgpICYmIC9cXHMvLnRlc3QodGhpcy5jaGFyKCkpKSB7XG4gICAgICBjb25zdCBlc2NhcGVkID0gXCJcXFxcdVwiICsgdGhpcy5jaGFyKCkuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdGhlIFRPTUw6IEl0IGNvbnRhaW5zIGludmFsaWQgd2hpdGVzcGFjZSBhdCBwb3NpdGlvbiAnJHtwb3NpdGlvbn0nOiBcXGAke2VzY2FwZWR9XFxgYCk7XG4gICAgfVxuICB9XG4gIG5leHRVbnRpbENoYXIob3B0aW9ucyA9IHtcbiAgICBza2lwQ29tbWVudHM6IHRydWVcbiAgfSkge1xuICAgIHdoaWxlKCF0aGlzLmVvZigpKXtcbiAgICAgIGNvbnN0IGNoYXIgPSB0aGlzLmNoYXIoKTtcbiAgICAgIGlmICh0aGlzLiN3aGl0ZXNwYWNlLnRlc3QoY2hhcikgfHwgdGhpcy5pc0N1cnJlbnRDaGFyRU9MKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2tpcENvbW1lbnRzICYmIHRoaXMuY2hhcigpID09PSBcIiNcIikge1xuICAgICAgICAvLyBlbnRlcmluZyBjb21tZW50XG4gICAgICAgIHdoaWxlKCF0aGlzLmlzQ3VycmVudENoYXJFT0woKSAmJiAhdGhpcy5lb2YoKSl7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogUG9zaXRpb24gcmVhY2hlZCBFT0Ygb3Igbm90XG4gICAqLyBlb2YoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uID49IHRoaXMuI3NvdXJjZS5sZW5ndGg7XG4gIH1cbiAgaXNDdXJyZW50Q2hhckVPTCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFyKCkgPT09IFwiXFxuXCIgfHwgdGhpcy5zdGFydHNXaXRoKFwiXFxyXFxuXCIpO1xuICB9XG4gIHN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NvdXJjZS5zdGFydHNXaXRoKHNlYXJjaFN0cmluZywgdGhpcy4jcG9zaXRpb24pO1xuICB9XG4gIG1hdGNoKHJlZ0V4cCkge1xuICAgIGlmICghcmVnRXhwLnN0aWNreSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWdFeHAgJHtyZWdFeHB9IGRvZXMgbm90IGhhdmUgYSBzdGlja3kgJ3knIGZsYWdgKTtcbiAgICB9XG4gICAgcmVnRXhwLmxhc3RJbmRleCA9IHRoaXMuI3Bvc2l0aW9uO1xuICAgIHJldHVybiB0aGlzLiNzb3VyY2UubWF0Y2gocmVnRXhwKTtcbiAgfVxufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFV0aWxpdGllc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHN1Y2Nlc3MoYm9keSkge1xuICByZXR1cm4ge1xuICAgIG9rOiB0cnVlLFxuICAgIGJvZHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGZhaWx1cmUoKSB7XG4gIHJldHVybiB7XG4gICAgb2s6IGZhbHNlXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhlIGtleXMgYW5kIHZhbHVlcy5cbiAqXG4gKiBlLmcuIGB1bmZsYXQoW1wiYVwiLCBcImJcIiwgXCJjXCJdLCAxKWAgcmV0dXJucyBgeyBhOiB7IGI6IHsgYzogMSB9IH0gfWBcbiAqLyBleHBvcnQgZnVuY3Rpb24gdW5mbGF0KGtleXMsIHZhbHVlcyA9IHtcbiAgX19wcm90b19fOiBudWxsXG59KSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZVJpZ2h0KChhY2MsIGtleSk9Pih7XG4gICAgICBba2V5XTogYWNjXG4gICAgfSksIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKSB7XG4gIGNvbnN0IGtleSA9IGtleXNbMF07XG4gIGlmICgha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHBhcnNlIHRoZSBUT01MOiBrZXkgbGVuZ3RoIGlzIG5vdCBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0W2tleV07XG59XG5mdW5jdGlvbiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCB0YWJsZSkge1xuICBjb25zdCB7IGtleXMsIHR5cGUsIHZhbHVlIH0gPSB0YWJsZTtcbiAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0VGFyZ2V0VmFsdWUodGFyZ2V0LCBrZXlzKTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB1bmZsYXQoa2V5cywgdmFsdWUpKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpKSB7XG4gICAgY29uc3QgbGFzdCA9IGN1cnJlbnRWYWx1ZS5hdCgtMSk7XG4gICAgZGVlcEFzc2lnbihsYXN0LCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmZ1bmN0aW9uIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgdGFibGUpIHtcbiAgY29uc3QgeyB0eXBlLCBrZXlzLCB2YWx1ZSB9ID0gdGFibGU7XG4gIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGdldFRhcmdldFZhbHVlKHRhcmdldCwga2V5cyk7XG4gIGlmIChjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRhcmdldCwgdW5mbGF0KGtleXMsIFtcbiAgICAgIHZhbHVlXG4gICAgXSkpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRWYWx1ZSkpIHtcbiAgICBpZiAodGFibGUua2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdCA9IGN1cnJlbnRWYWx1ZS5hdCgtMSk7XG4gICAgICBkZWVwQXNzaWduKGxhc3QsIHtcbiAgICAgICAgdHlwZTogdGFibGUudHlwZSxcbiAgICAgICAga2V5czogdGFibGUua2V5cy5zbGljZSgxKSxcbiAgICAgICAgdmFsdWU6IHRhYmxlLnZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBpZiAoaXNPYmplY3QoY3VycmVudFZhbHVlKSkge1xuICAgIGRlZXBBc3NpZ24oY3VycmVudFZhbHVlLCB7XG4gICAgICB0eXBlLFxuICAgICAga2V5czoga2V5cy5zbGljZSgxKSxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGFzc2lnblwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgYm9keSkge1xuICBzd2l0Y2goYm9keS50eXBlKXtcbiAgICBjYXNlIFwiQmxvY2tcIjpcbiAgICAgIHJldHVybiBkZWVwTWVyZ2UodGFyZ2V0LCBib2R5LnZhbHVlKTtcbiAgICBjYXNlIFwiVGFibGVcIjpcbiAgICAgIHJldHVybiBkZWVwQXNzaWduVGFibGUodGFyZ2V0LCBib2R5KTtcbiAgICBjYXNlIFwiVGFibGVBcnJheVwiOlxuICAgICAgcmV0dXJuIGRlZXBBc3NpZ25UYWJsZUFycmF5KHRhcmdldCwgYm9keSk7XG4gIH1cbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbWJpbmF0b3JzIGFuZCBnZW5lcmF0b3JzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiBvcihwYXJzZXJzKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBmb3IgKGNvbnN0IHBhcnNlIG9mIHBhcnNlcnMpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2Uoc2Nhbm5lcik7XG4gICAgICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZmFpbHVyZSgpO1xuICB9O1xufVxuLyoqIEpvaW4gdGhlIHBhcnNlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIHBhcnNlciBpbnRvIGFuIGFycmF5LlxuICpcbiAqIElmIHRoZSBwYXJzZXIgZmFpbHMgYXQgdGhlIGZpcnN0IGF0dGVtcHQsIGl0IHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5LlxuICovIGZ1bmN0aW9uIGpvaW4ocGFyc2VyLCBzZXBhcmF0b3IpIHtcbiAgY29uc3QgU2VwYXJhdG9yID0gY2hhcmFjdGVyKHNlcGFyYXRvcik7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBvdXQgPSBbXTtcbiAgICBjb25zdCBmaXJzdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIWZpcnN0Lm9rKSByZXR1cm4gc3VjY2VzcyhvdXQpO1xuICAgIG91dC5wdXNoKGZpcnN0LmJvZHkpO1xuICAgIHdoaWxlKCFzY2FubmVyLmVvZigpKXtcbiAgICAgIGlmICghU2VwYXJhdG9yKHNjYW5uZXIpLm9rKSBicmVhaztcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCB0b2tlbiBhZnRlciBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChyZXN1bHQuYm9keSk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzKG91dCk7XG4gIH07XG59XG4vKiogSm9pbiB0aGUgcGFyc2UgcmVzdWx0cyBvZiB0aGUgZ2l2ZW4gcGFyc2VyIGludG8gYW4gYXJyYXkuXG4gKlxuICogVGhpcyByZXF1aXJlcyB0aGUgcGFyc2VyIHRvIHN1Y2NlZWQgYXQgbGVhc3Qgb25jZS5cbiAqLyBmdW5jdGlvbiBqb2luMShwYXJzZXIsIHNlcGFyYXRvcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IGZpcnN0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghZmlyc3Qub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgb3V0ID0gW1xuICAgICAgZmlyc3QuYm9keVxuICAgIF07XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgaWYgKCFTZXBhcmF0b3Ioc2Nhbm5lcikub2spIGJyZWFrO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIHRva2VuIGFmdGVyIFwiJHtzZXBhcmF0b3J9XCJgKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3Mob3V0KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGt2KGtleVBhcnNlciwgc2VwYXJhdG9yLCB2YWx1ZVBhcnNlcikge1xuICBjb25zdCBTZXBhcmF0b3IgPSBjaGFyYWN0ZXIoc2VwYXJhdG9yKTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHBvc2l0aW9uID0gc2Nhbm5lci5wb3NpdGlvbjtcbiAgICBjb25zdCBrZXkgPSBrZXlQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCFrZXkub2spIHJldHVybiBmYWlsdXJlKCk7XG4gICAgY29uc3Qgc2VwID0gU2VwYXJhdG9yKHNjYW5uZXIpO1xuICAgIGlmICghc2VwLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYGtleS92YWx1ZSBwYWlyIGRvZXNuJ3QgaGF2ZSBcIiR7c2VwYXJhdG9yfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVQYXJzZXIoc2Nhbm5lcik7XG4gICAgaWYgKCF2YWx1ZS5vaykge1xuICAgICAgY29uc3QgbGluZUVuZEluZGV4ID0gc2Nhbm5lci5zb3VyY2UuaW5kZXhPZihcIlxcblwiLCBzY2FubmVyLnBvc2l0aW9uKTtcbiAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gbGluZUVuZEluZGV4ID4gMCA/IGxpbmVFbmRJbmRleCA6IHNjYW5uZXIuc291cmNlLmxlbmd0aDtcbiAgICAgIGNvbnN0IGxpbmUgPSBzY2FubmVyLnNvdXJjZS5zbGljZShwb3NpdGlvbiwgZW5kUG9zaXRpb24pO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBDYW5ub3QgcGFyc2UgdmFsdWUgb24gbGluZSAnJHtsaW5lfSdgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3ModW5mbGF0KGtleS5ib2R5LCB2YWx1ZS5ib2R5KSk7XG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZShwYXJzZXIpIHtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICBpZiAoIXJlc3VsdC5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICBsZXQgYm9keSA9IHtcbiAgICAgIF9fcHJvdG9fXzogbnVsbFxuICAgIH07XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVzdWx0LmJvZHkpe1xuICAgICAgaWYgKHR5cGVvZiByZWNvcmQgPT09IFwib2JqZWN0XCIgJiYgcmVjb3JkICE9PSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBkZWVwTWVyZ2UoYm9keSwgcmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiByZXBlYXQocGFyc2VyKSB7XG4gIHJldHVybiAoc2Nhbm5lcik9PntcbiAgICBjb25zdCBib2R5ID0gW107XG4gICAgd2hpbGUoIXNjYW5uZXIuZW9mKCkpe1xuICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgICAgYm9keS5wdXNoKHJlc3VsdC5ib2R5KTtcbiAgICAgIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICAgIH1cbiAgICBpZiAoYm9keS5sZW5ndGggPT09IDApIHJldHVybiBmYWlsdXJlKCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3MoYm9keSk7XG4gIH07XG59XG5mdW5jdGlvbiBzdXJyb3VuZChsZWZ0LCBwYXJzZXIsIHJpZ2h0KSB7XG4gIGNvbnN0IExlZnQgPSBjaGFyYWN0ZXIobGVmdCk7XG4gIGNvbnN0IFJpZ2h0ID0gY2hhcmFjdGVyKHJpZ2h0KTtcbiAgcmV0dXJuIChzY2FubmVyKT0+e1xuICAgIGlmICghTGVmdChzY2FubmVyKS5vaykge1xuICAgICAgcmV0dXJuIGZhaWx1cmUoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VyKHNjYW5uZXIpO1xuICAgIGlmICghcmVzdWx0Lm9rKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgdG9rZW4gYWZ0ZXIgXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgaWYgKCFSaWdodChzY2FubmVyKS5vaykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBOb3QgY2xvc2VkIGJ5IFwiJHtyaWdodH1cIiBhZnRlciBzdGFydGVkIHdpdGggXCIke2xlZnR9XCJgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1Y2Nlc3MocmVzdWx0LmJvZHkpO1xuICB9O1xufVxuZnVuY3Rpb24gY2hhcmFjdGVyKHN0cikge1xuICByZXR1cm4gKHNjYW5uZXIpPT57XG4gICAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aChzdHIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICAgIHNjYW5uZXIubmV4dChzdHIubGVuZ3RoKTtcbiAgICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICAgIHJldHVybiBzdWNjZXNzKHVuZGVmaW5lZCk7XG4gIH07XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUGFyc2VyIGNvbXBvbmVudHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jb25zdCBCQVJFX0tFWV9SRUdFWFAgPSAvW0EtWmEtejAtOV8tXSsveTtcbmV4cG9ydCBmdW5jdGlvbiBiYXJlS2V5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3Qga2V5ID0gc2Nhbm5lci5tYXRjaChCQVJFX0tFWV9SRUdFWFApPy5bMF07XG4gIGlmICgha2V5KSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoa2V5Lmxlbmd0aCk7XG4gIHJldHVybiBzdWNjZXNzKGtleSk7XG59XG5mdW5jdGlvbiBlc2NhcGVTZXF1ZW5jZShzY2FubmVyKSB7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJcXFxcXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICAvLyBTZWUgaHR0cHM6Ly90b21sLmlvL2VuL3YxLjAuMC1yYy4zI3N0cmluZ1xuICBzd2l0Y2goc2Nhbm5lci5jaGFyKCkpe1xuICAgIGNhc2UgXCJiXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxiXCIpO1xuICAgIGNhc2UgXCJ0XCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFx0XCIpO1xuICAgIGNhc2UgXCJuXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxuXCIpO1xuICAgIGNhc2UgXCJmXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxmXCIpO1xuICAgIGNhc2UgXCJyXCI6XG4gICAgICBzY2FubmVyLm5leHQoKTtcbiAgICAgIHJldHVybiBzdWNjZXNzKFwiXFxyXCIpO1xuICAgIGNhc2UgXCJ1XCI6XG4gICAgY2FzZSBcIlVcIjpcbiAgICAgIHtcbiAgICAgICAgLy8gVW5pY29kZSBjaGFyYWN0ZXJcbiAgICAgICAgY29uc3QgY29kZVBvaW50TGVuID0gc2Nhbm5lci5jaGFyKCkgPT09IFwidVwiID8gNCA6IDY7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IHBhcnNlSW50KFwiMHhcIiArIHNjYW5uZXIuc2xpY2UoMSwgMSArIGNvZGVQb2ludExlbiksIDE2KTtcbiAgICAgICAgY29uc3Qgc3RyID0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgICAgc2Nhbm5lci5uZXh0KGNvZGVQb2ludExlbiArIDEpO1xuICAgICAgICByZXR1cm4gc3VjY2VzcyhzdHIpO1xuICAgICAgfVxuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoJ1wiJyk7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgcmV0dXJuIHN1Y2Nlc3MoXCJcXFxcXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlOiBcXFxcJHtzY2FubmVyLmNoYXIoKX1gKTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGJhc2ljU3RyaW5nKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSAnXCInKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSAnXCInICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBpZiAoc2Nhbm5lci5jaGFyKCkgPT09IFwiXFxuXCIpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlNpbmdsZS1saW5lIHN0cmluZyBjYW5ub3QgY29udGFpbiBFT0xcIik7XG4gICAgfVxuICAgIGNvbnN0IGVzY2FwZWRDaGFyID0gZXNjYXBlU2VxdWVuY2Uoc2Nhbm5lcik7XG4gICAgaWYgKGVzY2FwZWRDaGFyLm9rKSB7XG4gICAgICBhY2MucHVzaChlc2NhcGVkQ2hhci5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWNjLnB1c2goc2Nhbm5lci5jaGFyKCkpO1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgfVxuICB9XG4gIGlmIChzY2FubmVyLmVvZigpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBTaW5nbGUtbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIHNjYW5uZXIubmV4dCgpOyAvLyBza2lwIGxhc3QgJ1wiXCJcbiAgcmV0dXJuIHN1Y2Nlc3MoYWNjLmpvaW4oXCJcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWxTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoc2Nhbm5lci5jaGFyKCkgIT09IFwiJ1wiKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoKTtcbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKHNjYW5uZXIuY2hhcigpICE9PSBcIidcIiAmJiAhc2Nhbm5lci5lb2YoKSl7XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJTaW5nbGUtbGluZSBzdHJpbmcgY2Fubm90IGNvbnRhaW4gRU9MXCIpO1xuICAgIH1cbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFNpbmdsZS1saW5lIHN0cmluZyBpcyBub3QgY2xvc2VkOlxcbiR7YWNjLmpvaW4oXCJcIil9YCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0KCk7IC8vIHNraXAgbGFzdCBcIidcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lQmFzaWNTdHJpbmcoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBpZiAoIXNjYW5uZXIuc3RhcnRzV2l0aCgnXCJcIlwiJykpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgzKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigpID09PSBcIlxcblwiKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKExGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxyXFxuXCIpKSB7XG4gICAgLy8gVGhlIGZpcnN0IG5ld2xpbmUgKENSTEYpIGlzIHRyaW1tZWRcbiAgICBzY2FubmVyLm5leHQoMik7XG4gIH1cbiAgY29uc3QgYWNjID0gW107XG4gIHdoaWxlKCFzY2FubmVyLnN0YXJ0c1dpdGgoJ1wiXCJcIicpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICAvLyBsaW5lIGVuZGluZyBiYWNrc2xhc2hcbiAgICBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoc2Nhbm5lci5zdGFydHNXaXRoKFwiXFxcXFxcclxcblwiKSkge1xuICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICBzY2FubmVyLm5leHRVbnRpbENoYXIoe1xuICAgICAgICBza2lwQ29tbWVudHM6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVNlcXVlbmNlKHNjYW5uZXIpO1xuICAgIGlmIChlc2NhcGVkQ2hhci5vaykge1xuICAgICAgYWNjLnB1c2goZXNjYXBlZENoYXIuYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjYy5wdXNoKHNjYW5uZXIuY2hhcigpKTtcbiAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgIH1cbiAgfVxuICBpZiAoc2Nhbm5lci5lb2YoKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgTXVsdGktbGluZSBzdHJpbmcgaXMgbm90IGNsb3NlZDpcXG4ke2FjYy5qb2luKFwiXCIpfWApO1xuICB9XG4gIC8vIGlmIGVuZHMgd2l0aCA0IGBcImAsIHB1c2ggdGhlIGZpc3QgYFwiYCB0byBzdHJpbmdcbiAgaWYgKHNjYW5uZXIuY2hhcigzKSA9PT0gJ1wiJykge1xuICAgIGFjYy5wdXNoKCdcIicpO1xuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9XG4gIHNjYW5uZXIubmV4dCgzKTsgLy8gc2tpcCBsYXN0ICdcIlwiXCJcIlxuICByZXR1cm4gc3VjY2VzcyhhY2Muam9pbihcIlwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbXVsdGlsaW5lTGl0ZXJhbFN0cmluZyhzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmICghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQoMyk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSA9PT0gXCJcXG5cIikge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChMRikgaXMgdHJpbW1lZFxuICAgIHNjYW5uZXIubmV4dCgpO1xuICB9IGVsc2UgaWYgKHNjYW5uZXIuc3RhcnRzV2l0aChcIlxcclxcblwiKSkge1xuICAgIC8vIFRoZSBmaXJzdCBuZXdsaW5lIChDUkxGKSBpcyB0cmltbWVkXG4gICAgc2Nhbm5lci5uZXh0KDIpO1xuICB9XG4gIGNvbnN0IGFjYyA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5zdGFydHNXaXRoKFwiJycnXCIpICYmICFzY2FubmVyLmVvZigpKXtcbiAgICBhY2MucHVzaChzY2FubmVyLmNoYXIoKSk7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgaWYgKHNjYW5uZXIuZW9mKCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYE11bHRpLWxpbmUgc3RyaW5nIGlzIG5vdCBjbG9zZWQ6XFxuJHthY2Muam9pbihcIlwiKX1gKTtcbiAgfVxuICAvLyBpZiBlbmRzIHdpdGggNCBgJ2AsIHB1c2ggdGhlIGZpc3QgYCdgIHRvIHN0cmluZ1xuICBpZiAoc2Nhbm5lci5jaGFyKDMpID09PSBcIidcIikge1xuICAgIGFjYy5wdXNoKFwiJ1wiKTtcbiAgICBzY2FubmVyLm5leHQoKTtcbiAgfVxuICBzY2FubmVyLm5leHQoMyk7IC8vIHNraXAgbGFzdCBcIicnJ1wiXG4gIHJldHVybiBzdWNjZXNzKGFjYy5qb2luKFwiXCIpKTtcbn1cbmNvbnN0IEJPT0xFQU5fUkVHRVhQID0gLyg/OnRydWV8ZmFsc2UpXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbihzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChCT09MRUFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gc3RyaW5nID09PSBcInRydWVcIjtcbiAgcmV0dXJuIHN1Y2Nlc3ModmFsdWUpO1xufVxuY29uc3QgSU5GSU5JVFlfTUFQID0gbmV3IE1hcChbXG4gIFtcbiAgICBcImluZlwiLFxuICAgIEluZmluaXR5XG4gIF0sXG4gIFtcbiAgICBcIitpbmZcIixcbiAgICBJbmZpbml0eVxuICBdLFxuICBbXG4gICAgXCItaW5mXCIsXG4gICAgLUluZmluaXR5XG4gIF1cbl0pO1xuY29uc3QgSU5GSU5JVFlfUkVHRVhQID0gL1srLV0/aW5mXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gaW5maW5pdHkoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goSU5GSU5JVFlfUkVHRVhQKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhaWx1cmUoKTtcbiAgY29uc3Qgc3RyaW5nID0gbWF0Y2hbMF07XG4gIHNjYW5uZXIubmV4dChzdHJpbmcubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBJTkZJTklUWV9NQVAuZ2V0KHN0cmluZyk7XG4gIHJldHVybiBzdWNjZXNzKHZhbHVlKTtcbn1cbmNvbnN0IE5BTl9SRUdFWFAgPSAvWystXT9uYW5cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4oc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTkFOX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IHZhbHVlID0gTmFOO1xuICByZXR1cm4gc3VjY2Vzcyh2YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgZG90dGVkS2V5ID0gam9pbjEob3IoW1xuICBiYXJlS2V5LFxuICBiYXNpY1N0cmluZyxcbiAgbGl0ZXJhbFN0cmluZ1xuXSksIFwiLlwiKTtcbmNvbnN0IEJJTkFSWV9SRUdFWFAgPSAvMGJbMDFdKyg/Ol9bMDFdKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEJJTkFSWV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMik7XG4gIHJldHVybiBpc05hTihudW1iZXIpID8gZmFpbHVyZSgpIDogc3VjY2VzcyhudW1iZXIpO1xufVxuY29uc3QgT0NUQUxfUkVHRVhQID0gLzBvWzAtN10rKD86X1swLTddKykqXFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gb2N0YWwoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goT0NUQUxfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5zbGljZSgyKS5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgbnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDgpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IEhFWF9SRUdFWFAgPSAvMHhbMC05YS1mXSsoPzpfWzAtOWEtZl0rKSpcXGIveWk7XG5leHBvcnQgZnVuY3Rpb24gaGV4KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKEhFWF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnNsaWNlKDIpLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBudW1iZXIgPSBwYXJzZUludCh2YWx1ZSwgMTYpO1xuICByZXR1cm4gaXNOYU4obnVtYmVyKSA/IGZhaWx1cmUoKSA6IHN1Y2Nlc3MobnVtYmVyKTtcbn1cbmNvbnN0IElOVEVHRVJfUkVHRVhQID0gL1srLV0/KD86MHxbMS05XVswLTldKig/Ol9bMC05XSspKilcXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ2VyKHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5za2lwV2hpdGVzcGFjZXMoKTtcbiAgY29uc3QgbWF0Y2ggPSBzY2FubmVyLm1hdGNoKElOVEVHRVJfUkVHRVhQKT8uWzBdO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHQobWF0Y2gubGVuZ3RoKTtcbiAgY29uc3QgdmFsdWUgPSBtYXRjaC5yZXBsYWNlQWxsKFwiX1wiLCBcIlwiKTtcbiAgY29uc3QgaW50ID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgcmV0dXJuIHN1Y2Nlc3MoaW50KTtcbn1cbmNvbnN0IEZMT0FUX1JFR0VYUCA9IC9bKy1dPyg/OjB8WzEtOV1bMC05XSooPzpfWzAtOV0rKSopKD86XFwuWzAtOV0rKD86X1swLTldKykqKT8oPzplWystXT9bMC05XSsoPzpfWzAtOV0rKSopP1xcYi95aTtcbmV4cG9ydCBmdW5jdGlvbiBmbG9hdChzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGNvbnN0IG1hdGNoID0gc2Nhbm5lci5tYXRjaChGTE9BVF9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICBjb25zdCB2YWx1ZSA9IG1hdGNoLnJlcGxhY2VBbGwoXCJfXCIsIFwiXCIpO1xuICBjb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICBpZiAoaXNOYU4oZmxvYXQpKSByZXR1cm4gZmFpbHVyZSgpO1xuICByZXR1cm4gc3VjY2VzcyhmbG9hdCk7XG59XG5jb25zdCBEQVRFX1RJTUVfUkVHRVhQID0gLyg/PHllYXI+XFxkezR9KS0oPzxtb250aD5cXGR7Mn0pLSg/PGRheT5cXGR7Mn0pKD86WyAwLTlUWi46Ky1dKyk/XFxiL3k7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZVRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goREFURV9USU1FX1JFR0VYUCk7XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIGNvbnN0IHN0cmluZyA9IG1hdGNoWzBdO1xuICBzY2FubmVyLm5leHQoc3RyaW5nLmxlbmd0aCk7XG4gIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgLy8gc3BlY2lhbCBjYXNlIGlmIG1vbnRoIGlzIEZlYnJ1YXJ5XG4gIGlmIChncm91cHMubW9udGggPT0gXCIwMlwiKSB7XG4gICAgY29uc3QgZGF5cyA9IHBhcnNlSW50KGdyb3Vwcy5kYXkpO1xuICAgIGlmIChkYXlzID4gMjkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGdyb3Vwcy55ZWFyKTtcbiAgICBpZiAoZGF5cyA+IDI4ICYmICFpc0xlYXAoeWVhcikpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHN0cmluZy50cmltKCkpO1xuICAvLyBpbnZhbGlkIGRhdGVcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBkYXRlIHN0cmluZyBcIiR7bWF0Y2h9XCJgKTtcbiAgfVxuICByZXR1cm4gc3VjY2VzcyhkYXRlKTtcbn1cbmNvbnN0IExPQ0FMX1RJTUVfUkVHRVhQID0gLyhcXGR7Mn0pOihcXGR7Mn0pOihcXGR7Mn0pKD86XFwuWzAtOV0rKT9cXGIveTtcbmV4cG9ydCBmdW5jdGlvbiBsb2NhbFRpbWUoc2Nhbm5lcikge1xuICBzY2FubmVyLnNraXBXaGl0ZXNwYWNlcygpO1xuICBjb25zdCBtYXRjaCA9IHNjYW5uZXIubWF0Y2goTE9DQUxfVElNRV9SRUdFWFApPy5bMF07XG4gIGlmICghbWF0Y2gpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dChtYXRjaC5sZW5ndGgpO1xuICByZXR1cm4gc3VjY2VzcyhtYXRjaCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlWYWx1ZShzY2FubmVyKSB7XG4gIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJbXCIpIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dCgpO1xuICBjb25zdCBhcnJheSA9IFtdO1xuICB3aGlsZSghc2Nhbm5lci5lb2YoKSl7XG4gICAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoc2Nhbm5lcik7XG4gICAgaWYgKCFyZXN1bHQub2spIGJyZWFrO1xuICAgIGFycmF5LnB1c2gocmVzdWx0LmJvZHkpO1xuICAgIHNjYW5uZXIuc2tpcFdoaXRlc3BhY2VzKCk7XG4gICAgLy8gbWF5IGhhdmUgYSBuZXh0IGl0ZW0sIGJ1dCB0cmFpbGluZyBjb21tYSBpcyBhbGxvd2VkIGF0IGFycmF5XG4gICAgaWYgKHNjYW5uZXIuY2hhcigpICE9PSBcIixcIikgYnJlYWs7XG4gICAgc2Nhbm5lci5uZXh0KCk7XG4gIH1cbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGlmIChzY2FubmVyLmNoYXIoKSAhPT0gXCJdXCIpIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFycmF5IGlzIG5vdCBjbG9zZWRcIik7XG4gIHNjYW5uZXIubmV4dCgpO1xuICByZXR1cm4gc3VjY2VzcyhhcnJheSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW5saW5lVGFibGUoc2Nhbm5lcikge1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgaWYgKHNjYW5uZXIuY2hhcigxKSA9PT0gXCJ9XCIpIHtcbiAgICBzY2FubmVyLm5leHQoMik7XG4gICAgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgICAgX19wcm90b19fOiBudWxsXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcGFpcnMgPSBzdXJyb3VuZChcIntcIiwgam9pbihwYWlyLCBcIixcIiksIFwifVwiKShzY2FubmVyKTtcbiAgaWYgKCFwYWlycy5vaykgcmV0dXJuIGZhaWx1cmUoKTtcbiAgbGV0IHRhYmxlID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbFxuICB9O1xuICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMuYm9keSl7XG4gICAgdGFibGUgPSBkZWVwTWVyZ2UodGFibGUsIHBhaXIpO1xuICB9XG4gIHJldHVybiBzdWNjZXNzKHRhYmxlKTtcbn1cbmV4cG9ydCBjb25zdCB2YWx1ZSA9IG9yKFtcbiAgbXVsdGlsaW5lQmFzaWNTdHJpbmcsXG4gIG11bHRpbGluZUxpdGVyYWxTdHJpbmcsXG4gIGJhc2ljU3RyaW5nLFxuICBsaXRlcmFsU3RyaW5nLFxuICBib29sZWFuLFxuICBpbmZpbml0eSxcbiAgbmFuLFxuICBkYXRlVGltZSxcbiAgbG9jYWxUaW1lLFxuICBiaW5hcnksXG4gIG9jdGFsLFxuICBoZXgsXG4gIGZsb2F0LFxuICBpbnRlZ2VyLFxuICBhcnJheVZhbHVlLFxuICBpbmxpbmVUYWJsZVxuXSk7XG5leHBvcnQgY29uc3QgcGFpciA9IGt2KGRvdHRlZEtleSwgXCI9XCIsIHZhbHVlKTtcbmV4cG9ydCBmdW5jdGlvbiBibG9jayhzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCByZXN1bHQgPSBtZXJnZShyZXBlYXQocGFpcikpKHNjYW5uZXIpO1xuICBpZiAocmVzdWx0Lm9rKSByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJCbG9ja1wiLFxuICAgIHZhbHVlOiByZXN1bHQuYm9keVxuICB9KTtcbiAgcmV0dXJuIGZhaWx1cmUoKTtcbn1cbmV4cG9ydCBjb25zdCB0YWJsZUhlYWRlciA9IHN1cnJvdW5kKFwiW1wiLCBkb3R0ZWRLZXksIFwiXVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB0YWJsZShzY2FubmVyKSB7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBoZWFkZXIgPSB0YWJsZUhlYWRlcihzY2FubmVyKTtcbiAgaWYgKCFoZWFkZXIub2spIHJldHVybiBmYWlsdXJlKCk7XG4gIHNjYW5uZXIubmV4dFVudGlsQ2hhcigpO1xuICBjb25zdCBiID0gYmxvY2soc2Nhbm5lcik7XG4gIHJldHVybiBzdWNjZXNzKHtcbiAgICB0eXBlOiBcIlRhYmxlXCIsXG4gICAga2V5czogaGVhZGVyLmJvZHksXG4gICAgdmFsdWU6IGIub2sgPyBiLmJvZHkudmFsdWUgOiB7XG4gICAgICBfX3Byb3RvX186IG51bGxcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGNvbnN0IHRhYmxlQXJyYXlIZWFkZXIgPSBzdXJyb3VuZChcIltbXCIsIGRvdHRlZEtleSwgXCJdXVwiKTtcbmV4cG9ydCBmdW5jdGlvbiB0YWJsZUFycmF5KHNjYW5uZXIpIHtcbiAgc2Nhbm5lci5uZXh0VW50aWxDaGFyKCk7XG4gIGNvbnN0IGhlYWRlciA9IHRhYmxlQXJyYXlIZWFkZXIoc2Nhbm5lcik7XG4gIGlmICghaGVhZGVyLm9rKSByZXR1cm4gZmFpbHVyZSgpO1xuICBzY2FubmVyLm5leHRVbnRpbENoYXIoKTtcbiAgY29uc3QgYiA9IGJsb2NrKHNjYW5uZXIpO1xuICByZXR1cm4gc3VjY2Vzcyh7XG4gICAgdHlwZTogXCJUYWJsZUFycmF5XCIsXG4gICAga2V5czogaGVhZGVyLmJvZHksXG4gICAgdmFsdWU6IGIub2sgPyBiLmJvZHkudmFsdWUgOiB7XG4gICAgICBfX3Byb3RvX186IG51bGxcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvbWwoc2Nhbm5lcikge1xuICBjb25zdCBibG9ja3MgPSByZXBlYXQob3IoW1xuICAgIGJsb2NrLFxuICAgIHRhYmxlQXJyYXksXG4gICAgdGFibGVcbiAgXSkpKHNjYW5uZXIpO1xuICBpZiAoIWJsb2Nrcy5vaykgcmV0dXJuIHN1Y2Nlc3Moe1xuICAgIF9fcHJvdG9fXzogbnVsbFxuICB9KTtcbiAgY29uc3QgYm9keSA9IGJsb2Nrcy5ib2R5LnJlZHVjZShkZWVwQXNzaWduLCB7XG4gICAgX19wcm90b19fOiBudWxsXG4gIH0pO1xuICByZXR1cm4gc3VjY2Vzcyhib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlRXJyb3JNZXNzYWdlKHNjYW5uZXIsIG1lc3NhZ2UpIHtcbiAgY29uc3Qgc3RyaW5nID0gc2Nhbm5lci5zb3VyY2Uuc2xpY2UoMCwgc2Nhbm5lci5wb3NpdGlvbik7XG4gIGNvbnN0IGxpbmVzID0gc3RyaW5nLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCByb3cgPSBsaW5lcy5sZW5ndGg7XG4gIGNvbnN0IGNvbHVtbiA9IGxpbmVzLmF0KC0xKT8ubGVuZ3RoID8/IDA7XG4gIHJldHVybiBgUGFyc2UgZXJyb3Igb24gbGluZSAke3Jvd30sIGNvbHVtbiAke2NvbHVtbn06ICR7bWVzc2FnZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlckZhY3RvcnkocGFyc2VyKSB7XG4gIHJldHVybiAodG9tbFN0cmluZyk9PntcbiAgICBjb25zdCBzY2FubmVyID0gbmV3IFNjYW5uZXIodG9tbFN0cmluZyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlcihzY2FubmVyKTtcbiAgICAgIGlmIChyZXN1bHQub2sgJiYgc2Nhbm5lci5lb2YoKSkgcmV0dXJuIHJlc3VsdC5ib2R5O1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIGNoYXJhY3RlcjogXCIke3NjYW5uZXIuY2hhcigpfVwiYDtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBtZXNzYWdlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihjcmVhdGVQYXJzZUVycm9yTWVzc2FnZShzY2FubmVyLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJJbnZhbGlkIGVycm9yIHR5cGUgY2F1Z2h0XCI7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoY3JlYXRlUGFyc2VFcnJvck1lc3NhZ2Uoc2Nhbm5lciwgbWVzc2FnZSkpO1xuICAgIH1cbiAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9wYXJzZXIuanMubWFwIiwiLy8gQ29weXJpZ2h0IDIwMTgtMjAyNSB0aGUgRGVubyBhdXRob3JzLiBNSVQgbGljZW5zZS5cbi8vIFRoaXMgbW9kdWxlIGlzIGJyb3dzZXIgY29tcGF0aWJsZS5cbmltcG9ydCB7IHBhcnNlckZhY3RvcnksIHRvbWwgfSBmcm9tIFwiLi9fcGFyc2VyLmpzXCI7XG4vKipcbiAqIFBhcnNlcyBhIHtAbGluayBodHRwczovL3RvbWwuaW8gfCBUT01MfSBzdHJpbmcgaW50byBhbiBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgVXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJAc3RkL3RvbWwvcGFyc2VcIjtcbiAqIGltcG9ydCB7IGFzc2VydEVxdWFscyB9IGZyb20gXCJAc3RkL2Fzc2VydFwiO1xuICpcbiAqIGNvbnN0IHRvbWxTdHJpbmcgPSBgdGl0bGUgPSBcIlRPTUwgRXhhbXBsZVwiXG4gKiBbb3duZXJdXG4gKiBuYW1lID0gXCJBbGljZVwiXG4gKiBiaW8gPSBcIkFsaWNlIGlzIGEgcHJvZ3JhbW1lci5cImA7XG4gKlxuICogY29uc3Qgb2JqID0gcGFyc2UodG9tbFN0cmluZyk7XG4gKiBhc3NlcnRFcXVhbHMob2JqLCB7IHRpdGxlOiBcIlRPTUwgRXhhbXBsZVwiLCBvd25lcjogeyBuYW1lOiBcIkFsaWNlXCIsIGJpbzogXCJBbGljZSBpcyBhIHByb2dyYW1tZXIuXCIgfSB9KTtcbiAqIGBgYFxuICogQHBhcmFtIHRvbWxTdHJpbmcgVE9NTCBzdHJpbmcgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKUyBvYmplY3QuXG4gKi8gZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRvbWxTdHJpbmcpIHtcbiAgcmV0dXJuIHBhcnNlckZhY3RvcnkodG9tbCkodG9tbFN0cmluZyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJzZS5qcy5tYXAiLCJpbXBvcnQgeyBjcmVhdGVSZXF1aXJlIH0gZnJvbSBcIm5vZGU6bW9kdWxlXCI7XG5pbXBvcnQgeyBpc0Fic29sdXRlLCBqb2luLCByZXNvbHZlIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gXCJub2RlOnVybFwiO1xuLyoqXG4qIFJlc29sdmUgYW4gYWJzb2x1dGUgcGF0aCBmcm9tIHtAbGluayByb290fSwgYnV0IG9ubHlcbiogaWYge0BsaW5rIGlucHV0fSBpc24ndCBhbHJlYWR5IGFic29sdXRlLlxuKlxuKiBAcGFyYW0gaW5wdXQgVGhlIHBhdGggdG8gcmVzb2x2ZS5cbiogQHBhcmFtIHJvb3QgVGhlIGJhc2UgcGF0aDsgZGVmYXVsdCA9IHByb2Nlc3MuY3dkKClcbiogQHJldHVybnMgVGhlIHJlc29sdmVkIGFic29sdXRlIHBhdGguXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGFic29sdXRlKGlucHV0LCByb290KSB7XG5cdHJldHVybiBpc0Fic29sdXRlKGlucHV0KSA/IGlucHV0IDogcmVzb2x2ZShyb290IHx8IFwiLlwiLCBpbnB1dCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZnJvbShyb290LCBpZGVudCwgc2lsZW50KSB7XG5cdHRyeSB7XG5cdFx0Ly8gTk9URTogZGlycyBuZWVkIGEgdHJhaWxpbmcgXCIvXCIgT1IgZmlsZW5hbWUuIFdpdGggXCIvXCIgcm91dGUsXG5cdFx0Ly8gTm9kZSBhZGRzIFwibm9vcC5qc1wiIGFzIG1haW4gZmlsZSwgc28ganVzdCBkbyBcIm5vb3AuanNcIiBhbnl3YXkuXG5cdFx0bGV0IHIgPSByb290IGluc3RhbmNlb2YgVVJMIHx8IHJvb3Quc3RhcnRzV2l0aChcImZpbGU6Ly9cIikgPyBqb2luKGZpbGVVUkxUb1BhdGgocm9vdCksIFwibm9vcC5qc1wiKSA6IGpvaW4oYWJzb2x1dGUocm9vdCksIFwibm9vcC5qc1wiKTtcblx0XHRyZXR1cm4gY3JlYXRlUmVxdWlyZShyKS5yZXNvbHZlKGlkZW50KTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0aWYgKCFzaWxlbnQpIHRocm93IGVycjtcblx0fVxufVxuZXhwb3J0IGZ1bmN0aW9uIGN3ZChpZGVudCwgc2lsZW50KSB7XG5cdHJldHVybiBmcm9tKHJlc29sdmUoKSwgaWRlbnQsIHNpbGVudCk7XG59XG4iLCJpbXBvcnQgeyBkaXJuYW1lIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgYWJzb2x1dGUgfSBmcm9tIFwiZW1wYXRoaWMvcmVzb2x2ZVwiO1xuLyoqXG4qIEdldCBhbGwgcGFyZW50IGRpcmVjdG9yaWVzIG9mIHtAbGluayBiYXNlfS5cbiogU3RvcHMgYWZ0ZXIge0BsaW5rIE9wdGlvbnNbJ2xhc3QnXX0gaXMgcHJvY2Vzc2VkLlxuKlxuKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhYnNvbHV0ZSBwYXRocyBvZiBhbGwgcGFyZW50IGRpcmVjdG9yaWVzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiB1cChiYXNlLCBvcHRpb25zKSB7XG5cdGxldCB7IGxhc3QsIGN3ZCB9ID0gb3B0aW9ucyB8fCB7fTtcblx0bGV0IHRtcCA9IGFic29sdXRlKGJhc2UsIGN3ZCk7XG5cdGxldCByb290ID0gYWJzb2x1dGUobGFzdCB8fCBcIi9cIiwgY3dkKTtcblx0bGV0IHByZXYsIGFyciA9IFtdO1xuXHR3aGlsZSAocHJldiAhPT0gcm9vdCkge1xuXHRcdGFyci5wdXNoKHRtcCk7XG5cdFx0dG1wID0gZGlybmFtZShwcmV2ID0gdG1wKTtcblx0XHRpZiAodG1wID09PSBwcmV2KSBicmVhaztcblx0fVxuXHRyZXR1cm4gYXJyO1xufVxuIiwiaW1wb3J0IHsgam9pbiB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGV4aXN0c1N5bmMsIHN0YXRTeW5jIH0gZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCAqIGFzIHdhbGsgZnJvbSBcImVtcGF0aGljL3dhbGtcIjtcbi8qKlxuKiBGaW5kIGFuIGl0ZW0gYnkgbmFtZSwgd2Fsa2luZyBwYXJlbnQgZGlyZWN0b3JpZXMgdW50aWwgZm91bmQuXG4qXG4qIEBwYXJhbSBuYW1lIFRoZSBpdGVtIG5hbWUgdG8gZmluZC5cbiogQHJldHVybnMgVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGl0ZW0sIGlmIGZvdW5kLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiB1cChuYW1lLCBvcHRpb25zKSB7XG5cdGxldCBkaXIsIHRtcDtcblx0bGV0IHN0YXJ0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmN3ZCB8fCBcIlwiO1xuXHRmb3IgKGRpciBvZiB3YWxrLnVwKHN0YXJ0LCBvcHRpb25zKSkge1xuXHRcdHRtcCA9IGpvaW4oZGlyLCBuYW1lKTtcblx0XHRpZiAoZXhpc3RzU3luYyh0bXApKSByZXR1cm4gdG1wO1xuXHR9XG59XG4vKipcbiogR2V0IHRoZSBmaXJzdCBwYXRoIHRoYXQgbWF0Y2hlcyBhbnkgb2YgdGhlIG5hbWVzIHByb3ZpZGVkLlxuKlxuKiA+IFtOT1RFXVxuKiA+IFRoZSBvcmRlciBvZiB7QGxpbmsgbmFtZXN9IGlzIHJlc3BlY3RlZC5cbipcbiogQHBhcmFtIG5hbWVzIFRoZSBpdGVtIG5hbWVzIHRvIGZpbmQuXG4qIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBmaXJzdCBpdGVtIGZvdW5kLCBpZiBhbnkuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGFueShuYW1lcywgb3B0aW9ucykge1xuXHRsZXQgZGlyLCBzdGFydCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jd2QgfHwgXCJcIjtcblx0bGV0IGogPSAwLCBsZW4gPSBuYW1lcy5sZW5ndGgsIHRtcDtcblx0Zm9yIChkaXIgb2Ygd2Fsay51cChzdGFydCwgb3B0aW9ucykpIHtcblx0XHRmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcblx0XHRcdHRtcCA9IGpvaW4oZGlyLCBuYW1lc1tqXSk7XG5cdFx0XHRpZiAoZXhpc3RzU3luYyh0bXApKSByZXR1cm4gdG1wO1xuXHRcdH1cblx0fVxufVxuLyoqXG4qIEZpbmQgYSBmaWxlIGJ5IG5hbWUsIHdhbGtpbmcgcGFyZW50IGRpcmVjdG9yaWVzIHVudGlsIGZvdW5kLlxuKlxuKiA+IFtOT1RFXVxuKiA+IFRoaXMgZnVuY3Rpb24gb25seSByZXR1cm5zIGEgdmFsdWUgZm9yIGZpbGUgbWF0Y2hlcy5cbiogPiBBIGRpcmVjdG9yeSBtYXRjaCB3aXRoIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBpZ25vcmVkLlxuKlxuKiBAcGFyYW0gbmFtZSBUaGUgZmlsZSBuYW1lIHRvIGZpbmQuXG4qIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBmaWxlLCBpZiBmb3VuZC5cbiovXG5leHBvcnQgZnVuY3Rpb24gZmlsZShuYW1lLCBvcHRpb25zKSB7XG5cdGxldCBkaXIsIHRtcDtcblx0bGV0IHN0YXJ0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmN3ZCB8fCBcIlwiO1xuXHRmb3IgKGRpciBvZiB3YWxrLnVwKHN0YXJ0LCBvcHRpb25zKSkge1xuXHRcdHRyeSB7XG5cdFx0XHR0bXAgPSBqb2luKGRpciwgbmFtZSk7XG5cdFx0XHRpZiAoc3RhdFN5bmModG1wKS5pc0ZpbGUoKSkgcmV0dXJuIHRtcDtcblx0XHR9IGNhdGNoIHt9XG5cdH1cbn1cbi8qKlxuKiBGaW5kIGEgZGlyZWN0b3J5IGJ5IG5hbWUsIHdhbGtpbmcgcGFyZW50IGRpcmVjdG9yaWVzIHVudGlsIGZvdW5kLlxuKlxuKiA+IFtOT1RFXVxuKiA+IFRoaXMgZnVuY3Rpb24gb25seSByZXR1cm5zIGEgdmFsdWUgZm9yIGRpcmVjdG9yeSBtYXRjaGVzLlxuKiA+IEEgZmlsZSBtYXRjaCB3aXRoIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBpZ25vcmVkLlxuKlxuKiBAcGFyYW0gbmFtZSBUaGUgZGlyZWN0b3J5IG5hbWUgdG8gZmluZC5cbiogQHJldHVybnMgVGhlIGFic29sdXRlIHBhdGggdG8gdGhlIGZpbGUsIGlmIGZvdW5kLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXIobmFtZSwgb3B0aW9ucykge1xuXHRsZXQgZGlyLCB0bXA7XG5cdGxldCBzdGFydCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jd2QgfHwgXCJcIjtcblx0Zm9yIChkaXIgb2Ygd2Fsay51cChzdGFydCwgb3B0aW9ucykpIHtcblx0XHR0cnkge1xuXHRcdFx0dG1wID0gam9pbihkaXIsIG5hbWUpO1xuXHRcdFx0aWYgKHN0YXRTeW5jKHRtcCkuaXNEaXJlY3RvcnkoKSkgcmV0dXJuIHRtcDtcblx0XHR9IGNhdGNoIHt9XG5cdH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlUmVuYW1lQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWydyZW5hbWUnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ1JlbmFtZSB0aGUgTkFQSS1SUyBwcm9qZWN0JyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXInLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICAkJG5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLW5hbWUsLW4nLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IG5hbWUgb2YgdGhlIHByb2plY3QnLFxuICB9KVxuXG4gIGJpbmFyeU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWJpbmFyeS1uYW1lLC1iJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBiaW5hcnkgbmFtZSAqLm5vZGUgZmlsZXMnLFxuICB9KVxuXG4gIHBhY2thZ2VOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLW5hbWUnLCB7XG4gICAgZGVzY3JpcHRpb246ICdUaGUgbmV3IHBhY2thZ2UgbmFtZSBvZiB0aGUgcHJvamVjdCcsXG4gIH0pXG5cbiAgbWFuaWZlc3RQYXRoID0gT3B0aW9uLlN0cmluZygnLS1tYW5pZmVzdC1wYXRoJywgJ0NhcmdvLnRvbWwnLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBDYXJnby50b21sYCcsXG4gIH0pXG5cbiAgcmVwb3NpdG9yeT86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tcmVwb3NpdG9yeScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1RoZSBuZXcgcmVwb3NpdG9yeSBvZiB0aGUgcHJvamVjdCcsXG4gIH0pXG5cbiAgZGVzY3JpcHRpb24/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWRlc2NyaXB0aW9uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnVGhlIG5ldyBkZXNjcmlwdGlvbiBvZiB0aGUgcHJvamVjdCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgICAgbmFtZTogdGhpcy4kJG5hbWUsXG4gICAgICBiaW5hcnlOYW1lOiB0aGlzLmJpbmFyeU5hbWUsXG4gICAgICBwYWNrYWdlTmFtZTogdGhpcy5wYWNrYWdlTmFtZSxcbiAgICAgIG1hbmlmZXN0UGF0aDogdGhpcy5tYW5pZmVzdFBhdGgsXG4gICAgICByZXBvc2l0b3J5OiB0aGlzLnJlcG9zaXRvcnksXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW5hbWUgdGhlIE5BUEktUlMgcHJvamVjdFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlbmFtZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBuYW1lIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBuYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IGJpbmFyeSBuYW1lICoubm9kZSBmaWxlc1xuICAgKi9cbiAgYmluYXJ5TmFtZT86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyBwYWNrYWdlIG5hbWUgb2YgdGhlIHByb2plY3RcbiAgICovXG4gIHBhY2thZ2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBDYXJnby50b21sYFxuICAgKlxuICAgKiBAZGVmYXVsdCAnQ2FyZ28udG9tbCdcbiAgICovXG4gIG1hbmlmZXN0UGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogVGhlIG5ldyByZXBvc2l0b3J5IG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICByZXBvc2l0b3J5Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgbmV3IGRlc2NyaXB0aW9uIG9mIHRoZSBwcm9qZWN0XG4gICAqL1xuICBkZXNjcmlwdGlvbj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucyhvcHRpb25zOiBSZW5hbWVPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgIHBhY2thZ2VKc29uUGF0aDogJ3BhY2thZ2UuanNvbicsXG4gICAgbnBtRGlyOiAnbnBtJyxcbiAgICBtYW5pZmVzdFBhdGg6ICdDYXJnby50b21sJyxcbiAgICAuLi5vcHRpb25zLFxuICB9XG59XG4iLCJpbXBvcnQgeyBleGlzdHNTeW5jIH0gZnJvbSAnbm9kZTpmcydcbmltcG9ydCB7IHJlbmFtZSB9IGZyb20gJ25vZGU6ZnMvcHJvbWlzZXMnXG5pbXBvcnQgeyByZXNvbHZlLCBqb2luIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBwYXJzZSBhcyBwYXJzZVRvbWwsIHN0cmluZ2lmeSBhcyBzdHJpbmdpZnlUb21sIH0gZnJvbSAnQHN0ZC90b21sJ1xuaW1wb3J0IHsgbG9hZCBhcyB5YW1sUGFyc2UsIGR1bXAgYXMgeWFtbFN0cmluZ2lmeSB9IGZyb20gJ2pzLXlhbWwnXG5pbXBvcnQgeyBpc05pbCwgbWVyZ2UsIG9taXRCeSwgcGljayB9IGZyb20gJ2VzLXRvb2xraXQnXG5pbXBvcnQgKiBhcyBmaW5kIGZyb20gJ2VtcGF0aGljL2ZpbmQnXG5cbmltcG9ydCB7IGFwcGx5RGVmYXVsdFJlbmFtZU9wdGlvbnMsIHR5cGUgUmVuYW1lT3B0aW9ucyB9IGZyb20gJy4uL2RlZi9yZW5hbWUuanMnXG5pbXBvcnQgeyByZWFkQ29uZmlnLCByZWFkRmlsZUFzeW5jLCB3cml0ZUZpbGVBc3luYyB9IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lUHJvamVjdCh1c2VyT3B0aW9uczogUmVuYW1lT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0UmVuYW1lT3B0aW9ucyh1c2VyT3B0aW9ucylcbiAgY29uc3QgbmFwaUNvbmZpZyA9IGF3YWl0IHJlYWRDb25maWcob3B0aW9ucylcbiAgY29uc3Qgb2xkTmFtZSA9IG5hcGlDb25maWcuYmluYXJ5TmFtZVxuXG4gIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHJlc29sdmUob3B0aW9ucy5jd2QsIG9wdGlvbnMucGFja2FnZUpzb25QYXRoKVxuICBjb25zdCBjYXJnb1RvbWxQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5tYW5pZmVzdFBhdGgpXG5cbiAgY29uc3QgcGFja2FnZUpzb25Db250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhwYWNrYWdlSnNvblBhdGgsICd1dGY4JylcbiAgY29uc3QgcGFja2FnZUpzb25EYXRhID0gSlNPTi5wYXJzZShwYWNrYWdlSnNvbkNvbnRlbnQpXG5cbiAgbWVyZ2UoXG4gICAgbWVyZ2UoXG4gICAgICBwYWNrYWdlSnNvbkRhdGEsXG4gICAgICBvbWl0QnkoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbWlzc2luZyBmaWVsZHM6IGF1dGhvciBhbmQgbGljZW5zZVxuICAgICAgICBwaWNrKG9wdGlvbnMsIFsnbmFtZScsICdkZXNjcmlwdGlvbicsICdhdXRob3InLCAnbGljZW5zZSddKSxcbiAgICAgICAgaXNOaWwsXG4gICAgICApLFxuICAgICksXG4gICAge1xuICAgICAgbmFwaTogb21pdEJ5KFxuICAgICAgICB7XG4gICAgICAgICAgYmluYXJ5TmFtZTogb3B0aW9ucy5iaW5hcnlOYW1lLFxuICAgICAgICAgIHBhY2thZ2VOYW1lOiBvcHRpb25zLnBhY2thZ2VOYW1lLFxuICAgICAgICB9LFxuICAgICAgICBpc05pbCxcbiAgICAgICksXG4gICAgfSxcbiAgKVxuXG4gIGlmIChvcHRpb25zLmNvbmZpZ1BhdGgpIHtcbiAgICBjb25zdCBjb25maWdQYXRoID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKVxuICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZUFzeW5jKGNvbmZpZ1BhdGgsICd1dGY4JylcbiAgICBjb25zdCBjb25maWdEYXRhID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KVxuICAgIGNvbmZpZ0RhdGEuYmluYXJ5TmFtZSA9IG9wdGlvbnMuYmluYXJ5TmFtZVxuICAgIGNvbmZpZ0RhdGEucGFja2FnZU5hbWUgPSBvcHRpb25zLnBhY2thZ2VOYW1lXG4gICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoY29uZmlnUGF0aCwgSlNPTi5zdHJpbmdpZnkoY29uZmlnRGF0YSwgbnVsbCwgMikpXG4gIH1cblxuICBhd2FpdCB3cml0ZUZpbGVBc3luYyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgSlNPTi5zdHJpbmdpZnkocGFja2FnZUpzb25EYXRhLCBudWxsLCAyKSxcbiAgKVxuXG4gIGNvbnN0IHRvbWxDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhjYXJnb1RvbWxQYXRoLCAndXRmOCcpXG4gIGNvbnN0IGNhcmdvVG9tbCA9IHBhcnNlVG9tbCh0b21sQ29udGVudCkgYXMgYW55XG5cbiAgLy8gVXBkYXRlIHRoZSBwYWNrYWdlIG5hbWVcbiAgaWYgKGNhcmdvVG9tbC5wYWNrYWdlICYmIG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIC8vIFNhbml0aXplIHRoZSBiaW5hcnkgbmFtZSBmb3IgUnVzdCBwYWNrYWdlIG5hbWluZyBjb252ZW50aW9uc1xuICAgIGNvbnN0IHNhbml0aXplZE5hbWUgPSBvcHRpb25zLmJpbmFyeU5hbWVcbiAgICAgIC5yZXBsYWNlKCdAJywgJycpXG4gICAgICAucmVwbGFjZSgnLycsICdfJylcbiAgICAgIC5yZXBsYWNlKC8tL2csICdfJylcbiAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgY2FyZ29Ub21sLnBhY2thZ2UubmFtZSA9IHNhbml0aXplZE5hbWVcbiAgfVxuXG4gIC8vIFN0cmluZ2lmeSB0aGUgdXBkYXRlZCBUT01MXG4gIGNvbnN0IHVwZGF0ZWRUb21sQ29udGVudCA9IHN0cmluZ2lmeVRvbWwoY2FyZ29Ub21sKVxuXG4gIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGNhcmdvVG9tbFBhdGgsIHVwZGF0ZWRUb21sQ29udGVudClcbiAgaWYgKG9sZE5hbWUgIT09IG9wdGlvbnMuYmluYXJ5TmFtZSkge1xuICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNQYXRoID0gZmluZC5kaXIoJy5naXRodWInLCB7XG4gICAgICBjd2Q6IG9wdGlvbnMuY3dkLFxuICAgIH0pXG4gICAgaWYgKGdpdGh1YkFjdGlvbnNQYXRoKSB7XG4gICAgICBjb25zdCBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoID0gam9pbihcbiAgICAgICAgZ2l0aHViQWN0aW9uc1BhdGgsXG4gICAgICAgICd3b3JrZmxvd3MnLFxuICAgICAgICAnQ0kueW1sJyxcbiAgICAgIClcbiAgICAgIGlmIChleGlzdHNTeW5jKGdpdGh1YkFjdGlvbnNDSVltbFBhdGgpKSB7XG4gICAgICAgIGNvbnN0IGdpdGh1YkFjdGlvbnNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICd1dGY4JyxcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBnaXRodWJBY3Rpb25zRGF0YSA9IHlhbWxQYXJzZShnaXRodWJBY3Rpb25zQ29udGVudCkgYXMgYW55XG4gICAgICAgIGlmIChnaXRodWJBY3Rpb25zRGF0YS5lbnY/LkFQUF9OQU1FKSB7XG4gICAgICAgICAgZ2l0aHViQWN0aW9uc0RhdGEuZW52LkFQUF9OQU1FID0gb3B0aW9ucy5iaW5hcnlOYW1lXG4gICAgICAgICAgYXdhaXQgd3JpdGVGaWxlQXN5bmMoXG4gICAgICAgICAgICBnaXRodWJBY3Rpb25zQ0lZbWxQYXRoLFxuICAgICAgICAgICAgeWFtbFN0cmluZ2lmeShnaXRodWJBY3Rpb25zRGF0YSwge1xuICAgICAgICAgICAgICBsaW5lV2lkdGg6IC0xLFxuICAgICAgICAgICAgICBub1JlZnM6IHRydWUsXG4gICAgICAgICAgICAgIHNvcnRLZXlzOiBmYWxzZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvbGRXYXNpQnJvd3NlckJpbmRpbmdQYXRoID0gam9pbihcbiAgICAgIG9wdGlvbnMuY3dkLFxuICAgICAgYCR7b2xkTmFtZX0ud2FzaS1icm93c2VyLmpzYCxcbiAgICApXG4gICAgaWYgKGV4aXN0c1N5bmMob2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJyb3dzZXJCaW5kaW5nUGF0aCxcbiAgICAgICAgam9pbihvcHRpb25zLmN3ZCwgYCR7b3B0aW9ucy5iaW5hcnlOYW1lfS53YXNpLWJyb3dzZXIuanNgKSxcbiAgICAgIClcbiAgICB9XG4gICAgY29uc3Qgb2xkV2FzaUJpbmRpbmdQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgYCR7b2xkTmFtZX0ud2FzaS5janNgKVxuICAgIGlmIChleGlzdHNTeW5jKG9sZFdhc2lCaW5kaW5nUGF0aCkpIHtcbiAgICAgIGF3YWl0IHJlbmFtZShcbiAgICAgICAgb2xkV2FzaUJpbmRpbmdQYXRoLFxuICAgICAgICBqb2luKG9wdGlvbnMuY3dkLCBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2kuY2pzYCksXG4gICAgICApXG4gICAgfVxuICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNQYXRoID0gam9pbihvcHRpb25zLmN3ZCwgJy5naXRhdHRyaWJ1dGVzJylcbiAgICBpZiAoZXhpc3RzU3luYyhnaXRBdHRyaWJ1dGVzUGF0aCkpIHtcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGVBc3luYyhcbiAgICAgICAgZ2l0QXR0cmlidXRlc1BhdGgsXG4gICAgICAgICd1dGY4JyxcbiAgICAgIClcbiAgICAgIGNvbnN0IGdpdEF0dHJpYnV0ZXNEYXRhID0gZ2l0QXR0cmlidXRlc0NvbnRlbnRcbiAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAubWFwKChsaW5lKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgICAgICBgJHtvbGROYW1lfS53YXNpLWJyb3dzZXIuanNgLFxuICAgICAgICAgICAgICBgJHtvcHRpb25zLmJpbmFyeU5hbWV9Lndhc2ktYnJvd3Nlci5qc2AsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAucmVwbGFjZShgJHtvbGROYW1lfS53YXNpLmNqc2AsIGAke29wdGlvbnMuYmluYXJ5TmFtZX0ud2FzaS5janNgKVxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICAgIGF3YWl0IHdyaXRlRmlsZUFzeW5jKGdpdEF0dHJpYnV0ZXNQYXRoLCBnaXRBdHRyaWJ1dGVzRGF0YSlcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IGV4ZWMsIGV4ZWNTeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgZXhpc3RzU3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBob21lZGlyIH0gZnJvbSAnbm9kZTpvcydcbmltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcbmltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnbm9kZTpmcydcblxuaW1wb3J0IHsgbG9hZCBhcyB5YW1sTG9hZCwgZHVtcCBhcyB5YW1sRHVtcCB9IGZyb20gJ2pzLXlhbWwnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdE5ld09wdGlvbnMsXG4gIHR5cGUgTmV3T3B0aW9ucyBhcyBSYXdOZXdPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvbmV3LmpzJ1xuaW1wb3J0IHtcbiAgQVZBSUxBQkxFX1RBUkdFVFMsXG4gIGRlYnVnRmFjdG9yeSxcbiAgREVGQVVMVF9UQVJHRVRTLFxuICBta2RpckFzeW5jLFxuICByZWFkZGlyQXN5bmMsXG4gIHN0YXRBc3luYyxcbiAgdHlwZSBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbn0gZnJvbSAnLi4vdXRpbHMvaW5kZXguanMnXG5pbXBvcnQgeyBuYXBpRW5naW5lUmVxdWlyZW1lbnQgfSBmcm9tICcuLi91dGlscy92ZXJzaW9uLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vcmVuYW1lLmpzJ1xuXG4vLyBUZW1wbGF0ZSBpbXBvcnRzIHJlbW92ZWQgYXMgd2UncmUgbm93IHVzaW5nIGV4dGVybmFsIHRlbXBsYXRlc1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnbmV3JylcblxudHlwZSBOZXdPcHRpb25zID0gUmVxdWlyZWQ8UmF3TmV3T3B0aW9ucz5cblxuY29uc3QgVEVNUExBVEVfUkVQT1MgPSB7XG4gIHlhcm46ICdodHRwczovL2dpdGh1Yi5jb20vbmFwaS1ycy9wYWNrYWdlLXRlbXBsYXRlJyxcbiAgcG5wbTogJ2h0dHBzOi8vZ2l0aHViLmNvbS9uYXBpLXJzL3BhY2thZ2UtdGVtcGxhdGUtcG5wbScsXG59IGFzIGNvbnN0XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrR2l0Q29tbWFuZCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgLS12ZXJzaW9uJylcbiAgICAgIGNwLm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSlcbiAgICAgIH0pXG4gICAgICBjcC5vbignZXhpdCcsIChjb2RlKSA9PiB7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmFsc2UpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBlbnN1cmVDYWNoZURpcihcbiAgcGFja2FnZU1hbmFnZXI6IFN1cHBvcnRlZFBhY2thZ2VNYW5hZ2VyLFxuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgY2FjaGVEaXIgPSBwYXRoLmpvaW4oaG9tZWRpcigpLCAnLm5hcGktcnMnLCAndGVtcGxhdGUnLCBwYWNrYWdlTWFuYWdlcilcbiAgYXdhaXQgbWtkaXJBc3luYyhjYWNoZURpciwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgcmV0dXJuIGNhY2hlRGlyXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkVGVtcGxhdGUoXG4gIHBhY2thZ2VNYW5hZ2VyOiBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlcixcbiAgY2FjaGVEaXI6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXBvVXJsID0gVEVNUExBVEVfUkVQT1NbcGFja2FnZU1hbmFnZXJdXG4gIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGguam9pbihjYWNoZURpciwgJ3JlcG8nKVxuXG4gIGlmIChleGlzdHNTeW5jKHRlbXBsYXRlUGF0aCkpIHtcbiAgICBkZWJ1ZyhgVGVtcGxhdGUgY2FjaGUgZm91bmQgYXQgJHt0ZW1wbGF0ZVBhdGh9LCB1cGRhdGluZy4uLmApXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZldGNoIGxhdGVzdCBjaGFuZ2VzIGFuZCByZXNldCB0byByZW1vdGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgY3AgPSBleGVjKCdnaXQgZmV0Y2ggb3JpZ2luJywgeyBjd2Q6IHRlbXBsYXRlUGF0aCB9KVxuICAgICAgICBjcC5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIGNwLm9uKCdleGl0JywgKGNvZGUpID0+IHtcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gZmV0Y2ggbGF0ZXN0IGNoYW5nZXMsIGdpdCBwcm9jZXNzIGV4aXRlZCB3aXRoIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIGV4ZWNTeW5jKCdnaXQgcmVzZXQgLS1oYXJkIG9yaWdpbi9tYWluJywge1xuICAgICAgICBjd2Q6IHRlbXBsYXRlUGF0aCxcbiAgICAgICAgc3RkaW86ICdpZ25vcmUnLFxuICAgICAgfSlcbiAgICAgIGRlYnVnKCdUZW1wbGF0ZSB1cGRhdGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKGBGYWlsZWQgdG8gdXBkYXRlIHRlbXBsYXRlOiAke2Vycm9yfWApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB1cGRhdGUgdGVtcGxhdGUgZnJvbSAke3JlcG9Vcmx9OiAke2Vycm9yfWApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKGBDbG9uaW5nIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfS4uLmApXG4gICAgdHJ5IHtcbiAgICAgIGV4ZWNTeW5jKGBnaXQgY2xvbmUgJHtyZXBvVXJsfSByZXBvYCwgeyBjd2Q6IGNhY2hlRGlyLCBzdGRpbzogJ2luaGVyaXQnIH0pXG4gICAgICBkZWJ1ZygnVGVtcGxhdGUgY2xvbmVkIHN1Y2Nlc3NmdWxseScpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNsb25lIHRlbXBsYXRlIGZyb20gJHtyZXBvVXJsfTogJHtlcnJvcn1gKVxuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb3B5RGlyZWN0b3J5KFxuICBzcmM6IHN0cmluZyxcbiAgZGVzdDogc3RyaW5nLFxuICBpbmNsdWRlV2FzaUJpbmRpbmdzOiBib29sZWFuLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGF3YWl0IG1rZGlyQXN5bmMoZGVzdCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgY29uc3QgZW50cmllcyA9IGF3YWl0IGZzLnJlYWRkaXIoc3JjLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcblxuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBjb25zdCBzcmNQYXRoID0gcGF0aC5qb2luKHNyYywgZW50cnkubmFtZSlcbiAgICBjb25zdCBkZXN0UGF0aCA9IHBhdGguam9pbihkZXN0LCBlbnRyeS5uYW1lKVxuXG4gICAgLy8gU2tpcCAuZ2l0IGRpcmVjdG9yeVxuICAgIGlmIChlbnRyeS5uYW1lID09PSAnLmdpdCcpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGF3YWl0IGNvcHlEaXJlY3Rvcnkoc3JjUGF0aCwgZGVzdFBhdGgsIGluY2x1ZGVXYXNpQmluZGluZ3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChcbiAgICAgICAgIWluY2x1ZGVXYXNpQmluZGluZ3MgJiZcbiAgICAgICAgKGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLWJyb3dzZXIuanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJy53YXNpLmNqcycpIHx8XG4gICAgICAgICAgZW50cnkubmFtZS5lbmRzV2l0aCgnd2FzaS13b3JrZXIuYnJvd3Nlci5tanMgJykgfHxcbiAgICAgICAgICBlbnRyeS5uYW1lLmVuZHNXaXRoKCd3YXNpLXdvcmtlci5tanMnKSB8fFxuICAgICAgICAgIGVudHJ5Lm5hbWUuZW5kc1dpdGgoJ2Jyb3dzZXIuanMnKSlcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgYXdhaXQgZnMuY29weUZpbGUoc3JjUGF0aCwgZGVzdFBhdGgpXG4gICAgfVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlclRhcmdldHNJblBhY2thZ2VKc29uKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCBwYWNrYWdlSnNvbiA9IEpTT04ucGFyc2UoY29udGVudClcblxuICAvLyBGaWx0ZXIgbmFwaS50YXJnZXRzXG4gIGlmIChwYWNrYWdlSnNvbi5uYXBpPy50YXJnZXRzKSB7XG4gICAgcGFja2FnZUpzb24ubmFwaS50YXJnZXRzID0gcGFja2FnZUpzb24ubmFwaS50YXJnZXRzLmZpbHRlcihcbiAgICAgICh0YXJnZXQ6IHN0cmluZykgPT4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KSxcbiAgICApXG4gIH1cblxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHBhY2thZ2VKc29uLCBudWxsLCAyKSArICdcXG4nKVxufVxuXG5hc3luYyBmdW5jdGlvbiBmaWx0ZXJUYXJnZXRzSW5HaXRodWJBY3Rpb25zKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBlbmFibGVkVGFyZ2V0czogc3RyaW5nW10sXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgY29udGVudCA9IGF3YWl0IGZzLnJlYWRGaWxlKGZpbGVQYXRoLCAndXRmLTgnKVxuICBjb25zdCB5YW1sID0geWFtbExvYWQoY29udGVudCkgYXMgYW55XG5cbiAgY29uc3QgbWFjT1NBbmRXaW5kb3dzVGFyZ2V0cyA9IG5ldyBTZXQoW1xuICAgICd4ODZfNjQtcGMtd2luZG93cy1tc3ZjJyxcbiAgICAneDg2XzY0LXBjLXdpbmRvd3MtZ251JyxcbiAgICAnYWFyY2g2NC1wYy13aW5kb3dzLW1zdmMnLFxuICAgICd4ODZfNjQtYXBwbGUtZGFyd2luJyxcbiAgXSlcblxuICBjb25zdCBsaW51eFRhcmdldHMgPSBuZXcgU2V0KFtcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtZ251JyxcbiAgICAneDg2XzY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdhYXJjaDY0LXVua25vd24tbGludXgtbXVzbCcsXG4gICAgJ2FybXY3LXVua25vd24tbGludXgtZ251ZWFiaWhmJyxcbiAgICAnYXJtdjctdW5rbm93bi1saW51eC1tdXNsZWFiaWhmJyxcbiAgICAnbG9vbmdhcmNoNjQtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdyaXNjdjY0Z2MtdW5rbm93bi1saW51eC1nbnUnLFxuICAgICdwb3dlcnBjNjRsZS11bmtub3duLWxpbnV4LWdudScsXG4gICAgJ3MzOTB4LXVua25vd24tbGludXgtZ251JyxcbiAgICAnYWFyY2g2NC1saW51eC1hbmRyb2lkJyxcbiAgICAnYXJtdjctbGludXgtYW5kcm9pZGVhYmknLFxuICBdKVxuXG4gIC8vIENoZWNrIGlmIGFueSBMaW51eCB0YXJnZXRzIGFyZSBlbmFibGVkXG4gIGNvbnN0IGhhc0xpbnV4VGFyZ2V0cyA9IGVuYWJsZWRUYXJnZXRzLnNvbWUoKHRhcmdldCkgPT5cbiAgICBsaW51eFRhcmdldHMuaGFzKHRhcmdldCksXG4gIClcblxuICAvLyBGaWx0ZXIgdGhlIG1hdHJpeCBjb25maWd1cmF0aW9ucyBpbiB0aGUgYnVpbGQgam9iXG4gIGlmICh5YW1sPy5qb2JzPy5idWlsZD8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3MpIHtcbiAgICB5YW1sLmpvYnMuYnVpbGQuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzID1cbiAgICAgIHlhbWwuam9icy5idWlsZC5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MuZmlsdGVyKChzZXR0aW5nOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHNldHRpbmcudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICB9XG5cbiAgY29uc3Qgam9ic1RvUmVtb3ZlOiBzdHJpbmdbXSA9IFtdXG5cbiAgaWYgKGVuYWJsZWRUYXJnZXRzLmV2ZXJ5KCh0YXJnZXQpID0+ICFtYWNPU0FuZFdpbmRvd3NUYXJnZXRzLmhhcyh0YXJnZXQpKSkge1xuICAgIGpvYnNUb1JlbW92ZS5wdXNoKCd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nIGpvYlxuICAgIGlmIChcbiAgICAgIHlhbWw/LmpvYnM/LlsndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXT8uc3RyYXRlZ3k/Lm1hdHJpeD8uc2V0dGluZ3NcbiAgICApIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1tYWNPUy13aW5kb3dzLWJpbmRpbmcnXS5zdHJhdGVneS5tYXRyaXguc2V0dGluZ3MgPVxuICAgICAgICB5YW1sLmpvYnNbJ3Rlc3QtbWFjT1Mtd2luZG93cy1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzLmZpbHRlcihcbiAgICAgICAgICAoc2V0dGluZzogYW55KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHNldHRpbmcudGFyZ2V0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gTGludXggdGFyZ2V0cyBhcmUgZW5hYmxlZCwgcmVtb3ZlIExpbnV4LXNwZWNpZmljIGpvYnNcbiAgaWYgKCFoYXNMaW51eFRhcmdldHMpIHtcbiAgICAvLyBSZW1vdmUgdGVzdC1saW51eC1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddKSB7XG4gICAgICBqb2JzVG9SZW1vdmUucHVzaCgndGVzdC1saW51eC1iaW5kaW5nJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmlsdGVyIHRoZSBtYXRyaXggY29uZmlndXJhdGlvbnMgaW4gdGhlIHRlc3QtbGludXgteDY0LWdudS1iaW5kaW5nIGpvYlxuICAgIGlmICh5YW1sPy5qb2JzPy5bJ3Rlc3QtbGludXgtYmluZGluZyddPy5zdHJhdGVneT8ubWF0cml4Py50YXJnZXQpIHtcbiAgICAgIHlhbWwuam9ic1sndGVzdC1saW51eC1iaW5kaW5nJ10uc3RyYXRlZ3kubWF0cml4LnRhcmdldCA9IHlhbWwuam9ic1tcbiAgICAgICAgJ3Rlc3QtbGludXgtYmluZGluZydcbiAgICAgIF0uc3RyYXRlZ3kubWF0cml4LnRhcmdldC5maWx0ZXIoKHRhcmdldDogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICByZXR1cm4gZW5hYmxlZFRhcmdldHMuaW5jbHVkZXModGFyZ2V0KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGlmICghZW5hYmxlZFRhcmdldHMuaW5jbHVkZXMoJ3dhc20zMi13YXNpcDEtdGhyZWFkcycpKSB7XG4gICAgam9ic1RvUmVtb3ZlLnB1c2goJ3Rlc3Qtd2FzaScpXG4gIH1cblxuICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKCd4ODZfNjQtdW5rbm93bi1mcmVlYnNkJykpIHtcbiAgICBqb2JzVG9SZW1vdmUucHVzaCgnYnVpbGQtZnJlZWJzZCcpXG4gIH1cblxuICAvLyBGaWx0ZXIgb3RoZXIgdGVzdCBqb2JzIGJhc2VkIG9uIHRhcmdldFxuICBmb3IgKGNvbnN0IFtqb2JOYW1lLCBqb2JDb25maWddIG9mIE9iamVjdC5lbnRyaWVzKHlhbWwuam9icyB8fCB7fSkpIHtcbiAgICBpZiAoXG4gICAgICBqb2JOYW1lLnN0YXJ0c1dpdGgoJ3Rlc3QtJykgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LW1hY09TLXdpbmRvd3MtYmluZGluZycgJiZcbiAgICAgIGpvYk5hbWUgIT09ICd0ZXN0LWxpbnV4LXg2NC1nbnUtYmluZGluZydcbiAgICApIHtcbiAgICAgIC8vIEV4dHJhY3QgdGFyZ2V0IGZyb20gam9iIG5hbWUgb3IgY29uZmlnXG4gICAgICBjb25zdCBqb2IgPSBqb2JDb25maWcgYXMgYW55XG4gICAgICBpZiAoam9iLnN0cmF0ZWd5Py5tYXRyaXg/LnNldHRpbmdzPy5bMF0/LnRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBqb2Iuc3RyYXRlZ3kubWF0cml4LnNldHRpbmdzWzBdLnRhcmdldFxuICAgICAgICBpZiAoIWVuYWJsZWRUYXJnZXRzLmluY2x1ZGVzKHRhcmdldCkpIHtcbiAgICAgICAgICBqb2JzVG9SZW1vdmUucHVzaChqb2JOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIGpvYnMgZm9yIGRpc2FibGVkIHRhcmdldHNcbiAgZm9yIChjb25zdCBqb2JOYW1lIG9mIGpvYnNUb1JlbW92ZSkge1xuICAgIGRlbGV0ZSB5YW1sLmpvYnNbam9iTmFtZV1cbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHlhbWwuam9icz8ucHVibGlzaD8ubmVlZHMpKSB7XG4gICAgeWFtbC5qb2JzLnB1Ymxpc2gubmVlZHMgPSB5YW1sLmpvYnMucHVibGlzaC5uZWVkcy5maWx0ZXIoXG4gICAgICAobmVlZDogc3RyaW5nKSA9PiAham9ic1RvUmVtb3ZlLmluY2x1ZGVzKG5lZWQpLFxuICAgIClcbiAgfVxuXG4gIC8vIFdyaXRlIGJhY2sgdGhlIGZpbHRlcmVkIFlBTUxcbiAgY29uc3QgdXBkYXRlZFlhbWwgPSB5YW1sRHVtcCh5YW1sLCB7XG4gICAgbGluZVdpZHRoOiAtMSxcbiAgICBub1JlZnM6IHRydWUsXG4gICAgc29ydEtleXM6IGZhbHNlLFxuICB9KVxuICBhd2FpdCBmcy53cml0ZUZpbGUoZmlsZVBhdGgsIHVwZGF0ZWRZYW1sKVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzT3B0aW9ucyhvcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdQcm9jZXNzaW5nIG9wdGlvbnMuLi4nKVxuICBpZiAoIW9wdGlvbnMucGF0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIHBhdGggYXMgdGhlIGFyZ3VtZW50JylcbiAgfVxuICBvcHRpb25zLnBhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgb3B0aW9ucy5wYXRoKVxuICBkZWJ1ZyhgUmVzb2x2ZWQgdGFyZ2V0IHBhdGggdG86ICR7b3B0aW9ucy5wYXRofWApXG5cbiAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICBvcHRpb25zLm5hbWUgPSBwYXRoLnBhcnNlKG9wdGlvbnMucGF0aCkuYmFzZVxuICAgIGRlYnVnKGBObyBwcm9qZWN0IG5hbWUgcHJvdmlkZWQsIGZpeCBpdCB0byBkaXIgbmFtZTogJHtvcHRpb25zLm5hbWV9YClcbiAgfVxuXG4gIGlmICghb3B0aW9ucy50YXJnZXRzPy5sZW5ndGgpIHtcbiAgICBpZiAob3B0aW9ucy5lbmFibGVBbGxUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBBVkFJTEFCTEVfVEFSR0VUUy5jb25jYXQoKVxuICAgICAgZGVidWcoJ0VuYWJsZSBhbGwgdGFyZ2V0cycpXG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmVuYWJsZURlZmF1bHRUYXJnZXRzKSB7XG4gICAgICBvcHRpb25zLnRhcmdldHMgPSBERUZBVUxUX1RBUkdFVFMuY29uY2F0KClcbiAgICAgIGRlYnVnKCdFbmFibGUgZGVmYXVsdCB0YXJnZXRzJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdCBsZWFzdCBvbmUgdGFyZ2V0IG11c3QgYmUgZW5hYmxlZCcpXG4gICAgfVxuICB9XG4gIGlmIChcbiAgICBvcHRpb25zLnRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJylcbiAgKSB7XG4gICAgY29uc3Qgb3V0ID0gZXhlY1N5bmMoYHJ1c3R1cCB0YXJnZXQgbGlzdGAsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgfSlcbiAgICBpZiAob3V0LmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSkge1xuICAgICAgb3B0aW9ucy50YXJnZXRzID0gb3B0aW9ucy50YXJnZXRzLm1hcCgodGFyZ2V0KSA9PlxuICAgICAgICB0YXJnZXQgPT09ICd3YXNtMzItd2FzaS1wcmV2aWV3MS10aHJlYWRzJ1xuICAgICAgICAgID8gJ3dhc20zMi13YXNpcDEtdGhyZWFkcydcbiAgICAgICAgICA6IHRhcmdldCxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBwbHlEZWZhdWx0TmV3T3B0aW9ucyhvcHRpb25zKSBhcyBOZXdPcHRpb25zXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBuZXdQcm9qZWN0KHVzZXJPcHRpb25zOiBSYXdOZXdPcHRpb25zKSB7XG4gIGRlYnVnKCdXaWxsIGNyZWF0ZSBuYXBpLXJzIHByb2plY3Qgd2l0aCBnaXZlbiBvcHRpb25zOicpXG4gIGRlYnVnKHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBwcm9jZXNzT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBkZWJ1ZygnVGFyZ2V0cyB0byBiZSBlbmFibGVkOicpXG4gIGRlYnVnKG9wdGlvbnMudGFyZ2V0cylcblxuICAvLyBDaGVjayBpZiBnaXQgaXMgYXZhaWxhYmxlXG4gIGlmICghKGF3YWl0IGNoZWNrR2l0Q29tbWFuZCgpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdHaXQgaXMgbm90IGluc3RhbGxlZCBvciBub3QgYXZhaWxhYmxlIGluIFBBVEguIFBsZWFzZSBpbnN0YWxsIEdpdCB0byBjb250aW51ZS4nLFxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHBhY2thZ2VNYW5hZ2VyID0gb3B0aW9ucy5wYWNrYWdlTWFuYWdlciBhcyBTdXBwb3J0ZWRQYWNrYWdlTWFuYWdlclxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgZGlyZWN0b3J5IGV4aXN0cyBhbmQgaXMgZW1wdHlcbiAgYXdhaXQgZW5zdXJlUGF0aChvcHRpb25zLnBhdGgsIG9wdGlvbnMuZHJ5UnVuKVxuXG4gIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICB0cnkge1xuICAgICAgLy8gRG93bmxvYWQgb3IgdXBkYXRlIHRlbXBsYXRlXG4gICAgICBjb25zdCBjYWNoZURpciA9IGF3YWl0IGVuc3VyZUNhY2hlRGlyKHBhY2thZ2VNYW5hZ2VyKVxuICAgICAgYXdhaXQgZG93bmxvYWRUZW1wbGF0ZShwYWNrYWdlTWFuYWdlciwgY2FjaGVEaXIpXG5cbiAgICAgIC8vIENvcHkgdGVtcGxhdGUgZmlsZXMgdG8gdGFyZ2V0IGRpcmVjdG9yeVxuICAgICAgY29uc3QgdGVtcGxhdGVQYXRoID0gcGF0aC5qb2luKGNhY2hlRGlyLCAncmVwbycpXG4gICAgICBhd2FpdCBjb3B5RGlyZWN0b3J5KFxuICAgICAgICB0ZW1wbGF0ZVBhdGgsXG4gICAgICAgIG9wdGlvbnMucGF0aCxcbiAgICAgICAgb3B0aW9ucy50YXJnZXRzLmluY2x1ZGVzKCd3YXNtMzItd2FzaXAxLXRocmVhZHMnKSxcbiAgICAgIClcblxuICAgICAgLy8gUmVuYW1lIHByb2plY3QgdXNpbmcgdGhlIHJlbmFtZSBBUElcbiAgICAgIGF3YWl0IHJlbmFtZVByb2plY3Qoe1xuICAgICAgICBjd2Q6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICBiaW5hcnlOYW1lOiBnZXRCaW5hcnlOYW1lKG9wdGlvbnMubmFtZSksXG4gICAgICB9KVxuXG4gICAgICAvLyBGaWx0ZXIgdGFyZ2V0cyBpbiBwYWNrYWdlLmpzb25cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICdwYWNrYWdlLmpzb24nKVxuICAgICAgaWYgKGV4aXN0c1N5bmMocGFja2FnZUpzb25QYXRoKSkge1xuICAgICAgICBhd2FpdCBmaWx0ZXJUYXJnZXRzSW5QYWNrYWdlSnNvbihwYWNrYWdlSnNvblBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIHRhcmdldHMgaW4gR2l0SHViIEFjdGlvbnMgQ0lcbiAgICAgIGNvbnN0IGNpUGF0aCA9IHBhdGguam9pbihvcHRpb25zLnBhdGgsICcuZ2l0aHViJywgJ3dvcmtmbG93cycsICdDSS55bWwnKVxuICAgICAgaWYgKGV4aXN0c1N5bmMoY2lQYXRoKSAmJiBvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMpIHtcbiAgICAgICAgYXdhaXQgZmlsdGVyVGFyZ2V0c0luR2l0aHViQWN0aW9ucyhjaVBhdGgsIG9wdGlvbnMudGFyZ2V0cylcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICFvcHRpb25zLmVuYWJsZUdpdGh1YkFjdGlvbnMgJiZcbiAgICAgICAgZXhpc3RzU3luYyhwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpKVxuICAgICAgKSB7XG4gICAgICAgIC8vIFJlbW92ZSAuZ2l0aHViIGRpcmVjdG9yeSBpZiBHaXRIdWIgQWN0aW9ucyBpcyBub3QgZW5hYmxlZFxuICAgICAgICBhd2FpdCBmcy5ybShwYXRoLmpvaW4ob3B0aW9ucy5wYXRoLCAnLmdpdGh1YicpLCB7XG4gICAgICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgcGFja2FnZS5qc29uIHdpdGggYWRkaXRpb25hbCBjb25maWd1cmF0aW9uc1xuICAgICAgY29uc3QgcGtnSnNvbkNvbnRlbnQgPSBhd2FpdCBmcy5yZWFkRmlsZShwYWNrYWdlSnNvblBhdGgsICd1dGYtOCcpXG4gICAgICBjb25zdCBwa2dKc29uID0gSlNPTi5wYXJzZShwa2dKc29uQ29udGVudClcblxuICAgICAgLy8gVXBkYXRlIGVuZ2luZSByZXF1aXJlbWVudFxuICAgICAgaWYgKCFwa2dKc29uLmVuZ2luZXMpIHtcbiAgICAgICAgcGtnSnNvbi5lbmdpbmVzID0ge31cbiAgICAgIH1cbiAgICAgIHBrZ0pzb24uZW5naW5lcy5ub2RlID0gbmFwaUVuZ2luZVJlcXVpcmVtZW50KG9wdGlvbnMubWluTm9kZUFwaVZlcnNpb24pXG5cbiAgICAgIC8vIFVwZGF0ZSBsaWNlbnNlIGlmIGRpZmZlcmVudCBmcm9tIHRlbXBsYXRlXG4gICAgICBpZiAob3B0aW9ucy5saWNlbnNlICYmIHBrZ0pzb24ubGljZW5zZSAhPT0gb3B0aW9ucy5saWNlbnNlKSB7XG4gICAgICAgIHBrZ0pzb24ubGljZW5zZSA9IG9wdGlvbnMubGljZW5zZVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgdGVzdCBmcmFtZXdvcmsgaWYgbmVlZGVkXG4gICAgICBpZiAob3B0aW9ucy50ZXN0RnJhbWV3b3JrICE9PSAnYXZhJykge1xuICAgICAgICAvLyBUaGlzIHdvdWxkIHJlcXVpcmUgbW9yZSBjb21wbGV4IGxvZ2ljIHRvIHVwZGF0ZSB0ZXN0IHNjcmlwdHMgYW5kIGRlcGVuZGVuY2llc1xuICAgICAgICBkZWJ1ZyhcbiAgICAgICAgICBgVGVzdCBmcmFtZXdvcmsgJHtvcHRpb25zLnRlc3RGcmFtZXdvcmt9IHJlcXVlc3RlZCBidXQgbm90IHlldCBpbXBsZW1lbnRlZGAsXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZnMud3JpdGVGaWxlKFxuICAgICAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHBrZ0pzb24sIG51bGwsIDIpICsgJ1xcbicsXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBwcm9qZWN0OiAke2Vycm9yfWApXG4gICAgfVxuICB9XG5cbiAgZGVidWcoYFByb2plY3QgY3JlYXRlZCBhdDogJHtvcHRpb25zLnBhdGh9YClcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW5zdXJlUGF0aChwYXRoOiBzdHJpbmcsIGRyeVJ1biA9IGZhbHNlKSB7XG4gIGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0QXN5bmMocGF0aCwge30pLmNhdGNoKCgpID0+IHVuZGVmaW5lZClcblxuICAvLyBmaWxlIGRlc2NyaXB0b3IgZXhpc3RzXG4gIGlmIChzdGF0KSB7XG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFBhdGggJHtwYXRofSBmb3IgY3JlYXRpbmcgbmV3IG5hcGktcnMgcHJvamVjdCBhbHJlYWR5IGV4aXN0cyBhbmQgaXQncyBub3QgYSBkaXJlY3RvcnkuYCxcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgY29uc3QgZmlsZXMgPSBhd2FpdCByZWFkZGlyQXN5bmMocGF0aClcbiAgICAgIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBQYXRoICR7cGF0aH0gZm9yIGNyZWF0aW5nIG5ldyBuYXBpLXJzIHByb2plY3QgYWxyZWFkeSBleGlzdHMgYW5kIGl0J3Mgbm90IGVtcHR5LmAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIWRyeVJ1bikge1xuICAgIHRyeSB7XG4gICAgICBkZWJ1ZyhgVHJ5IHRvIGNyZWF0ZSB0YXJnZXQgZGlyZWN0b3J5OiAke3BhdGh9YClcbiAgICAgIGlmICghZHJ5UnVuKSB7XG4gICAgICAgIGF3YWl0IG1rZGlyQXN5bmMocGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgdGFyZ2V0IGRpcmVjdG9yeTogJHtwYXRofWAsIHtcbiAgICAgICAgY2F1c2U6IGUsXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaW5hcnlOYW1lKG5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBuYW1lLnNwbGl0KCcvJykucG9wKCkhXG59XG5cbmV4cG9ydCB0eXBlIHsgTmV3T3B0aW9ucyB9XG4iLCIvLyBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IGNvZGVnZW4vaW5kZXgudHNcbi8vIERvIG5vdCBlZGl0IHRoaXMgZmlsZSBtYW51YWxseVxuaW1wb3J0IHsgQ29tbWFuZCwgT3B0aW9uIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByZVB1Ymxpc2hDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ3ByZS1wdWJsaXNoJ10sIFsncHJlcHVibGlzaCddXVxuXG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1VwZGF0ZSBwYWNrYWdlLmpzb24gYW5kIGNvcHkgYWRkb25zIGludG8gcGVyIHBsYXRmb3JtIHBhY2thZ2VzJyxcbiAgfSlcblxuICBjd2QgPSBPcHRpb24uU3RyaW5nKCctLWN3ZCcsIHByb2Nlc3MuY3dkKCksIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGgnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsICdwYWNrYWdlLmpzb24nLCB7XG4gICAgZGVzY3JpcHRpb246ICdQYXRoIHRvIGBwYWNrYWdlLmpzb25gJyxcbiAgfSlcblxuICBucG1EaXIgPSBPcHRpb24uU3RyaW5nKCctLW5wbS1kaXIsLXAnLCAnbnBtJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byB0aGUgZm9sZGVyIHdoZXJlIHRoZSBucG0gcGFja2FnZXMgcHV0JyxcbiAgfSlcblxuICB0YWdTdHlsZSA9IE9wdGlvbi5TdHJpbmcoJy0tdGFnLXN0eWxlLC0tdGFnc3R5bGUsLXQnLCAnbGVybmEnLCB7XG4gICAgZGVzY3JpcHRpb246ICdnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgJyxcbiAgfSlcblxuICBnaFJlbGVhc2UgPSBPcHRpb24uQm9vbGVhbignLS1naC1yZWxlYXNlJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBjcmVhdGUgR2l0SHViIHJlbGVhc2UnLFxuICB9KVxuXG4gIGdoUmVsZWFzZU5hbWU/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWdoLXJlbGVhc2UtbmFtZScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ0dpdEh1YiByZWxlYXNlIG5hbWUnLFxuICB9KVxuXG4gIGdoUmVsZWFzZUlkPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1naC1yZWxlYXNlLWlkJywge1xuICAgIGRlc2NyaXB0aW9uOiAnRXhpc3RpbmcgR2l0SHViIHJlbGVhc2UgaWQnLFxuICB9KVxuXG4gIHNraXBPcHRpb25hbFB1Ymxpc2ggPSBPcHRpb24uQm9vbGVhbignLS1za2lwLW9wdGlvbmFsLXB1Ymxpc2gnLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciBza2lwIG9wdGlvbmFsRGVwZW5kZW5jaWVzIHBhY2thZ2VzIHB1Ymxpc2gnLFxuICB9KVxuXG4gIGRyeVJ1biA9IE9wdGlvbi5Cb29sZWFuKCctLWRyeS1ydW4nLCBmYWxzZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtJyxcbiAgfSlcblxuICBnZXRPcHRpb25zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIG5wbURpcjogdGhpcy5ucG1EaXIsXG4gICAgICB0YWdTdHlsZTogdGhpcy50YWdTdHlsZSxcbiAgICAgIGdoUmVsZWFzZTogdGhpcy5naFJlbGVhc2UsXG4gICAgICBnaFJlbGVhc2VOYW1lOiB0aGlzLmdoUmVsZWFzZU5hbWUsXG4gICAgICBnaFJlbGVhc2VJZDogdGhpcy5naFJlbGVhc2VJZCxcbiAgICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IHRoaXMuc2tpcE9wdGlvbmFsUHVibGlzaCxcbiAgICAgIGRyeVJ1bjogdGhpcy5kcnlSdW4sXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHBhY2thZ2UuanNvbiBhbmQgY29weSBhZGRvbnMgaW50byBwZXIgcGxhdGZvcm0gcGFja2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQcmVQdWJsaXNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICpcbiAgICogQGRlZmF1bHQgcHJvY2Vzcy5jd2QoKVxuICAgKi9cbiAgY3dkPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBuYXBpYCBjb25maWcganNvbiBmaWxlXG4gICAqL1xuICBjb25maWdQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIGBwYWNrYWdlLmpzb25gXG4gICAqXG4gICAqIEBkZWZhdWx0ICdwYWNrYWdlLmpzb24nXG4gICAqL1xuICBwYWNrYWdlSnNvblBhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFBhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dFxuICAgKlxuICAgKiBAZGVmYXVsdCAnbnBtJ1xuICAgKi9cbiAgbnBtRGlyPzogc3RyaW5nXG4gIC8qKlxuICAgKiBnaXQgdGFnIHN0eWxlLCBgbnBtYCBvciBgbGVybmFgXG4gICAqXG4gICAqIEBkZWZhdWx0ICdsZXJuYSdcbiAgICovXG4gIHRhZ1N0eWxlPzogJ25wbScgfCAnbGVybmEnXG4gIC8qKlxuICAgKiBXaGV0aGVyIGNyZWF0ZSBHaXRIdWIgcmVsZWFzZVxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICBnaFJlbGVhc2U/OiBib29sZWFuXG4gIC8qKlxuICAgKiBHaXRIdWIgcmVsZWFzZSBuYW1lXG4gICAqL1xuICBnaFJlbGVhc2VOYW1lPzogc3RyaW5nXG4gIC8qKlxuICAgKiBFeGlzdGluZyBHaXRIdWIgcmVsZWFzZSBpZFxuICAgKi9cbiAgZ2hSZWxlYXNlSWQ/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgc2tpcCBvcHRpb25hbERlcGVuZGVuY2llcyBwYWNrYWdlcyBwdWJsaXNoXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBza2lwT3B0aW9uYWxQdWJsaXNoPzogYm9vbGVhblxuICAvKipcbiAgICogRHJ5IHJ1biB3aXRob3V0IHRvdWNoaW5nIGZpbGUgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcnlSdW4/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyhvcHRpb25zOiBQcmVQdWJsaXNoT3B0aW9ucykge1xuICByZXR1cm4ge1xuICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICBwYWNrYWdlSnNvblBhdGg6ICdwYWNrYWdlLmpzb24nLFxuICAgIG5wbURpcjogJ25wbScsXG4gICAgdGFnU3R5bGU6ICdsZXJuYScsXG4gICAgZ2hSZWxlYXNlOiB0cnVlLFxuICAgIHNraXBPcHRpb25hbFB1Ymxpc2g6IGZhbHNlLFxuICAgIGRyeVJ1bjogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiLy8gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBjb2RlZ2VuL2luZGV4LnRzXG4vLyBEbyBub3QgZWRpdCB0aGlzIGZpbGUgbWFudWFsbHlcbmltcG9ydCB7IENvbW1hbmQsIE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VWZXJzaW9uQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyd2ZXJzaW9uJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdVcGRhdGUgdmVyc2lvbiBpbiBjcmVhdGVkIG5wbSBwYWNrYWdlcycsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgbnBtRGlyID0gT3B0aW9uLlN0cmluZygnLS1ucG0tZGlyJywgJ25wbScsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSB0aGUgbnBtIHBhY2thZ2VzIHB1dCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBucG1EaXI6IHRoaXMubnBtRGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSB2ZXJzaW9uIGluIGNyZWF0ZWQgbnBtIHBhY2thZ2VzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVmVyc2lvbk9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgdGhlIG5wbSBwYWNrYWdlcyBwdXRcbiAgICpcbiAgICogQGRlZmF1bHQgJ25wbSdcbiAgICovXG4gIG5wbURpcj86IHN0cmluZ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlEZWZhdWx0VmVyc2lvbk9wdGlvbnMob3B0aW9uczogVmVyc2lvbk9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBucG1EaXI6ICducG0nLFxuICAgIC4uLm9wdGlvbnMsXG4gIH1cbn1cbiIsImltcG9ydCB7IGpvaW4sIHJlc29sdmUgfSBmcm9tICdub2RlOnBhdGgnXG5cbmltcG9ydCB7XG4gIGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zLFxuICB0eXBlIFZlcnNpb25PcHRpb25zLFxufSBmcm9tICcuLi9kZWYvdmVyc2lvbi5qcydcbmltcG9ydCB7XG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHVwZGF0ZVBhY2thZ2VKc29uLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3ZlcnNpb24nKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmVyc2lvbih1c2VyT3B0aW9uczogVmVyc2lvbk9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGFwcGx5RGVmYXVsdFZlcnNpb25PcHRpb25zKHVzZXJPcHRpb25zKVxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGZvciAoY29uc3QgdGFyZ2V0IG9mIGNvbmZpZy50YXJnZXRzKSB7XG4gICAgY29uc3QgcGtnRGlyID0gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5ucG1EaXIsIHRhcmdldC5wbGF0Zm9ybUFyY2hBQkkpXG5cbiAgICBkZWJ1ZyhgVXBkYXRlIHZlcnNpb24gdG8gJWkgaW4gWyVpXWAsIGNvbmZpZy5wYWNrYWdlSnNvbi52ZXJzaW9uLCBwa2dEaXIpXG4gICAgYXdhaXQgdXBkYXRlUGFja2FnZUpzb24oam9pbihwa2dEaXIsICdwYWNrYWdlLmpzb24nKSwge1xuICAgICAgdmVyc2lvbjogY29uZmlnLnBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgfSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBzdGF0U3luYyB9IGZyb20gJ25vZGU6ZnMnXG5pbXBvcnQgeyBqb2luLCByZXNvbHZlIH0gZnJvbSAnbm9kZTpwYXRoJ1xuXG5pbXBvcnQgeyBPY3Rva2l0IH0gZnJvbSAnQG9jdG9raXQvcmVzdCdcblxuaW1wb3J0IHtcbiAgYXBwbHlEZWZhdWx0UHJlUHVibGlzaE9wdGlvbnMsXG4gIHR5cGUgUHJlUHVibGlzaE9wdGlvbnMsXG59IGZyb20gJy4uL2RlZi9wcmUtcHVibGlzaC5qcydcbmltcG9ydCB7XG4gIHJlYWRGaWxlQXN5bmMsXG4gIHJlYWROYXBpQ29uZmlnLFxuICBkZWJ1Z0ZhY3RvcnksXG4gIHVwZGF0ZVBhY2thZ2VKc29uLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcblxuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3ByZS1wdWJsaXNoJylcblxuaW50ZXJmYWNlIFBhY2thZ2VJbmZvIHtcbiAgbmFtZTogc3RyaW5nXG4gIHZlcnNpb246IHN0cmluZ1xuICB0YWc6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJlUHVibGlzaCh1c2VyT3B0aW9uczogUHJlUHVibGlzaE9wdGlvbnMpIHtcbiAgZGVidWcoJ1JlY2VpdmUgcHJlLXB1Ymxpc2ggb3B0aW9uczonKVxuICBkZWJ1ZygnICAlTycsIHVzZXJPcHRpb25zKVxuXG4gIGNvbnN0IG9wdGlvbnMgPSBhcHBseURlZmF1bHRQcmVQdWJsaXNoT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSByZXNvbHZlKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCB7IHBhY2thZ2VKc29uLCB0YXJnZXRzLCBwYWNrYWdlTmFtZSwgYmluYXJ5TmFtZSwgbnBtQ2xpZW50IH0gPVxuICAgIGF3YWl0IHJlYWROYXBpQ29uZmlnKFxuICAgICAgcGFja2FnZUpzb25QYXRoLFxuICAgICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgICApXG5cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlR2hSZWxlYXNlKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGlmICghb3B0aW9ucy5naFJlbGVhc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHJlcG8sIG93bmVyLCBwa2dJbmZvLCBvY3Rva2l0IH0gPSBnZXRSZXBvSW5mbyhwYWNrYWdlTmFtZSwgdmVyc2lvbilcblxuICAgIGlmICghcmVwbyB8fCAhb3duZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG93bmVyOiBudWxsLFxuICAgICAgICByZXBvOiBudWxsLFxuICAgICAgICBwa2dJbmZvOiB7IG5hbWU6IG51bGwsIHZlcnNpb246IG51bGwsIHRhZzogbnVsbCB9LFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5kcnlSdW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IG9jdG9raXQucmVwb3MuY3JlYXRlUmVsZWFzZSh7XG4gICAgICAgICAgb3duZXIsXG4gICAgICAgICAgcmVwbyxcbiAgICAgICAgICB0YWdfbmFtZTogcGtnSW5mby50YWcsXG4gICAgICAgICAgbmFtZTogb3B0aW9ucy5naFJlbGVhc2VOYW1lLFxuICAgICAgICAgIHByZXJlbGVhc2U6XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdhbHBoYScpIHx8XG4gICAgICAgICAgICB2ZXJzaW9uLmluY2x1ZGVzKCdiZXRhJykgfHxcbiAgICAgICAgICAgIHZlcnNpb24uaW5jbHVkZXMoJ3JjJyksXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKFxuICAgICAgICAgIGBQYXJhbXM6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7IG93bmVyLCByZXBvLCB0YWdfbmFtZTogcGtnSW5mby50YWcgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyLFxuICAgICAgICAgICl9YCxcbiAgICAgICAgKVxuICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG93bmVyLCByZXBvLCBwa2dJbmZvLCBvY3Rva2l0IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJlcG9JbmZvKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHZlcnNpb246IHN0cmluZykge1xuICAgIGNvbnN0IGhlYWRDb21taXQgPSBleGVjU3luYygnZ2l0IGxvZyAtMSAtLXByZXR0eT0lQicsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmLTgnLFxuICAgIH0pLnRyaW0oKVxuXG4gICAgY29uc3QgeyBHSVRIVUJfUkVQT1NJVE9SWSB9ID0gcHJvY2Vzcy5lbnZcbiAgICBpZiAoIUdJVEhVQl9SRVBPU0lUT1JZKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvd25lcjogbnVsbCxcbiAgICAgICAgcmVwbzogbnVsbCxcbiAgICAgICAgcGtnSW5mbzogeyBuYW1lOiBudWxsLCB2ZXJzaW9uOiBudWxsLCB0YWc6IG51bGwgfSxcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWcoYEdpdGh1YiByZXBvc2l0b3J5OiAke0dJVEhVQl9SRVBPU0lUT1JZfWApXG4gICAgY29uc3QgW293bmVyLCByZXBvXSA9IEdJVEhVQl9SRVBPU0lUT1JZLnNwbGl0KCcvJylcbiAgICBjb25zdCBvY3Rva2l0ID0gbmV3IE9jdG9raXQoe1xuICAgICAgYXV0aDogcHJvY2Vzcy5lbnYuR0lUSFVCX1RPS0VOLFxuICAgIH0pXG4gICAgbGV0IHBrZ0luZm86IFBhY2thZ2VJbmZvIHwgdW5kZWZpbmVkXG4gICAgaWYgKG9wdGlvbnMudGFnU3R5bGUgPT09ICdsZXJuYScpIHtcbiAgICAgIGNvbnN0IHBhY2thZ2VzVG9QdWJsaXNoID0gaGVhZENvbW1pdFxuICAgICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUudHJpbSgpKVxuICAgICAgICAuZmlsdGVyKChsaW5lLCBpbmRleCkgPT4gbGluZS5sZW5ndGggJiYgaW5kZXgpXG4gICAgICAgIC5tYXAoKGxpbmUpID0+IGxpbmUuc3Vic3RyaW5nKDIpKVxuICAgICAgICAubWFwKHBhcnNlVGFnKVxuXG4gICAgICBwa2dJbmZvID0gcGFja2FnZXNUb1B1Ymxpc2guZmluZChcbiAgICAgICAgKHBrZ0luZm8pID0+IHBrZ0luZm8ubmFtZSA9PT0gcGFja2FnZU5hbWUsXG4gICAgICApXG5cbiAgICAgIGlmICghcGtnSW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBObyByZWxlYXNlIGNvbW1pdCBmb3VuZCB3aXRoICR7cGFja2FnZU5hbWV9LCBvcmlnaW5hbCBjb21taXQgaW5mbzogJHtoZWFkQ29tbWl0fWAsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGtnSW5mbyA9IHtcbiAgICAgICAgdGFnOiBgdiR7dmVyc2lvbn1gLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBuYW1lOiBwYWNrYWdlTmFtZSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb3duZXIsIHJlcG8sIHBrZ0luZm8sIG9jdG9raXQgfVxuICB9XG5cbiAgaWYgKCFvcHRpb25zLmRyeVJ1bikge1xuICAgIGF3YWl0IHZlcnNpb24odXNlck9wdGlvbnMpXG4gICAgYXdhaXQgdXBkYXRlUGFja2FnZUpzb24ocGFja2FnZUpzb25QYXRoLCB7XG4gICAgICBvcHRpb25hbERlcGVuZGVuY2llczogdGFyZ2V0cy5yZWR1Y2UoXG4gICAgICAgIChkZXBzLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICBkZXBzW2Ake3BhY2thZ2VOYW1lfS0ke3RhcmdldC5wbGF0Zm9ybUFyY2hBQkl9YF0gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbiAgICAgICAgICByZXR1cm4gZGVwc1xuICAgICAgICB9LFxuICAgICAgICB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICAgICAgKSxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgeyBvd25lciwgcmVwbywgcGtnSW5mbywgb2N0b2tpdCB9ID0gb3B0aW9ucy5naFJlbGVhc2VJZFxuICAgID8gZ2V0UmVwb0luZm8ocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG4gICAgOiBhd2FpdCBjcmVhdGVHaFJlbGVhc2UocGFja2FnZU5hbWUsIHBhY2thZ2VKc29uLnZlcnNpb24pXG5cbiAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0cykge1xuICAgIGNvbnN0IHBrZ0RpciA9IHJlc29sdmUoXG4gICAgICBvcHRpb25zLmN3ZCxcbiAgICAgIG9wdGlvbnMubnBtRGlyLFxuICAgICAgYCR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX1gLFxuICAgIClcbiAgICBjb25zdCBleHQgPVxuICAgICAgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzaScgfHwgdGFyZ2V0LnBsYXRmb3JtID09PSAnd2FzbScgPyAnd2FzbScgOiAnbm9kZSdcbiAgICBjb25zdCBmaWxlbmFtZSA9IGAke2JpbmFyeU5hbWV9LiR7dGFyZ2V0LnBsYXRmb3JtQXJjaEFCSX0uJHtleHR9YFxuICAgIGNvbnN0IGRzdFBhdGggPSBqb2luKHBrZ0RpciwgZmlsZW5hbWUpXG5cbiAgICBpZiAoIW9wdGlvbnMuZHJ5UnVuKSB7XG4gICAgICBpZiAoIWV4aXN0c1N5bmMoZHN0UGF0aCkpIHtcbiAgICAgICAgZGVidWcud2FybihgJXMgZG9lc24ndCBleGlzdGAsIGRzdFBhdGgpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICghb3B0aW9ucy5za2lwT3B0aW9uYWxQdWJsaXNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZXhlY1N5bmMoYCR7bnBtQ2xpZW50fSBwdWJsaXNoYCwge1xuICAgICAgICAgICAgY3dkOiBwa2dEaXIsXG4gICAgICAgICAgICBlbnY6IHByb2Nlc3MuZW52LFxuICAgICAgICAgICAgc3RkaW86ICdwaXBlJyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKG91dHB1dClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgZS5tZXNzYWdlLmluY2x1ZGVzKFxuICAgICAgICAgICAgICAnWW91IGNhbm5vdCBwdWJsaXNoIG92ZXIgdGhlIHByZXZpb3VzbHkgcHVibGlzaGVkIHZlcnNpb25zJyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhlLm1lc3NhZ2UpXG4gICAgICAgICAgICBkZWJ1Zy53YXJuKGAke3BrZ0Rpcn0gaGFzIGJlZW4gcHVibGlzaGVkLCBza2lwcGluZ2ApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZ2hSZWxlYXNlICYmIHJlcG8gJiYgb3duZXIpIHtcbiAgICAgICAgZGVidWcuaW5mbyhgQ3JlYXRpbmcgR2l0SHViIHJlbGVhc2UgJHtwa2dJbmZvLnRhZ31gKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlbGVhc2VJZCA9IG9wdGlvbnMuZ2hSZWxlYXNlSWRcbiAgICAgICAgICAgID8gTnVtYmVyKG9wdGlvbnMuZ2hSZWxlYXNlSWQpXG4gICAgICAgICAgICA6IChcbiAgICAgICAgICAgICAgICBhd2FpdCBvY3Rva2l0IS5yZXBvcy5nZXRSZWxlYXNlQnlUYWcoe1xuICAgICAgICAgICAgICAgICAgcmVwbzogcmVwbyxcbiAgICAgICAgICAgICAgICAgIG93bmVyOiBvd25lcixcbiAgICAgICAgICAgICAgICAgIHRhZzogcGtnSW5mby50YWcsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKS5kYXRhLmlkXG4gICAgICAgICAgY29uc3QgZHN0RmlsZVN0YXRzID0gc3RhdFN5bmMoZHN0UGF0aClcbiAgICAgICAgICBjb25zdCBhc3NldEluZm8gPSBhd2FpdCBvY3Rva2l0IS5yZXBvcy51cGxvYWRSZWxlYXNlQXNzZXQoe1xuICAgICAgICAgICAgb3duZXI6IG93bmVyLFxuICAgICAgICAgICAgcmVwbzogcmVwbyxcbiAgICAgICAgICAgIG5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgcmVsZWFzZV9pZDogcmVsZWFzZUlkLFxuICAgICAgICAgICAgbWVkaWFUeXBlOiB7IGZvcm1hdDogJ3JhdycgfSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ2NvbnRlbnQtbGVuZ3RoJzogZHN0RmlsZVN0YXRzLnNpemUsXG4gICAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIG9jdG9raXQgdHlwZXMgYXJlIHdyb25nXG4gICAgICAgICAgICBkYXRhOiBhd2FpdCByZWFkRmlsZUFzeW5jKGRzdFBhdGgpLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgZGVidWcuaW5mbyhgR2l0SHViIHJlbGVhc2UgY3JlYXRlZGApXG4gICAgICAgICAgZGVidWcuaW5mbyhgRG93bmxvYWQgVVJMOiAlc2AsIGFzc2V0SW5mby5kYXRhLmJyb3dzZXJfZG93bmxvYWRfdXJsKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcuZXJyb3IoXG4gICAgICAgICAgICBgUGFyYW06ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHsgb3duZXIsIHJlcG8sIHRhZzogcGtnSW5mby50YWcsIGZpbGVuYW1lOiBkc3RQYXRoIH0sXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgKVxuICAgICAgICAgIGRlYnVnLmVycm9yKGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VUYWcodGFnOiBzdHJpbmcpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSB0YWcuc3BsaXQoJ0AnKVxuICBjb25zdCB2ZXJzaW9uID0gc2VnbWVudHMucG9wKCkhXG4gIGNvbnN0IG5hbWUgPSBzZWdtZW50cy5qb2luKCdAJylcblxuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgdmVyc2lvbixcbiAgICB0YWcsXG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlVW5pdmVyc2FsaXplQ29tbWFuZCBleHRlbmRzIENvbW1hbmQge1xuICBzdGF0aWMgcGF0aHMgPSBbWyd1bml2ZXJzYWxpemUnXV1cblxuICBzdGF0aWMgdXNhZ2UgPSBDb21tYW5kLlVzYWdlKHtcbiAgICBkZXNjcmlwdGlvbjogJ0NvbWJpbGUgYnVpbHQgYmluYXJpZXMgaW50byBvbmUgdW5pdmVyc2FsIGJpbmFyeScsXG4gIH0pXG5cbiAgY3dkID0gT3B0aW9uLlN0cmluZygnLS1jd2QnLCBwcm9jZXNzLmN3ZCgpLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoJyxcbiAgfSlcblxuICBjb25maWdQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1jb25maWctcGF0aCwtYycsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYG5hcGlgIGNvbmZpZyBqc29uIGZpbGUnLFxuICB9KVxuXG4gIHBhY2thZ2VKc29uUGF0aCA9IE9wdGlvbi5TdHJpbmcoJy0tcGFja2FnZS1qc29uLXBhdGgnLCAncGFja2FnZS5qc29uJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgcGFja2FnZS5qc29uYCcsXG4gIH0pXG5cbiAgb3V0cHV0RGlyID0gT3B0aW9uLlN0cmluZygnLS1vdXRwdXQtZGlyLC1vJywgJy4vJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggdG8gdGhlIGZvbGRlciB3aGVyZSBhbGwgYnVpbHQgYC5ub2RlYCBmaWxlcyBwdXQsIHNhbWUgYXMgYC0tb3V0cHV0LWRpcmAgb2YgYnVpbGQgY29tbWFuZCcsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGNvbmZpZ1BhdGg6IHRoaXMuY29uZmlnUGF0aCxcbiAgICAgIHBhY2thZ2VKc29uUGF0aDogdGhpcy5wYWNrYWdlSnNvblBhdGgsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbWJpbGUgYnVpbHQgYmluYXJpZXMgaW50byBvbmUgdW5pdmVyc2FsIGJpbmFyeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVuaXZlcnNhbGl6ZU9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIHdvcmtpbmcgZGlyZWN0b3J5IG9mIHdoZXJlIG5hcGkgY29tbWFuZCB3aWxsIGJlIGV4ZWN1dGVkIGluLCBhbGwgb3RoZXIgcGF0aHMgb3B0aW9ucyBhcmUgcmVsYXRpdmUgdG8gdGhpcyBwYXRoXG4gICAqXG4gICAqIEBkZWZhdWx0IHByb2Nlc3MuY3dkKClcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKlxuICAgKiBAZGVmYXVsdCAncGFja2FnZS5qc29uJ1xuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBQYXRoIHRvIHRoZSBmb2xkZXIgd2hlcmUgYWxsIGJ1aWx0IGAubm9kZWAgZmlsZXMgcHV0LCBzYW1lIGFzIGAtLW91dHB1dC1kaXJgIG9mIGJ1aWxkIGNvbW1hbmRcbiAgICpcbiAgICogQGRlZmF1bHQgJy4vJ1xuICAgKi9cbiAgb3V0cHV0RGlyPzogc3RyaW5nXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRVbml2ZXJzYWxpemVPcHRpb25zKG9wdGlvbnM6IFVuaXZlcnNhbGl6ZU9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgcGFja2FnZUpzb25QYXRoOiAncGFja2FnZS5qc29uJyxcbiAgICBvdXRwdXREaXI6ICcuLycsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgc3Bhd25TeW5jIH0gZnJvbSAnbm9kZTpjaGlsZF9wcm9jZXNzJ1xuaW1wb3J0IHsgam9pbiwgcmVzb2x2ZSB9IGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHtcbiAgYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyxcbiAgdHlwZSBVbml2ZXJzYWxpemVPcHRpb25zLFxufSBmcm9tICcuLi9kZWYvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuLi91dGlscy9jb25maWcuanMnXG5pbXBvcnQgeyBkZWJ1Z0ZhY3RvcnkgfSBmcm9tICcuLi91dGlscy9sb2cuanMnXG5pbXBvcnQgeyBmaWxlRXhpc3RzIH0gZnJvbSAnLi4vdXRpbHMvbWlzYy5qcydcbmltcG9ydCB7IFVuaUFyY2hzQnlQbGF0Zm9ybSB9IGZyb20gJy4uL3V0aWxzL3RhcmdldC5qcydcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ3VuaXZlcnNhbGl6ZScpXG5cbmNvbnN0IHVuaXZlcnNhbGl6ZXJzOiBQYXJ0aWFsPFxuICBSZWNvcmQ8Tm9kZUpTLlBsYXRmb3JtLCAoaW5wdXRzOiBzdHJpbmdbXSwgb3V0cHV0OiBzdHJpbmcpID0+IHZvaWQ+XG4+ID0ge1xuICBkYXJ3aW46IChpbnB1dHMsIG91dHB1dCkgPT4ge1xuICAgIHNwYXduU3luYygnbGlwbycsIFsnLWNyZWF0ZScsICctb3V0cHV0Jywgb3V0cHV0LCAuLi5pbnB1dHNdLCB7XG4gICAgICBzdGRpbzogJ2luaGVyaXQnLFxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1bml2ZXJzYWxpemVCaW5hcmllcyh1c2VyT3B0aW9uczogVW5pdmVyc2FsaXplT3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zID0gYXBwbHlEZWZhdWx0VW5pdmVyc2FsaXplT3B0aW9ucyh1c2VyT3B0aW9ucylcblxuICBjb25zdCBwYWNrYWdlSnNvblBhdGggPSBqb2luKG9wdGlvbnMuY3dkLCBvcHRpb25zLnBhY2thZ2VKc29uUGF0aClcblxuICBjb25zdCBjb25maWcgPSBhd2FpdCByZWFkTmFwaUNvbmZpZyhcbiAgICBwYWNrYWdlSnNvblBhdGgsXG4gICAgb3B0aW9ucy5jb25maWdQYXRoID8gcmVzb2x2ZShvcHRpb25zLmN3ZCwgb3B0aW9ucy5jb25maWdQYXRoKSA6IHVuZGVmaW5lZCxcbiAgKVxuXG4gIGNvbnN0IHRhcmdldCA9IGNvbmZpZy50YXJnZXRzLmZpbmQoXG4gICAgKHQpID0+IHQucGxhdGZvcm0gPT09IHByb2Nlc3MucGxhdGZvcm0gJiYgdC5hcmNoID09PSAndW5pdmVyc2FsJyxcbiAgKVxuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3QgZm91bmQgaW4gY29uZmlnIWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgc3JjRmlsZXMgPSBVbmlBcmNoc0J5UGxhdGZvcm1bcHJvY2Vzcy5wbGF0Zm9ybV0/Lm1hcCgoYXJjaCkgPT5cbiAgICByZXNvbHZlKFxuICAgICAgb3B0aW9ucy5jd2QsXG4gICAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICAgIGAke2NvbmZpZy5iaW5hcnlOYW1lfS4ke3Byb2Nlc3MucGxhdGZvcm19LSR7YXJjaH0ubm9kZWAsXG4gICAgKSxcbiAgKVxuXG4gIGlmICghc3JjRmlsZXMgfHwgIXVuaXZlcnNhbGl6ZXJzW3Byb2Nlc3MucGxhdGZvcm1dKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYCd1bml2ZXJzYWwnIGFyY2ggZm9yIHBsYXRmb3JtICcke3Byb2Nlc3MucGxhdGZvcm19JyBub3Qgc3VwcG9ydGVkLmAsXG4gICAgKVxuICB9XG5cbiAgZGVidWcoYExvb2tpbmcgdXAgc291cmNlIGJpbmFyaWVzIHRvIGNvbWJpbmU6IGApXG4gIGRlYnVnKCcgICVPJywgc3JjRmlsZXMpXG5cbiAgY29uc3Qgc3JjRmlsZUxvb2t1cCA9IGF3YWl0IFByb21pc2UuYWxsKHNyY0ZpbGVzLm1hcCgoZikgPT4gZmlsZUV4aXN0cyhmKSkpXG5cbiAgY29uc3Qgbm90Rm91bmRGaWxlcyA9IHNyY0ZpbGVzLmZpbHRlcigoXywgaSkgPT4gIXNyY0ZpbGVMb29rdXBbaV0pXG5cbiAgaWYgKG5vdEZvdW5kRmlsZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFNvbWUgYmluYXJ5IGZpbGVzIHdlcmUgbm90IGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KG5vdEZvdW5kRmlsZXMpfWAsXG4gICAgKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gcmVzb2x2ZShcbiAgICBvcHRpb25zLmN3ZCxcbiAgICBvcHRpb25zLm91dHB1dERpcixcbiAgICBgJHtjb25maWcuYmluYXJ5TmFtZX0uJHtwcm9jZXNzLnBsYXRmb3JtfS11bml2ZXJzYWwubm9kZWAsXG4gIClcblxuICB1bml2ZXJzYWxpemVyc1twcm9jZXNzLnBsYXRmb3JtXT8uKHNyY0ZpbGVzLCBvdXRwdXQpXG5cbiAgZGVidWcoYFByb2R1Y2VkIHVuaXZlcnNhbCBiaW5hcnk6ICR7b3V0cHV0fWApXG59XG4iLCJpbXBvcnQgeyBDb21tYW5kIH0gZnJvbSAnY2xpcGFuaW9uJ1xuXG5pbXBvcnQgeyBjb2xsZWN0QXJ0aWZhY3RzIH0gZnJvbSAnLi4vYXBpL2FydGlmYWN0cy5qcydcbmltcG9ydCB7IEJhc2VBcnRpZmFjdHNDb21tYW5kIH0gZnJvbSAnLi4vZGVmL2FydGlmYWN0cy5qcydcblxuZXhwb3J0IGNsYXNzIEFydGlmYWN0c0NvbW1hbmQgZXh0ZW5kcyBCYXNlQXJ0aWZhY3RzQ29tbWFuZCB7XG4gIHN0YXRpYyB1c2FnZSA9IENvbW1hbmQuVXNhZ2Uoe1xuICAgIGRlc2NyaXB0aW9uOiAnQ29weSBhcnRpZmFjdHMgZnJvbSBHaXRodWIgQWN0aW9ucyBpbnRvIHNwZWNpZmllZCBkaXInLFxuICAgIGV4YW1wbGVzOiBbXG4gICAgICBbXG4gICAgICAgICckMCBhcnRpZmFjdHMgLS1vdXRwdXQtZGlyIC4vYXJ0aWZhY3RzIC0tZGlzdCAuL25wbScsXG4gICAgICAgIGBDb3B5IFtiaW5hcnlOYW1lXS5bcGxhdGZvcm1dLm5vZGUgdW5kZXIgY3VycmVudCBkaXIoLikgaW50byBwYWNrYWdlcyB1bmRlciBucG0gZGlyLlxuZS5nOiBpbmRleC5saW51eC14NjQtZ251Lm5vZGUgLS0+IC4vbnBtL2xpbnV4LXg2NC1nbnUvaW5kZXgubGludXgteDY0LWdudS5ub2RlYCxcbiAgICAgIF0sXG4gICAgXSxcbiAgfSlcblxuICBzdGF0aWMgcGF0aHMgPSBbWydhcnRpZmFjdHMnXV1cblxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IGNvbGxlY3RBcnRpZmFjdHModGhpcy5nZXRPcHRpb25zKCkpXG4gIH1cbn1cbiIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgYnkgY29kZWdlbi9pbmRleC50c1xuLy8gRG8gbm90IGVkaXQgdGhpcyBmaWxlIG1hbnVhbGx5XG5pbXBvcnQgeyBDb21tYW5kLCBPcHRpb24gfSBmcm9tICdjbGlwYW5pb24nXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQnVpbGRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZCB7XG4gIHN0YXRpYyBwYXRocyA9IFtbJ2J1aWxkJ11dXG5cbiAgc3RhdGljIHVzYWdlID0gQ29tbWFuZC5Vc2FnZSh7XG4gICAgZGVzY3JpcHRpb246ICdCdWlsZCB0aGUgTkFQSS1SUyBwcm9qZWN0JyxcbiAgfSlcblxuICB0YXJnZXQ/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLXRhcmdldCwtdCcsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdCdWlsZCBmb3IgdGhlIHRhcmdldCB0cmlwbGUsIGJ5cGFzc2VkIHRvIGBjYXJnbyBidWlsZCAtLXRhcmdldGAnLFxuICB9KVxuXG4gIGN3ZD86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tY3dkJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1RoZSB3b3JraW5nIGRpcmVjdG9yeSBvZiB3aGVyZSBuYXBpIGNvbW1hbmQgd2lsbCBiZSBleGVjdXRlZCBpbiwgYWxsIG90aGVyIHBhdGhzIG9wdGlvbnMgYXJlIHJlbGF0aXZlIHRvIHRoaXMgcGF0aCcsXG4gIH0pXG5cbiAgbWFuaWZlc3RQYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1tYW5pZmVzdC1wYXRoJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgQ2FyZ28udG9tbGAnLFxuICB9KVxuXG4gIGNvbmZpZ1BhdGg/OiBzdHJpbmcgPSBPcHRpb24uU3RyaW5nKCctLWNvbmZpZy1wYXRoLC1jJywge1xuICAgIGRlc2NyaXB0aW9uOiAnUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZScsXG4gIH0pXG5cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLWpzb24tcGF0aCcsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1BhdGggdG8gYHBhY2thZ2UuanNvbmAnLFxuICB9KVxuXG4gIHRhcmdldERpcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tdGFyZ2V0LWRpcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdEaXJlY3RvcnkgZm9yIGFsbCBjcmF0ZSBnZW5lcmF0ZWQgYXJ0aWZhY3RzLCBzZWUgYGNhcmdvIGJ1aWxkIC0tdGFyZ2V0LWRpcmAnLFxuICB9KVxuXG4gIG91dHB1dERpcj86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tb3V0cHV0LWRpciwtbycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdQYXRoIHRvIHdoZXJlIGFsbCB0aGUgYnVpbHQgZmlsZXMgd291bGQgYmUgcHV0LiBEZWZhdWx0IHRvIHRoZSBjcmF0ZSBmb2xkZXInLFxuICB9KVxuXG4gIHBsYXRmb3JtPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXBsYXRmb3JtJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0FkZCBwbGF0Zm9ybSB0cmlwbGUgdG8gdGhlIGdlbmVyYXRlZCBub2RlanMgYmluZGluZyBmaWxlLCBlZzogYFtuYW1lXS5saW51eC14NjQtZ251Lm5vZGVgJyxcbiAgfSlcblxuICBqc1BhY2thZ2VOYW1lPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1qcy1wYWNrYWdlLW5hbWUnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGFja2FnZSBuYW1lIGluIGdlbmVyYXRlZCBqcyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZycsXG4gIH0pXG5cbiAgY29uc3RFbnVtPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLWNvbnN0LWVudW0nLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIGdlbmVyYXRlIGNvbnN0IGVudW0gZm9yIHR5cGVzY3JpcHQgYmluZGluZ3MnLFxuICB9KVxuXG4gIGpzQmluZGluZz86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tanMnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGF0aCBhbmQgZmlsZW5hbWUgb2YgZ2VuZXJhdGVkIEpTIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnLiBSZWxhdGl2ZSB0byBgLS1vdXRwdXQtZGlyYC4nLFxuICB9KVxuXG4gIG5vSnNCaW5kaW5nPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLW5vLWpzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1doZXRoZXIgdG8gZGlzYWJsZSB0aGUgZ2VuZXJhdGlvbiBKUyBiaW5kaW5nIGZpbGUuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy4nLFxuICB9KVxuXG4gIGR0cz86IHN0cmluZyA9IE9wdGlvbi5TdHJpbmcoJy0tZHRzJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1BhdGggYW5kIGZpbGVuYW1lIG9mIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBSZWxhdGl2ZSB0byBgLS1vdXRwdXQtZGlyYCcsXG4gIH0pXG5cbiAgZHRzSGVhZGVyPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1kdHMtaGVhZGVyJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ0N1c3RvbSBmaWxlIGhlYWRlciBmb3IgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIE9ubHkgd29ya3Mgd2hlbiBgdHlwZWRlZmAgZmVhdHVyZSBlbmFibGVkLicsXG4gIH0pXG5cbiAgbm9EdHNIZWFkZXI/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tbm8tZHRzLWhlYWRlcicsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdXaGV0aGVyIHRvIGRpc2FibGUgdGhlIGRlZmF1bHQgZmlsZSBoZWFkZXIgZm9yIGdlbmVyYXRlZCB0eXBlIGRlZiBmaWxlLiBPbmx5IHdvcmtzIHdoZW4gYHR5cGVkZWZgIGZlYXR1cmUgZW5hYmxlZC4nLFxuICB9KVxuXG4gIGR0c0NhY2hlID0gT3B0aW9uLkJvb2xlYW4oJy0tZHRzLWNhY2hlJywgdHJ1ZSwge1xuICAgIGRlc2NyaXB0aW9uOiAnV2hldGhlciB0byBlbmFibGUgdGhlIGR0cyBjYWNoZSwgZGVmYXVsdCB0byB0cnVlJyxcbiAgfSlcblxuICBlc20/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tZXNtJywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ1doZXRoZXIgdG8gZW1pdCBhbiBFU00gSlMgYmluZGluZyBmaWxlIGluc3RlYWQgb2YgQ0pTIGZvcm1hdC4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnLicsXG4gIH0pXG5cbiAgc3RyaXA/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tc3RyaXAsLXMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdXaGV0aGVyIHN0cmlwIHRoZSBsaWJyYXJ5IHRvIGFjaGlldmUgdGhlIG1pbmltdW0gZmlsZSBzaXplJyxcbiAgfSlcblxuICByZWxlYXNlPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXJlbGVhc2UsLXInLCB7XG4gICAgZGVzY3JpcHRpb246ICdCdWlsZCBpbiByZWxlYXNlIG1vZGUnLFxuICB9KVxuXG4gIHZlcmJvc2U/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tdmVyYm9zZSwtdicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1ZlcmJvc2VseSBsb2cgYnVpbGQgY29tbWFuZCB0cmFjZScsXG4gIH0pXG5cbiAgYmluPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1iaW4nLCB7XG4gICAgZGVzY3JpcHRpb246ICdCdWlsZCBvbmx5IHRoZSBzcGVjaWZpZWQgYmluYXJ5JyxcbiAgfSlcblxuICBwYWNrYWdlPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1wYWNrYWdlLC1wJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgdGhlIHNwZWNpZmllZCBsaWJyYXJ5IG9yIHRoZSBvbmUgYXQgY3dkJyxcbiAgfSlcblxuICBwcm9maWxlPzogc3RyaW5nID0gT3B0aW9uLlN0cmluZygnLS1wcm9maWxlJywge1xuICAgIGRlc2NyaXB0aW9uOiAnQnVpbGQgYXJ0aWZhY3RzIHdpdGggdGhlIHNwZWNpZmllZCBwcm9maWxlJyxcbiAgfSlcblxuICBjcm9zc0NvbXBpbGU/OiBib29sZWFuID0gT3B0aW9uLkJvb2xlYW4oJy0tY3Jvc3MtY29tcGlsZSwteCcsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdbZXhwZXJpbWVudGFsXSBjcm9zcy1jb21waWxlIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCB3aXRoIGBjYXJnby14d2luYCBvbiB3aW5kb3dzIGFuZCBgY2FyZ28temlnYnVpbGRgIG9uIG90aGVyIHBsYXRmb3JtJyxcbiAgfSlcblxuICB1c2VDcm9zcz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS11c2UtY3Jvc3MnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnW2V4cGVyaW1lbnRhbF0gdXNlIFtjcm9zc10oaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzLXJzL2Nyb3NzKSBpbnN0ZWFkIG9mIGBjYXJnb2AnLFxuICB9KVxuXG4gIHVzZU5hcGlDcm9zcz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS11c2UtbmFwaS1jcm9zcycsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdbZXhwZXJpbWVudGFsXSB1c2UgQG5hcGktcnMvY3Jvc3MtdG9vbGNoYWluIHRvIGNyb3NzLWNvbXBpbGUgTGludXggYXJtL2FybTY0L3g2NCBnbnUgdGFyZ2V0cy4nLFxuICB9KVxuXG4gIHdhdGNoPzogYm9vbGVhbiA9IE9wdGlvbi5Cb29sZWFuKCctLXdhdGNoLC13Jywge1xuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgJ3dhdGNoIHRoZSBjcmF0ZSBjaGFuZ2VzIGFuZCBidWlsZCBjb250aW51b3VzbHkgd2l0aCBgY2FyZ28td2F0Y2hgIGNyYXRlcycsXG4gIH0pXG5cbiAgZmVhdHVyZXM/OiBzdHJpbmdbXSA9IE9wdGlvbi5BcnJheSgnLS1mZWF0dXJlcywtRicsIHtcbiAgICBkZXNjcmlwdGlvbjogJ1NwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIGZlYXR1cmVzIHRvIGFjdGl2YXRlJyxcbiAgfSlcblxuICBhbGxGZWF0dXJlcz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1hbGwtZmVhdHVyZXMnLCB7XG4gICAgZGVzY3JpcHRpb246ICdBY3RpdmF0ZSBhbGwgYXZhaWxhYmxlIGZlYXR1cmVzJyxcbiAgfSlcblxuICBub0RlZmF1bHRGZWF0dXJlcz86IGJvb2xlYW4gPSBPcHRpb24uQm9vbGVhbignLS1uby1kZWZhdWx0LWZlYXR1cmVzJywge1xuICAgIGRlc2NyaXB0aW9uOiAnRG8gbm90IGFjdGl2YXRlIHRoZSBgZGVmYXVsdGAgZmVhdHVyZScsXG4gIH0pXG5cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICBtYW5pZmVzdFBhdGg6IHRoaXMubWFuaWZlc3RQYXRoLFxuICAgICAgY29uZmlnUGF0aDogdGhpcy5jb25maWdQYXRoLFxuICAgICAgcGFja2FnZUpzb25QYXRoOiB0aGlzLnBhY2thZ2VKc29uUGF0aCxcbiAgICAgIHRhcmdldERpcjogdGhpcy50YXJnZXREaXIsXG4gICAgICBvdXRwdXREaXI6IHRoaXMub3V0cHV0RGlyLFxuICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICBqc1BhY2thZ2VOYW1lOiB0aGlzLmpzUGFja2FnZU5hbWUsXG4gICAgICBjb25zdEVudW06IHRoaXMuY29uc3RFbnVtLFxuICAgICAganNCaW5kaW5nOiB0aGlzLmpzQmluZGluZyxcbiAgICAgIG5vSnNCaW5kaW5nOiB0aGlzLm5vSnNCaW5kaW5nLFxuICAgICAgZHRzOiB0aGlzLmR0cyxcbiAgICAgIGR0c0hlYWRlcjogdGhpcy5kdHNIZWFkZXIsXG4gICAgICBub0R0c0hlYWRlcjogdGhpcy5ub0R0c0hlYWRlcixcbiAgICAgIGR0c0NhY2hlOiB0aGlzLmR0c0NhY2hlLFxuICAgICAgZXNtOiB0aGlzLmVzbSxcbiAgICAgIHN0cmlwOiB0aGlzLnN0cmlwLFxuICAgICAgcmVsZWFzZTogdGhpcy5yZWxlYXNlLFxuICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NlLFxuICAgICAgYmluOiB0aGlzLmJpbixcbiAgICAgIHBhY2thZ2U6IHRoaXMucGFja2FnZSxcbiAgICAgIHByb2ZpbGU6IHRoaXMucHJvZmlsZSxcbiAgICAgIGNyb3NzQ29tcGlsZTogdGhpcy5jcm9zc0NvbXBpbGUsXG4gICAgICB1c2VDcm9zczogdGhpcy51c2VDcm9zcyxcbiAgICAgIHVzZU5hcGlDcm9zczogdGhpcy51c2VOYXBpQ3Jvc3MsXG4gICAgICB3YXRjaDogdGhpcy53YXRjaCxcbiAgICAgIGZlYXR1cmVzOiB0aGlzLmZlYXR1cmVzLFxuICAgICAgYWxsRmVhdHVyZXM6IHRoaXMuYWxsRmVhdHVyZXMsXG4gICAgICBub0RlZmF1bHRGZWF0dXJlczogdGhpcy5ub0RlZmF1bHRGZWF0dXJlcyxcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCdWlsZCB0aGUgTkFQSS1SUyBwcm9qZWN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQnVpbGRPcHRpb25zIHtcbiAgLyoqXG4gICAqIEJ1aWxkIGZvciB0aGUgdGFyZ2V0IHRyaXBsZSwgYnlwYXNzZWQgdG8gYGNhcmdvIGJ1aWxkIC0tdGFyZ2V0YFxuICAgKi9cbiAgdGFyZ2V0Pzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgd29ya2luZyBkaXJlY3Rvcnkgb2Ygd2hlcmUgbmFwaSBjb21tYW5kIHdpbGwgYmUgZXhlY3V0ZWQgaW4sIGFsbCBvdGhlciBwYXRocyBvcHRpb25zIGFyZSByZWxhdGl2ZSB0byB0aGlzIHBhdGhcbiAgICovXG4gIGN3ZD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgQ2FyZ28udG9tbGBcbiAgICovXG4gIG1hbmlmZXN0UGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgbmFwaWAgY29uZmlnIGpzb24gZmlsZVxuICAgKi9cbiAgY29uZmlnUGF0aD86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byBgcGFja2FnZS5qc29uYFxuICAgKi9cbiAgcGFja2FnZUpzb25QYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBEaXJlY3RvcnkgZm9yIGFsbCBjcmF0ZSBnZW5lcmF0ZWQgYXJ0aWZhY3RzLCBzZWUgYGNhcmdvIGJ1aWxkIC0tdGFyZ2V0LWRpcmBcbiAgICovXG4gIHRhcmdldERpcj86IHN0cmluZ1xuICAvKipcbiAgICogUGF0aCB0byB3aGVyZSBhbGwgdGhlIGJ1aWx0IGZpbGVzIHdvdWxkIGJlIHB1dC4gRGVmYXVsdCB0byB0aGUgY3JhdGUgZm9sZGVyXG4gICAqL1xuICBvdXRwdXREaXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEFkZCBwbGF0Zm9ybSB0cmlwbGUgdG8gdGhlIGdlbmVyYXRlZCBub2RlanMgYmluZGluZyBmaWxlLCBlZzogYFtuYW1lXS5saW51eC14NjQtZ251Lm5vZGVgXG4gICAqL1xuICBwbGF0Zm9ybT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFBhY2thZ2UgbmFtZSBpbiBnZW5lcmF0ZWQganMgYmluZGluZyBmaWxlLiBPbmx5IHdvcmtzIHdpdGggYC0tcGxhdGZvcm1gIGZsYWdcbiAgICovXG4gIGpzUGFja2FnZU5hbWU/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgZ2VuZXJhdGUgY29uc3QgZW51bSBmb3IgdHlwZXNjcmlwdCBiaW5kaW5nc1xuICAgKi9cbiAgY29uc3RFbnVtPzogYm9vbGVhblxuICAvKipcbiAgICogUGF0aCBhbmQgZmlsZW5hbWUgb2YgZ2VuZXJhdGVkIEpTIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnLiBSZWxhdGl2ZSB0byBgLS1vdXRwdXQtZGlyYC5cbiAgICovXG4gIGpzQmluZGluZz86IHN0cmluZ1xuICAvKipcbiAgICogV2hldGhlciB0byBkaXNhYmxlIHRoZSBnZW5lcmF0aW9uIEpTIGJpbmRpbmcgZmlsZS4gT25seSB3b3JrcyB3aXRoIGAtLXBsYXRmb3JtYCBmbGFnLlxuICAgKi9cbiAgbm9Kc0JpbmRpbmc/OiBib29sZWFuXG4gIC8qKlxuICAgKiBQYXRoIGFuZCBmaWxlbmFtZSBvZiBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gUmVsYXRpdmUgdG8gYC0tb3V0cHV0LWRpcmBcbiAgICovXG4gIGR0cz86IHN0cmluZ1xuICAvKipcbiAgICogQ3VzdG9tIGZpbGUgaGVhZGVyIGZvciBnZW5lcmF0ZWQgdHlwZSBkZWYgZmlsZS4gT25seSB3b3JrcyB3aGVuIGB0eXBlZGVmYCBmZWF0dXJlIGVuYWJsZWQuXG4gICAqL1xuICBkdHNIZWFkZXI/OiBzdHJpbmdcbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZGlzYWJsZSB0aGUgZGVmYXVsdCBmaWxlIGhlYWRlciBmb3IgZ2VuZXJhdGVkIHR5cGUgZGVmIGZpbGUuIE9ubHkgd29ya3Mgd2hlbiBgdHlwZWRlZmAgZmVhdHVyZSBlbmFibGVkLlxuICAgKi9cbiAgbm9EdHNIZWFkZXI/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgZHRzIGNhY2hlLCBkZWZhdWx0IHRvIHRydWVcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZHRzQ2FjaGU/OiBib29sZWFuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVtaXQgYW4gRVNNIEpTIGJpbmRpbmcgZmlsZSBpbnN0ZWFkIG9mIENKUyBmb3JtYXQuIE9ubHkgd29ya3Mgd2l0aCBgLS1wbGF0Zm9ybWAgZmxhZy5cbiAgICovXG4gIGVzbT86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFdoZXRoZXIgc3RyaXAgdGhlIGxpYnJhcnkgdG8gYWNoaWV2ZSB0aGUgbWluaW11bSBmaWxlIHNpemVcbiAgICovXG4gIHN0cmlwPzogYm9vbGVhblxuICAvKipcbiAgICogQnVpbGQgaW4gcmVsZWFzZSBtb2RlXG4gICAqL1xuICByZWxlYXNlPzogYm9vbGVhblxuICAvKipcbiAgICogVmVyYm9zZWx5IGxvZyBidWlsZCBjb21tYW5kIHRyYWNlXG4gICAqL1xuICB2ZXJib3NlPzogYm9vbGVhblxuICAvKipcbiAgICogQnVpbGQgb25seSB0aGUgc3BlY2lmaWVkIGJpbmFyeVxuICAgKi9cbiAgYmluPzogc3RyaW5nXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgc3BlY2lmaWVkIGxpYnJhcnkgb3IgdGhlIG9uZSBhdCBjd2RcbiAgICovXG4gIHBhY2thZ2U/OiBzdHJpbmdcbiAgLyoqXG4gICAqIEJ1aWxkIGFydGlmYWN0cyB3aXRoIHRoZSBzcGVjaWZpZWQgcHJvZmlsZVxuICAgKi9cbiAgcHJvZmlsZT86IHN0cmluZ1xuICAvKipcbiAgICogW2V4cGVyaW1lbnRhbF0gY3Jvc3MtY29tcGlsZSBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQgd2l0aCBgY2FyZ28teHdpbmAgb24gd2luZG93cyBhbmQgYGNhcmdvLXppZ2J1aWxkYCBvbiBvdGhlciBwbGF0Zm9ybVxuICAgKi9cbiAgY3Jvc3NDb21waWxlPzogYm9vbGVhblxuICAvKipcbiAgICogW2V4cGVyaW1lbnRhbF0gdXNlIFtjcm9zc10oaHR0cHM6Ly9naXRodWIuY29tL2Nyb3NzLXJzL2Nyb3NzKSBpbnN0ZWFkIG9mIGBjYXJnb2BcbiAgICovXG4gIHVzZUNyb3NzPzogYm9vbGVhblxuICAvKipcbiAgICogW2V4cGVyaW1lbnRhbF0gdXNlIEBuYXBpLXJzL2Nyb3NzLXRvb2xjaGFpbiB0byBjcm9zcy1jb21waWxlIExpbnV4IGFybS9hcm02NC94NjQgZ251IHRhcmdldHMuXG4gICAqL1xuICB1c2VOYXBpQ3Jvc3M/OiBib29sZWFuXG4gIC8qKlxuICAgKiB3YXRjaCB0aGUgY3JhdGUgY2hhbmdlcyBhbmQgYnVpbGQgY29udGludW91c2x5IHdpdGggYGNhcmdvLXdhdGNoYCBjcmF0ZXNcbiAgICovXG4gIHdhdGNoPzogYm9vbGVhblxuICAvKipcbiAgICogU3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2YgZmVhdHVyZXMgdG8gYWN0aXZhdGVcbiAgICovXG4gIGZlYXR1cmVzPzogc3RyaW5nW11cbiAgLyoqXG4gICAqIEFjdGl2YXRlIGFsbCBhdmFpbGFibGUgZmVhdHVyZXNcbiAgICovXG4gIGFsbEZlYXR1cmVzPzogYm9vbGVhblxuICAvKipcbiAgICogRG8gbm90IGFjdGl2YXRlIHRoZSBgZGVmYXVsdGAgZmVhdHVyZVxuICAgKi9cbiAgbm9EZWZhdWx0RmVhdHVyZXM/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcHBseURlZmF1bHRCdWlsZE9wdGlvbnMob3B0aW9uczogQnVpbGRPcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgZHRzQ2FjaGU6IHRydWUsXG4gICAgLi4ub3B0aW9ucyxcbiAgfVxufVxuIiwiaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnXG5cbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgYnVpbGRQcm9qZWN0IH0gZnJvbSAnLi4vYXBpL2J1aWxkLmpzJ1xuaW1wb3J0IHsgQmFzZUJ1aWxkQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9idWlsZC5qcydcbmltcG9ydCB7IGRlYnVnRmFjdG9yeSB9IGZyb20gJy4uL3V0aWxzL2luZGV4LmpzJ1xuXG5jb25zdCBkZWJ1ZyA9IGRlYnVnRmFjdG9yeSgnYnVpbGQnKVxuXG5leHBvcnQgY2xhc3MgQnVpbGRDb21tYW5kIGV4dGVuZHMgQmFzZUJ1aWxkQ29tbWFuZCB7XG4gIHBpcGUgPSBPcHRpb24uU3RyaW5nKCctLXBpcGUnLCB7XG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnUGlwZSBhbGwgb3V0cHV0cyBmaWxlIHRvIGdpdmVuIGNvbW1hbmQuIGUuZy4gYG5hcGkgYnVpbGQgLS1waXBlIFwibnB4IHByZXR0aWVyIC0td3JpdGVcImAnLFxuICB9KVxuXG4gIGNhcmdvT3B0aW9ucyA9IE9wdGlvbi5SZXN0KClcblxuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGNvbnN0IHsgdGFzayB9ID0gYXdhaXQgYnVpbGRQcm9qZWN0KHtcbiAgICAgIC4uLnRoaXMuZ2V0T3B0aW9ucygpLFxuICAgICAgY2FyZ29PcHRpb25zOiB0aGlzLmNhcmdvT3B0aW9ucyxcbiAgICB9KVxuXG4gICAgY29uc3Qgb3V0cHV0cyA9IGF3YWl0IHRhc2tcblxuICAgIGlmICh0aGlzLnBpcGUpIHtcbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIG91dHB1dHMpIHtcbiAgICAgICAgZGVidWcoJ1BpcGluZyBvdXRwdXQgZmlsZSB0byBjb21tYW5kOiAlcycsIHRoaXMucGlwZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBleGVjU3luYyhgJHt0aGlzLnBpcGV9ICR7b3V0cHV0LnBhdGh9YCwge1xuICAgICAgICAgICAgc3RkaW86ICdpbmhlcml0JyxcbiAgICAgICAgICAgIGN3ZDogdGhpcy5jd2QsXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnLmVycm9yKGBGYWlsZWQgdG8gcGlwZSBvdXRwdXQgZmlsZSAke291dHB1dC5wYXRofSB0byBjb21tYW5kYClcbiAgICAgICAgICBkZWJ1Zy5lcnJvcihlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVOcG1EaXJzIH0gZnJvbSAnLi4vYXBpL2NyZWF0ZS1ucG0tZGlycy5qcydcbmltcG9ydCB7IEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCB9IGZyb20gJy4uL2RlZi9jcmVhdGUtbnBtLWRpcnMuanMnXG5cbmV4cG9ydCBjbGFzcyBDcmVhdGVOcG1EaXJzQ29tbWFuZCBleHRlbmRzIEJhc2VDcmVhdGVOcG1EaXJzQ29tbWFuZCB7XG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgYXdhaXQgY3JlYXRlTnBtRGlycyh0aGlzLmdldE9wdGlvbnMoKSlcbiAgfVxufVxuIiwiaW1wb3J0IHsgQ29tbWFuZCB9IGZyb20gJ2NsaXBhbmlvbidcblxuLyoqXG4gKiBBIGNvbW1hbmQgdGhhdCBwcmludHMgdGhlIHVzYWdlIG9mIGFsbCBjb21tYW5kcy5cbiAqXG4gKiBQYXRoczogYC1oYCwgYC0taGVscGBcbiAqL1xuZXhwb3J0IGNsYXNzIEhlbHBDb21tYW5kIGV4dGVuZHMgQ29tbWFuZDxhbnk+IHtcbiAgc3RhdGljIHBhdGhzID0gW1tgLWhgXSwgW2AtLWhlbHBgXV1cbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCB0aGlzLmNvbnRleHQuc3Rkb3V0LndyaXRlKHRoaXMuY2xpLnVzYWdlKCkpXG4gIH1cbn1cbiIsImltcG9ydCBwYXRoIGZyb20gJ25vZGU6cGF0aCdcblxuaW1wb3J0IHsgaW5wdXQsIHNlbGVjdCwgY2hlY2tib3gsIGNvbmZpcm0gfSBmcm9tICdAaW5xdWlyZXIvcHJvbXB0cydcbmltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ2NsaXBhbmlvbidcblxuaW1wb3J0IHsgbmV3UHJvamVjdCB9IGZyb20gJy4uL2FwaS9uZXcuanMnXG5pbXBvcnQgeyBCYXNlTmV3Q29tbWFuZCB9IGZyb20gJy4uL2RlZi9uZXcuanMnXG5pbXBvcnQge1xuICBBVkFJTEFCTEVfVEFSR0VUUyxcbiAgZGVidWdGYWN0b3J5LFxuICBERUZBVUxUX1RBUkdFVFMsXG4gIHR5cGUgVGFyZ2V0VHJpcGxlLFxufSBmcm9tICcuLi91dGlscy9pbmRleC5qcydcbmltcG9ydCB7IG5hcGlFbmdpbmVSZXF1aXJlbWVudCB9IGZyb20gJy4uL3V0aWxzL3ZlcnNpb24uanMnXG5cbmNvbnN0IGRlYnVnID0gZGVidWdGYWN0b3J5KCduZXcnKVxuXG5leHBvcnQgY2xhc3MgTmV3Q29tbWFuZCBleHRlbmRzIEJhc2VOZXdDb21tYW5kIHtcbiAgaW50ZXJhY3RpdmUgPSBPcHRpb24uQm9vbGVhbignLS1pbnRlcmFjdGl2ZSwtaScsIHRydWUsIHtcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICdBc2sgcHJvamVjdCBiYXNpYyBpbmZvcm1hdGlvbiBpbnRlcmFjdGl2ZWx5IHdpdGhvdXQganVzdCB1c2luZyB0aGUgZGVmYXVsdC4nLFxuICB9KVxuXG4gIGFzeW5jIGV4ZWN1dGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCB0aGlzLmZldGNoT3B0aW9ucygpXG4gICAgICBhd2FpdCBuZXdQcm9qZWN0KG9wdGlvbnMpXG4gICAgICByZXR1cm4gMFxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdGYWlsZWQgdG8gY3JlYXRlIG5ldyBwcm9qZWN0JylcbiAgICAgIGRlYnVnLmVycm9yKGUpXG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hPcHRpb25zKCkge1xuICAgIGNvbnN0IGNtZE9wdGlvbnMgPSBzdXBlci5nZXRPcHRpb25zKClcblxuICAgIGlmICh0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICBjb25zdCB0YXJnZXRQYXRoOiBzdHJpbmcgPSBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgPyBjbWRPcHRpb25zLnBhdGhcbiAgICAgICAgOiBhd2FpdCBpbnF1aXJlclByb2plY3RQYXRoKClcbiAgICAgIGNtZE9wdGlvbnMucGF0aCA9IHRhcmdldFBhdGhcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmNtZE9wdGlvbnMsXG4gICAgICAgIG5hbWU6IGF3YWl0IHRoaXMuZmV0Y2hOYW1lKHBhdGgucGFyc2UodGFyZ2V0UGF0aCkuYmFzZSksXG4gICAgICAgIG1pbk5vZGVBcGlWZXJzaW9uOiBhd2FpdCB0aGlzLmZldGNoTmFwaVZlcnNpb24oKSxcbiAgICAgICAgdGFyZ2V0czogYXdhaXQgdGhpcy5mZXRjaFRhcmdldHMoKSxcbiAgICAgICAgbGljZW5zZTogYXdhaXQgdGhpcy5mZXRjaExpY2Vuc2UoKSxcbiAgICAgICAgZW5hYmxlVHlwZURlZjogYXdhaXQgdGhpcy5mZXRjaFR5cGVEZWYoKSxcbiAgICAgICAgZW5hYmxlR2l0aHViQWN0aW9uczogYXdhaXQgdGhpcy5mZXRjaEdpdGh1YkFjdGlvbnMoKSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY21kT3B0aW9uc1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaE5hbWUoZGVmYXVsdE5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuJCRuYW1lID8/XG4gICAgICBpbnB1dCh7XG4gICAgICAgIG1lc3NhZ2U6ICdQYWNrYWdlIG5hbWUgKHRoZSBuYW1lIGZpZWxkIGluIHlvdXIgcGFja2FnZS5qc29uIGZpbGUpJyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdE5hbWUsXG4gICAgICB9KVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hMaWNlbnNlKCk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIGlucHV0KHtcbiAgICAgIG1lc3NhZ2U6ICdMaWNlbnNlIGZvciBvcGVuLXNvdXJjZWQgcHJvamVjdCcsXG4gICAgICBkZWZhdWx0OiB0aGlzLmxpY2Vuc2UsXG4gICAgfSlcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hOYXBpVmVyc2lvbigpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBzZWxlY3Qoe1xuICAgICAgbWVzc2FnZTogJ01pbmltdW0gbm9kZS1hcGkgdmVyc2lvbiAod2l0aCBub2RlIHZlcnNpb24gcmVxdWlyZW1lbnQpJyxcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgcGFnZVNpemU6IDEwLFxuICAgICAgY2hvaWNlczogQXJyYXkuZnJvbSh7IGxlbmd0aDogOCB9LCAoXywgaSkgPT4gKHtcbiAgICAgICAgbmFtZTogYG5hcGkke2kgKyAxfSAoJHtuYXBpRW5naW5lUmVxdWlyZW1lbnQoaSArIDEpfSlgLFxuICAgICAgICB2YWx1ZTogaSArIDEsXG4gICAgICB9KSksXG4gICAgICAvLyBjaG9pY2UgaW5kZXhcbiAgICAgIGRlZmF1bHQ6IHRoaXMubWluTm9kZUFwaVZlcnNpb24gLSAxLFxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVGFyZ2V0cygpOiBQcm9taXNlPFRhcmdldFRyaXBsZVtdPiB7XG4gICAgaWYgKHRoaXMuZW5hYmxlQWxsVGFyZ2V0cykge1xuICAgICAgcmV0dXJuIEFWQUlMQUJMRV9UQVJHRVRTLmNvbmNhdCgpXG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0cyA9IGF3YWl0IGNoZWNrYm94KHtcbiAgICAgIGxvb3A6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogJ0Nob29zZSB0YXJnZXQocykgeW91ciBjcmF0ZSB3aWxsIGJlIGNvbXBpbGVkIHRvJyxcbiAgICAgIGNob2ljZXM6IEFWQUlMQUJMRV9UQVJHRVRTLm1hcCgodGFyZ2V0KSA9PiAoe1xuICAgICAgICBuYW1lOiB0YXJnZXQsXG4gICAgICAgIHZhbHVlOiB0YXJnZXQsXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgY2hlY2tlZDogREVGQVVMVF9UQVJHRVRTLmluY2x1ZGVzKHRhcmdldCksXG4gICAgICB9KSksXG4gICAgfSlcblxuICAgIHJldHVybiB0YXJnZXRzXG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGZldGNoVHlwZURlZigpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBlbmFibGVUeXBlRGVmID0gYXdhaXQgY29uZmlybSh7XG4gICAgICBtZXNzYWdlOiAnRW5hYmxlIHR5cGUgZGVmaW5pdGlvbiBhdXRvLWdlbmVyYXRpb24nLFxuICAgICAgZGVmYXVsdDogdGhpcy5lbmFibGVUeXBlRGVmLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZW5hYmxlVHlwZURlZlxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBmZXRjaEdpdGh1YkFjdGlvbnMoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgZW5hYmxlR2l0aHViQWN0aW9ucyA9IGF3YWl0IGNvbmZpcm0oe1xuICAgICAgbWVzc2FnZTogJ0VuYWJsZSBHaXRodWIgQWN0aW9ucyBDSScsXG4gICAgICBkZWZhdWx0OiB0aGlzLmVuYWJsZUdpdGh1YkFjdGlvbnMsXG4gICAgfSlcblxuICAgIHJldHVybiBlbmFibGVHaXRodWJBY3Rpb25zXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaW5xdWlyZXJQcm9qZWN0UGF0aCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICByZXR1cm4gaW5wdXQoe1xuICAgIG1lc3NhZ2U6ICdUYXJnZXQgcGF0aCB0byBjcmVhdGUgdGhlIHByb2plY3QsIHJlbGF0aXZlIHRvIGN3ZC4nLFxuICB9KS50aGVuKChwYXRoKSA9PiB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICByZXR1cm4gaW5xdWlyZXJQcm9qZWN0UGF0aCgpXG4gICAgfVxuICAgIHJldHVybiBwYXRoXG4gIH0pXG59XG4iLCJpbXBvcnQgeyBwcmVQdWJsaXNoIH0gZnJvbSAnLi4vYXBpL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgQmFzZVByZVB1Ymxpc2hDb21tYW5kIH0gZnJvbSAnLi4vZGVmL3ByZS1wdWJsaXNoLmpzJ1xuXG5leHBvcnQgY2xhc3MgUHJlUHVibGlzaENvbW1hbmQgZXh0ZW5kcyBCYXNlUHJlUHVibGlzaENvbW1hbmQge1xuICBhc3luYyBleGVjdXRlKCkge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgY29uc3QgJ25wbScgfCAnbGVybmEnIHRvIHN0cmluZ1xuICAgIGF3YWl0IHByZVB1Ymxpc2godGhpcy5nZXRPcHRpb25zKCkpXG4gIH1cbn1cbiIsImltcG9ydCB7IGlucHV0IH0gZnJvbSAnQGlucXVpcmVyL3Byb21wdHMnXG5cbmltcG9ydCB7IHJlbmFtZVByb2plY3QgfSBmcm9tICcuLi9hcGkvcmVuYW1lLmpzJ1xuaW1wb3J0IHsgQmFzZVJlbmFtZUNvbW1hbmQgfSBmcm9tICcuLi9kZWYvcmVuYW1lLmpzJ1xuXG5leHBvcnQgY2xhc3MgUmVuYW1lQ29tbWFuZCBleHRlbmRzIEJhc2VSZW5hbWVDb21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKClcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgY29uc3QgbmFtZSA9IGF3YWl0IGlucHV0KHtcbiAgICAgICAgbWVzc2FnZTogYEVudGVyIHRoZSBuZXcgcGFja2FnZSBuYW1lIGluIHRoZSBwYWNrYWdlLmpzb25gLFxuICAgICAgICByZXF1aXJlZDogdHJ1ZSxcbiAgICAgIH0pXG4gICAgICBvcHRpb25zLm5hbWUgPSBuYW1lXG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5iaW5hcnlOYW1lKSB7XG4gICAgICBjb25zdCBiaW5hcnlOYW1lID0gYXdhaXQgaW5wdXQoe1xuICAgICAgICBtZXNzYWdlOiBgRW50ZXIgdGhlIG5ldyBiaW5hcnkgbmFtZWAsXG4gICAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgfSlcbiAgICAgIG9wdGlvbnMuYmluYXJ5TmFtZSA9IGJpbmFyeU5hbWVcbiAgICB9XG4gICAgYXdhaXQgcmVuYW1lUHJvamVjdChvcHRpb25zKVxuICB9XG59XG4iLCJpbXBvcnQgeyB1bml2ZXJzYWxpemVCaW5hcmllcyB9IGZyb20gJy4uL2FwaS91bml2ZXJzYWxpemUuanMnXG5pbXBvcnQgeyBCYXNlVW5pdmVyc2FsaXplQ29tbWFuZCB9IGZyb20gJy4uL2RlZi91bml2ZXJzYWxpemUuanMnXG5cbmV4cG9ydCBjbGFzcyBVbml2ZXJzYWxpemVDb21tYW5kIGV4dGVuZHMgQmFzZVVuaXZlcnNhbGl6ZUNvbW1hbmQge1xuICBhc3luYyBleGVjdXRlKCkge1xuICAgIGF3YWl0IHVuaXZlcnNhbGl6ZUJpbmFyaWVzKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vYXBpL3ZlcnNpb24uanMnXG5pbXBvcnQgeyBCYXNlVmVyc2lvbkNvbW1hbmQgfSBmcm9tICcuLi9kZWYvdmVyc2lvbi5qcydcblxuZXhwb3J0IGNsYXNzIFZlcnNpb25Db21tYW5kIGV4dGVuZHMgQmFzZVZlcnNpb25Db21tYW5kIHtcbiAgYXN5bmMgZXhlY3V0ZSgpIHtcbiAgICBhd2FpdCB2ZXJzaW9uKHRoaXMuZ2V0T3B0aW9ucygpKVxuICB9XG59XG4iLCJpbXBvcnQgeyBDbGkgfSBmcm9tICdjbGlwYW5pb24nXG5cbmltcG9ydCB7IGNvbGxlY3RBcnRpZmFjdHMgfSBmcm9tICcuL2FwaS9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBidWlsZFByb2plY3QgfSBmcm9tICcuL2FwaS9idWlsZC5qcydcbmltcG9ydCB7IGNyZWF0ZU5wbURpcnMgfSBmcm9tICcuL2FwaS9jcmVhdGUtbnBtLWRpcnMuanMnXG5pbXBvcnQgeyBuZXdQcm9qZWN0IH0gZnJvbSAnLi9hcGkvbmV3LmpzJ1xuaW1wb3J0IHsgcHJlUHVibGlzaCB9IGZyb20gJy4vYXBpL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgcmVuYW1lUHJvamVjdCB9IGZyb20gJy4vYXBpL3JlbmFtZS5qcydcbmltcG9ydCB7IHVuaXZlcnNhbGl6ZUJpbmFyaWVzIH0gZnJvbSAnLi9hcGkvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vYXBpL3ZlcnNpb24uanMnXG5pbXBvcnQgeyBBcnRpZmFjdHNDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9hcnRpZmFjdHMuanMnXG5pbXBvcnQgeyBCdWlsZENvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL2J1aWxkLmpzJ1xuaW1wb3J0IHsgQ3JlYXRlTnBtRGlyc0NvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL2NyZWF0ZS1ucG0tZGlycy5qcydcbmltcG9ydCB7IEhlbHBDb21tYW5kIH0gZnJvbSAnLi9jb21tYW5kcy9oZWxwLmpzJ1xuaW1wb3J0IHsgTmV3Q29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvbmV3LmpzJ1xuaW1wb3J0IHsgUHJlUHVibGlzaENvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3ByZS1wdWJsaXNoLmpzJ1xuaW1wb3J0IHsgUmVuYW1lQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvcmVuYW1lLmpzJ1xuaW1wb3J0IHsgVW5pdmVyc2FsaXplQ29tbWFuZCB9IGZyb20gJy4vY29tbWFuZHMvdW5pdmVyc2FsaXplLmpzJ1xuaW1wb3J0IHsgVmVyc2lvbkNvbW1hbmQgfSBmcm9tICcuL2NvbW1hbmRzL3ZlcnNpb24uanMnXG5pbXBvcnQgeyBDTElfVkVSU0lPTiB9IGZyb20gJy4vdXRpbHMvbWlzYy5qcydcblxuZXhwb3J0IGNvbnN0IGNsaSA9IG5ldyBDbGkoe1xuICBiaW5hcnlOYW1lOiAnbmFwaScsXG4gIGJpbmFyeVZlcnNpb246IENMSV9WRVJTSU9OLFxufSlcblxuY2xpLnJlZ2lzdGVyKE5ld0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoQnVpbGRDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKENyZWF0ZU5wbURpcnNDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKEFydGlmYWN0c0NvbW1hbmQpXG5jbGkucmVnaXN0ZXIoVW5pdmVyc2FsaXplQ29tbWFuZClcbmNsaS5yZWdpc3RlcihSZW5hbWVDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFByZVB1Ymxpc2hDb21tYW5kKVxuY2xpLnJlZ2lzdGVyKFZlcnNpb25Db21tYW5kKVxuY2xpLnJlZ2lzdGVyKEhlbHBDb21tYW5kKVxuXG4vKipcbiAqXG4gKiBAdXNhZ2VcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgY2xpID0gbmV3IE5hcGlDbGkoKVxuICpcbiAqIGNsaS5idWlsZCh7XG4gKiAgIGN3ZDogJy9wYXRoL3RvL3lvdXIvcHJvamVjdCcsXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBOYXBpQ2xpIHtcbiAgYXJ0aWZhY3RzID0gY29sbGVjdEFydGlmYWN0c1xuICBuZXcgPSBuZXdQcm9qZWN0XG4gIGJ1aWxkID0gYnVpbGRQcm9qZWN0XG4gIGNyZWF0ZU5wbURpcnMgPSBjcmVhdGVOcG1EaXJzXG4gIHByZVB1Ymxpc2ggPSBwcmVQdWJsaXNoXG4gIHJlbmFtZSA9IHJlbmFtZVByb2plY3RcbiAgdW5pdmVyc2FsaXplID0gdW5pdmVyc2FsaXplQmluYXJpZXNcbiAgdmVyc2lvbiA9IHZlcnNpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUJ1aWxkQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IEJ1aWxkQ29tbWFuZCB7XG4gIHJldHVybiBjbGkucHJvY2VzcyhbJ2J1aWxkJywgLi4uYXJnc10pIGFzIEJ1aWxkQ29tbWFuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXJ0aWZhY3RzQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IEFydGlmYWN0c0NvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWydhcnRpZmFjdHMnLCAuLi5hcmdzXSkgYXMgQXJ0aWZhY3RzQ29tbWFuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3JlYXRlTnBtRGlyc0NvbW1hbmQoXG4gIGFyZ3M6IHN0cmluZ1tdLFxuKTogQ3JlYXRlTnBtRGlyc0NvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWydjcmVhdGUtbnBtLWRpcnMnLCAuLi5hcmdzXSkgYXMgQ3JlYXRlTnBtRGlyc0NvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByZVB1Ymxpc2hDb21tYW5kKGFyZ3M6IHN0cmluZ1tdKTogUHJlUHVibGlzaENvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWydwcmUtcHVibGlzaCcsIC4uLmFyZ3NdKSBhcyBQcmVQdWJsaXNoQ29tbWFuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVuYW1lQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IFJlbmFtZUNvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWydyZW5hbWUnLCAuLi5hcmdzXSkgYXMgUmVuYW1lQ29tbWFuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5pdmVyc2FsaXplQ29tbWFuZChhcmdzOiBzdHJpbmdbXSk6IFVuaXZlcnNhbGl6ZUNvbW1hbmQge1xuICByZXR1cm4gY2xpLnByb2Nlc3MoWyd1bml2ZXJzYWxpemUnLCAuLi5hcmdzXSkgYXMgVW5pdmVyc2FsaXplQ29tbWFuZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmVyc2lvbkNvbW1hbmQoYXJnczogc3RyaW5nW10pOiBWZXJzaW9uQ29tbWFuZCB7XG4gIHJldHVybiBjbGkucHJvY2VzcyhbJ3ZlcnNpb24nLCAuLi5hcmdzXSkgYXMgVmVyc2lvbkNvbW1hbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5ld0NvbW1hbmQoYXJnczogc3RyaW5nW10pOiBOZXdDb21tYW5kIHtcbiAgcmV0dXJuIGNsaS5wcm9jZXNzKFsnbmV3JywgLi4uYXJnc10pIGFzIE5ld0NvbW1hbmRcbn1cblxuZXhwb3J0IHsgcGFyc2VUcmlwbGUgfSBmcm9tICcuL3V0aWxzL3RhcmdldC5qcydcbmV4cG9ydCB7XG4gIHR5cGUgR2VuZXJhdGVUeXBlRGVmT3B0aW9ucyxcbiAgdHlwZSBXcml0ZUpzQmluZGluZ09wdGlvbnMsXG4gIHdyaXRlSnNCaW5kaW5nLFxuICBnZW5lcmF0ZVR5cGVEZWYsXG59IGZyb20gJy4vYXBpL2J1aWxkLmpzJ1xuZXhwb3J0IHsgcmVhZE5hcGlDb25maWcgfSBmcm9tICcuL3V0aWxzL2NvbmZpZy5qcydcbiJdLCJ4X2dvb2dsZV9pZ25vcmVMaXN0IjpbMTksMjAsMjEsMjIsMjMsMjQsMjUsMjZdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLElBQXNCLHVCQUF0QixjQUFtRCxRQUFRO0NBQ3pELE9BQU8sUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0NBRTlCLE9BQU8sUUFBUSxRQUFRLE1BQU0sRUFDM0IsYUFDRSw2RUFDSCxDQUFDO0NBRUYsTUFBTSxPQUFPLE9BQU8sU0FBUyxRQUFRLEtBQUssRUFBRSxFQUMxQyxhQUNFLHNIQUNILENBQUM7Q0FFRixhQUFzQixPQUFPLE9BQU8sb0JBQW9CLEVBQ3RELGFBQWEsbUNBQ2QsQ0FBQztDQUVGLGtCQUFrQixPQUFPLE9BQU8sdUJBQXVCLGdCQUFnQixFQUNyRSxhQUFhLDBCQUNkLENBQUM7Q0FFRixZQUFZLE9BQU8sT0FBTyxzQkFBc0IsZUFBZSxFQUM3RCxhQUNFLGlHQUNILENBQUM7Q0FFRixTQUFTLE9BQU8sT0FBTyxhQUFhLE9BQU8sRUFDekMsYUFBYSxpREFDZCxDQUFDO0NBRUYsaUJBQTBCLE9BQU8sT0FBTyxzQkFBc0IsRUFDNUQsYUFDRSxtRkFDSCxDQUFDO0NBRUYsYUFBYTtBQUNYLFNBQU87R0FDTCxLQUFLLEtBQUs7R0FDVixZQUFZLEtBQUs7R0FDakIsaUJBQWlCLEtBQUs7R0FDdEIsV0FBVyxLQUFLO0dBQ2hCLFFBQVEsS0FBSztHQUNiLGdCQUFnQixLQUFLO0dBQ3RCOzs7QUEwQ0wsU0FBZ0IsNkJBQTZCLFNBQTJCO0FBQ3RFLFFBQU87RUFDTCxLQUFLLFFBQVEsS0FBSztFQUNsQixpQkFBaUI7RUFDakIsV0FBVztFQUNYLFFBQVE7RUFDUixHQUFHO0VBQ0o7Ozs7O0FDckZILE1BQWEsZ0JBQWdCLGNBQXNCO0NBQ2pELE1BQU1BLFdBQVEsWUFBWSxRQUFRLGFBQWEs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